## 제4장: 일급 함수(First-Class Functions)와 고차 함수(Higher-Order Functions)

함수형 프로그래밍(FP)은 **함수를 주된 구성 요소**로 사용하는 프로그래밍 스타일입니다. 이는 코드가 함수, 루프, 조건문과 같은 블록으로 구성되는 절차적 프로그래밍이나, 상호작용하는 객체로 코드가 구성되는 객체 지향 프로그래밍(OOP)과는 다른 패러다임입니다. Python은 절차적, 객체 지향, 그리고 함수형 프로그래밍 패러다임을 모두 지원하며, 특히 함수형 개념은 코드의 간결성, 명확성, 예측 가능성, 그리고 병렬 처리에 유리하다는 장점을 가집니다.

이 장에서는 함수형 프로그래밍의 핵심 개념인 **일급 함수**와 **고차 함수**에 대해 깊이 있게 탐구하고, Python에서 이들을 어떻게 활용할 수 있는지 다양한 예시와 함께 설명합니다.

### 4.1 일급 함수(First-Class Functions)

**일급 함수는 프로그래밍 언어가 함수를 다른 일반적인 값(예: 변수, 숫자, 문자열, 객체)처럼 다룰 수 있도록 지원하는 기능**을 의미합니다. 파이썬에서는 함수도 '객체'로 취급되기 때문에, 함수를 다른 데이터처럼 자유롭게 다룰 수 있어요. 마치 여러분이 숫자나 문자열을 변수에 할당하고, 함수의 인수로 전달하고, 다른 함수의 반환 값으로 사용하는 것처럼, 함수 자체도 그렇게 할 수 있다는 뜻입니다.

Python은 함수를 일급 객체(first-class objects)로 취급하여 다음을 가능하게 합니다:

- **함수를 변수에 저장**: 함수를 변수에 할당하여 해당 변수를 통해 함수를 호출할 수 있습니다. 이는 함수에 별칭(alias)을 부여하는 것과 같으며, 함수 참조를 덮어쓸 수도 있습니다.
    

```
def say_hi(name):
	return f'Hello, {name}'

# 함수 'say_hi'를 변수 'greet'에 할당합니다.
# 이제 greet도 say_hi와 동일한 함수 객체를 가리킵니다.
greet = say_hi
print(f"say_hi의 ID: {id(say_hi)}") # say_hi 함수의 메모리 ID
print(f"greet의 ID: {id(greet)}")   # greet 변수가 가리키는 함수의 메모리 ID
# 두 ID가 동일함을 확인할 수 있습니다.

print(greet('Dilbert'))
# 출력: Hello, Dilbert
```

위 예시에서 `say_hi` 함수는 메모리에서 특정 객체를 가리키며, `greet` 변수도 동일한 객체를 가리키는 또 다른 별칭입니다.

- **함수를 다른 함수의 인수로 전달**: 함수를 다른 함수의 파라미터로 전달하여, 해당 함수 내에서 전달된 함수를 실행할 수 있습니다. 이는 코드를 일반화하고 재사용성을 높이는 데 매우 유용합니다.
    

````
def miles_to_kilometers(miles):
	return miles * 1.60934

def usd_to_chf(usd):
	return usd * 0.92

# 'converter_func'는 함수를 인수로 받습니다.
# 'value'는 변환할 값입니다.
def convert(converter_func, value):
	return converter_func(value)

print('500 miles =', convert(miles_to_kilometers, 500), 'km')
print('100 usd =', convert(usd_to_chf, 100), 'chf')
# 출력:
# 500 miles = 804.67 km
# 100 usd = 92.0 chf
```convert` 함수는 변환 함수(`miles_to_kilometers` 또는 `usd_to_chf`)와 값을 인수로 받아, 전달된 함수를 값에 적용하는 방식으로 동작합니다. 이처럼 함수를 전달함으로써 다양한 종류의 변환을 유연하게 처리할 수 있습니다. `convert` 함수는 어떤 특정 변환 로직도 알 필요 없이, 그저 '주어진 함수를 주어진 값에 적용한다'는 일반적인 역할만 수행합니다.
    
-   **함수를 다른 함수의 반환 값으로 사용**: 함수는 다른 함수의 결과로 반환될 수 있습니다. 이는 **클로저(Closures)** 및 **커링(Currying)**과 같은 고급 함수형 프로그래밍 기법에서 특히 중요하게 활용됩니다.
    
```python
def create_increment_function(step=1):
	# 이 함수는 새로운 함수(람다 함수)를 반환합니다.
	# 반환되는 람다 함수는 create_increment_function이 호출될 때의 'step' 값을 기억합니다.
	# 이렇게 외부 함수의 변수를 기억하는 내부 함수를 '클로저'라고 부릅니다.
	return lambda x: x + step

add_one = create_increment_function() # add_one은 x에 1을 더하는 함수가 됩니다.
add_two = create_increment_function(step=2) # add_two는 x에 2를 더하는 함수가 됩니다.

print(add_one(5)) # 5 + 1 = 6
print(add_two(5)) # 5 + 2 = 7
```create_increment_function`은 특정 `step` 값에 따라 값을 증가시키는 새로운 람다 함수를 반환합니다. 반환된 함수는 `step` 값을 기억하고 독립적으로 동작합니다. 이처럼 함수가 자신이 정의될 때의 환경(여기서는 `step` 변수)을 "기억"하는 것을 **클로저(Closure)**라고 부릅니다. 클로저는 함수형 프로그래밍에서 매우 강력한 도구로 사용됩니다.
    

#### 4.1.1 람다(Lambda) 함수

**람다 함수는 이름이 없는 익명 함수(anonymous function)입니다**. Python에서는 람다 미적분(Lambda calculus)의 이름을 따서 람다 함수라고 부릅니다. 람다 함수는 일반적으로 한 줄짜리 표현식으로 구성되며, 복잡하지 않은 간단한 연산에 사용됩니다. 람다 함수는 `return` 문 없이 자동으로 표현식의 결과를 반환합니다.

```python
# 일반 함수
def increment_normal(x):
    return x + 1
print(increment_normal(5)) # 출력: 6

# 람다 함수 예시: x를 받아 x+1을 반환
increment_lambda = lambda x: x + 1
print(increment_lambda(5)) # 출력: 6

# 람다 함수를 변수에 할당하지 않고 직접 호출하는 예시
print((lambda x: x ** 2)(5)) # 출력: 25 (5의 제곱)
````

람다 함수는 특히 `map()`, `filter()`, `reduce()`와 같은 고차 함수와 함께 사용될 때 강력한 도구가 됩니다. 간단한 변환이나 필터링 조건을 즉석에서 정의할 때 매우 유용하죠.

```
def calculate(op, a, b):
    # op는 함수(람다 또는 일반 함수)를 인수로 받습니다.
    return op(a, b)

print(calculate(lambda a, b: a + b, 3, 1)) # 람다로 덧셈 연산 전달. 출력: 4
print(calculate(lambda a, b: a * b, 3, 2)) # 람다로 곱셈 연산 전달. 출력: 6
```

복잡하거나 여러 번 사용되는 표현식에는 일반 함수를 사용하는 것이 좋지만, 간단하고 명확한 단일 연산에는 람다 함수를 사용하여 코드를 간결하게 만들 수 있습니다. 또한, 파이썬의 `operator` 모듈은 일반적인 연산자(`+`, `*`, `-`, `/` 등)에 대한 미리 정의된 함수를 제공하여 람다를 직접 구현할 필요 없이 고차 함수와 함께 사용할 수 있게 합니다.

```
import operator

print(calculate(operator.add, 3, 1)) # operator.add는 람다 (lambda a, b: a + b)와 동일
print(calculate(operator.mul, 3, 2)) # operator.mul은 람다 (lambda a, b: a * b)와 동일
```

### 4.2 고차 함수(Higher-Order Functions)

**고차 함수는 다른 함수를 인수로 받거나 함수를 결과로 반환하는 함수**입니다. 파이썬은 이러한 고차 함수를 모두 지원합니다. 고차 함수는 함수형 프로그래밍에서 반복문(예: `for`, `while`)이나 상태 변경(mutable state)을 피하고 **데이터 변환의 흐름을 표현**하는 데 핵심적인 역할을 합니다. 이는 코드를 더 간결하고 명확하게 만들며, 디버깅과 추론을 용이하게 합니다. 마치 공장 자동화 라인에서 각 기계(고차 함수)가 특정 작업(다른 함수)을 수행하도록 설정하고, 재료(데이터)가 이 라인을 따라 흐르면서 최종 제품으로 변환되는 것과 비슷하다고 생각할 수 있습니다.

#### 4.2.1 `map()`, `filter()`, `reduce()`

`map()`, `filter()`, `reduce()`는 함수형 프로그래밍에서 가장 흔히 사용되는 세 가지 고차 함수입니다. 이들은 반복 가능한(iterable) 객체에 함수를 적용하여 새로운 반복 가능한 객체(주로 이터레이터)를 반환합니다.

- **`map(function, iterable)`**: **주어진 함수를 반복 가능한 객체(`iterable`)의 각 요소에 적용하고, 그 결과들을 모아 새로운 반복 가능한 객체(이터레이터)를 반환합니다**. 이는 반복문을 사용하지 않고 리스트의 모든 요소에 동일한 연산을 적용할 때 유용합니다.
    

````
numbers = [1, 2, 3, 4, 5]

# 각 숫자를 제곱하는 함수
def square(x):
	return x * x

# map 함수를 사용하여 리스트의 모든 숫자를 제곱
squared_nums_iterator = map(square, numbers)
print(f"map 함수의 반환 타입: {type(squared_nums_iterator)}") # <class 'map'>
print(list(squared_nums_iterator)) # map 객체를 리스트로 변환하여 출력
# 출력: [1, 4, 9, 16, 25]

# 람다와 함께 사용 예시
cubed_nums = list(map(lambda x: x ** 3, numbers))
print(f"각 숫자의 세제곱: {cubed_nums}")
# 출력: [1, 8, 27, 64, 125]
```map`은 리스트와 같은 이터러블에 대해 연산을 수행하고, 새로운 이터러블(정확히는 이터레이터)을 반환합니다. 이터레이터는 요소를 필요할 때마다 생성하므로 메모리를 효율적으로 사용하며, 한 번만 순방향으로 처리될 수 있습니다.
    
-   **`filter(function, iterable)`**: **주어진 함수를 반복 가능한 객체의 각 요소에 적용하고, 함수가 `True`를 반환하는 요소들만을 모아 새로운 반복 가능한 객체(이터레이터)를 반환합니다**. 즉, 특정 조건을 만족하는 요소들을 걸러낼 때 사용합니다.
    
```python
numbers = range(10) # 0부터 9까지의 숫자 이터러블

# 숫자가 짝수인지 확인하는 함수
def is_even(x):
	return x % 2 == 0

# filter 함수를 사용하여 짝수만 걸러냄
even_numbers_iterator = filter(is_even, numbers)
print(f"filter 함수의 반환 타입: {type(even_numbers_iterator)}") # <class 'filter'>
print(list(even_numbers_iterator))
# 출력: [0, 2, 4, 6, 8]

# 람다와 함께 사용 예시: 5보다 큰 숫자만 필터링
greater_than_five = list(filter(lambda x: x > 5, numbers))
print(f"5보다 큰 숫자: {greater_than_five}")
# 출력: [6, 7, 8, 9]

# 홀수만 걸러내려면 `itertools.filterfalse`를 사용할 수도 있음
from itertools import filterfalse
odd_numbers = list(filterfalse(is_even, numbers))
print(f"홀수만: {odd_numbers}") # 출력: [1, 3, 5, 7, 9]
````

- **`functools.reduce(function, iterable[, initializer])`**: `reduce()` 함수는 `functools` 모듈에 포함되어 있으며, **주어진 함수를 반복 가능한 객체의 요소들에 누적적으로 적용하여 단일 결과를 생성합니다**. `reduce`는 보통 `accumulator`(누적기)와 현재 요소를 인수로 받는 함수를 사용합니다. 마치 여러 개의 숫자를 하나로 합치거나, 긴 문장을 하나의 요약으로 만드는 것처럼, 여러 요소를 하나의 값으로 "줄여나가는" 역할을 합니다.
    

````
from functools import reduce

numbers = [1, 2, 3, 4, 5]

# 모든 숫자를 더하는 함수
def sum_numbers(accumulator, current_num):
	print(f"누적: {accumulator}, 현재 숫자: {current_num} -> {accumulator + current_num}")
	return accumulator + current_num

# reduce를 사용하여 리스트의 모든 숫자를 더함
# initializer(초기값)를 지정하지 않으면, 리스트의 첫 번째 요소가 accumulator의 초기값이 됩니다.
total_sum = reduce(sum_numbers, numbers)
print(f"총합: {total_sum}")
# 출력 과정:
# 누적: 1, 현재 숫자: 2 -> 3
# 누적: 3, 현재 숫자: 3 -> 6
# 누적: 6, 현재 숫자: 4 -> 10
# 누적: 10, 현재 숫자: 5 -> 15
# 총합: 15

words = ["This", "is", "the", "first", "sentence"]

# 문자열을 연결하는 함수
def concatenate_words(accumulator, current_word):
	return accumulator + " " + current_word

# reduce를 사용하여 모든 단어를 하나의 문자열로 연결
# 초기값을 빈 문자열로 주면, 첫 번째 단어 앞에 공백이 붙는 것을 방지할 수 있습니다.
sentence = reduce(concatenate_words, words, "") # 초기값 ""
# 첫 단어의 앞 공백을 제거하기 위해 .strip()을 사용하거나,
# 첫 단어를 초기값으로 사용하고 나머지 단어에 대해 reduce를 적용할 수 있습니다.
print(sentence.strip()) # 출력: This is the first sentence
```reduce`는 반복문처럼 동작하며, `accumulator`에 계속해서 값을 재할당하는 방식으로 결과를 구축합니다. 초기값(initializer)을 설정하면 `accumulator`의 시작 값을 정해줄 수 있어 유연하게 활용할 수 있습니다.
    

#### 4.2.2 함수 합성(Function Composition)

함수 합성은 **두 개 이상의 함수를 결합하여 새로운 함수를 만드는 개념**입니다. 수학에서 $f(g(x))$와 같이 한 함수의 출력이 다른 함수의 입력으로 사용되는 것과 유사합니다. 이는 복잡한 계산 과정을 여러 개의 작고 순수한 함수로 나누어 처리한 후, 이들을 조합하여 최종 결과를 얻는 강력한 방법입니다. 마치 여러 개의 작은 기계를 연결하여 하나의 큰 생산 라인을 만드는 것과 같아요.

```python
# 함수 합성을 위한 헬퍼 함수 정의
# compose(f, g)는 g(x)의 결과를 f에 전달하는 새로운 함수를 반환합니다.
# 즉, f(g(x))와 같습니다.
def compose(f, g):
    def func(x):
        return f(g(x))
    return func

# 예시 함수: x에 1을 더하는 함수
def increment(x):
    return x + 1

# 예시 함수: x에 2를 곱하는 함수
def twice(x):
    return x * 2

# increment와 twice 함수를 합성하여 새로운 함수 'f' 생성
# f(x)는 twice(increment(x))와 같습니다.
# 즉, 먼저 1을 더하고, 그 결과에 2를 곱합니다.
f = compose(twice, increment)

print(f(1)) # (1 + 1) * 2 = 4
print(f(2)) # (2 + 1) * 2 = 6
print(f(3)) # (3 + 1) * 2 = 8

# 만약 순서를 바꾸면 어떻게 될까요?
# g(x)는 increment(twice(x))와 같습니다.
# 즉, 먼저 2를 곱하고, 그 결과에 1을 더합니다.
g = compose(increment, twice)
print(g(1)) # (1 * 2) + 1 = 3
print(g(2)) # (2 * 2) + 1 = 5
print(g(3)) # (3 * 2) + 1 = 7
````

함수 합성은 코드를 **더 명확하게 하고, 각 함수를 독립적으로 테스트하고 추론하기 쉽게** 만듭니다. 복잡한 계산이 여러 단계로 나뉘어져 있기 때문에, 문제가 발생했을 때 오류의 원인을 파악하기 쉽습니다. 반면, 절차적(procedural) 방식의 코드는 한 줄 한 줄을 해독해야 하기 때문에 추론하기 더 어렵습니다.

#### 4.2.3 파이프라인(Pipelines)

Python의 `filter()`와 `map()`과 같은 고차 함수들은 **데이터를 파이프라인 방식으로 처리**합니다. 즉, 각 항목은 한 단계씩 순차적으로 처리되며, 다음 단계로 넘어가기 전에 모든 항목이 이전 단계를 완료할 필요가 없습니다. 이를 **지연 평가(Lazy Evaluation)**라고도 부르는데, 필요한 시점에만 계산이 이루어져 메모리 효율적입니다. 마치 물이 파이프를 통해 흘러가듯이, 데이터가 한 함수를 통과하면 다음 함수로 바로 전달되어 처리되는 방식입니다.

```
def is_taxable(salary):
    print(f'is_taxable({salary}) 호출됨') # 함수가 호출되는 시점을 확인하기 위한 print
    return salary > 100000

def calc_tax(salary):
    print(f'calc_tax({salary}) 호출됨') # 함수가 호출되는 시점을 확인하기 위한 print
    return salary * 0.05

salaries = [120000, 84000, 52000, 190000]

# 파이프라인 예시: 중간 변수 없이 함수 호출을 직접 연결
# filter(is_taxable, salaries)는 과세 대상 급여를 걸러내는 이터레이터를 반환합니다.
# map(calc_tax, ...)는 걸러진 각 급여에 대해 세금을 계산하는 이터레이터를 반환합니다.
taxes_iterator = map(calc_tax, filter(is_taxable, salaries))

print("\n세금 계산 시작:")
for tax in taxes_iterator:
    print(f"계산된 세금: {tax}")

# 예상 출력 (실행 순서):
# 세금 계산 시작:
# is_taxable(120000) 호출됨
# calc_tax(120000) 호출됨
# 계산된 세금: 6000.0
# is_taxable(84000) 호출됨
# is_taxable(52000) 호출됨
# is_taxable(190000) 호출됨
# calc_tax(190000) 호출됨
# 계산된 세금: 9500.0
```

위 예시에서 `filter()` 함수가 `map()` 함수보다 먼저 호출되었음에도 불구하고, `is_taxable()` 연산은 첫 번째 요소에 대해서만 처리된 후에 `calc_tax()`가 실행되고 결과가 출력됩니다. `84000`과 `52000`은 `is_taxable`에서 `False`를 반환했기 때문에 `calc_tax`가 호출되지 않습니다. 이는 항목들이 하나씩 파이프라인을 통해 처리되기 때문입니다. 이러한 특징은 중간 변수를 사용하지 않고 함수 호출을 직접 연결하여 코드를 더욱 간결하게 만들 수 있게 합니다.

이 외에도 Python은 `sorted()` (정렬), `zip()` (여러 이터러블의 요소들을 묶음), `enumerate()` (인덱스와 함께 요소 반환) 등 다양한 고차 함수와 이터러블 변환 기능을 제공하여 함수형 프로그래밍 스타일을 풍부하게 지원합니다. 이러한 도구들을 활용하면 코드를 더욱 효율적이고 함수형 원칙에 맞게 작성할 수 있습니다.