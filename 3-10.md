## 제10장: 타입과 데이터 모델: 견고한 코드 설계

함수형 프로그래밍(Functional Programming, FP)의 핵심 원칙 중 하나는 **예측 가능하고 안정적인 코드를 작성하는 것**입니다. 이를 위해 데이터와 그 표현 방식을 깊이 이해하는 것이 중요합니다. 이 장에서는 프로덕트 타입(Product Types)과 합 타입(Sum Types)이라는 두 가지 근본적인 데이터 모델을 살펴보고, 파이썬에서 이를 어떻게 활용하여 견고한 코드를 설계할 수 있는지 알아봅니다. 특히 오류를 예외(exceptions)가 아닌 값(values)으로 표현하는 함수형 방식이 왜 중요한지 설명합니다.

### 프로덕트 타입(Product Types)

**프로덕트 타입은 여러 필드(속성)의 조합으로 가능한 값의 수가 늘어나는 타입을 의미합니다**. 마치 수학에서 여러 집합의 데카르트 곱(Cartesian Product)처럼, 각 필드가 가질 수 있는 값의 경우의 수를 곱하여 전체 타입이 가질 수 있는 조합의 수가 결정됩니다.

예를 들어, 여러분이 옷 가게에서 셔츠를 고른다고 상상해 보세요. 셔츠는 '사이즈' (S, M, L)와 '색상' (빨강, 파랑)이라는 두 가지 속성을 가질 수 있습니다.

- 사이즈: 3가지 (S, M, L)
    
- 색상: 2가지 (빨강, 파랑)
    

이 셔츠가 가질 수 있는 총 조합의 수는 $3 \times 2 = \textbf{6가지}$가 됩니다 (S-빨강, S-파랑, M-빨강, M-파랑, L-빨강, L-파랑). 이렇게 각 속성이 가질 수 있는 경우의 수를 곱해서 전체 경우의 수가 결정되기 때문에 '프로덕트(곱셈) 타입'이라고 부르는 거예요.

**파이썬에서 클래스(Classes), 튜플(Tuples), 리스트(Lists) 등이 기본적으로 프로덕트 타입의 예시**입니다. 특히, 여러 필드를 묶어 하나의 의미 있는 데이터 구조를 표현할 때 `class` 외에도 `namedtuple`이나 `dataclasses`를 자주 사용합니다. 예를 들어, 어떤 사람을 `Person` 클래스로 모델링하고 `name` (문자열)과 `age` (정수) 두 필드를 가진다고 가정해봅시다. `name`은 무한한 문자열 조합을 가질 수 있고, `age`도 넓은 범위의 정수를 가질 수 있습니다. 이 두 필드의 조합은 거의 무한에 가까운 `Person` 객체의 조합을 만들어냅니다.

소스에 제시된 `Partner` 클래스 예시를 통해 이를 더 명확히 이해할 수 있습니다:

```
class Partner:
    def __init__(self, studies_finance: bool, has_trust_fund: bool):
        self.studies_finance = studies_finance
        self.has_trust_fund = has_trust_fund

    def __repr__(self): # 객체를 쉽게 출력하기 위한 메서드 추가
        return (f"Partner(studies_finance={self.studies_finance}, "
                f"has_trust_fund={self.has_trust_fund})")

# 가능한 조합
p1 = Partner(studies_finance=True, has_trust_fund=True)
p2 = Partner(studies_finance=True, has_trust_fund=False)
p3 = Partner(studies_finance=False, has_trust_fund=True)
p4 = Partner(studies_finance=False, has_trust_fund=False)

print(p1)
print(p2)
print(p3)
print(p4)
```

이 `Partner` 클래스는 두 개의 불리언(Boolean) 필드를 가지고 있으며, 각각 `True` 또는 `False` 두 가지 값을 가질 수 있습니다. 따라서 이 클래스로 표현할 수 있는 총 조합의 수는 $2 \times 2 = \textbf{4가지}$입니다. 만약 세 번째 불리언 속성(예: `has_blue_eyes`)을 추가한다면, 가능한 조합의 수는 $2 \times 2 \times 2 = \textbf{8가지}$로 늘어납니다. 다섯 개의 불리언 필드를 갖게 되면 25=textbf32가지 조합이 가능해집니다.

**파이썬에서 프로덕트 타입을 표현하는 다른 방법:**

이전 장에서 다룬 `namedtuple`이나 파이썬 3.7+에서 도입된 `dataclasses`는 프로덕트 타입을 간결하게 정의하는 데 매우 유용합니다. 이들은 클래스처럼 속성을 가질 수 있지만, 보일러플레이트 코드(반복되는 코드)를 줄여줍니다.

```
from collections import namedtuple
from dataclasses import dataclass

# namedtuple을 사용한 프로덕트 타입
# (x, y) 좌표를 나타내는 Point 타입
PointNamedTuple = namedtuple('PointNamedTuple', ['x', 'y'])
pt1 = PointNamedTuple(x=10, y=20)
print(f"namedtuple Point: {pt1}") # PointNamedTuple(x=10, y=20)

# dataclass를 사용한 프로덕트 타입
# 이름과 나이를 가진 Person 타입
@dataclass
class PersonDataclass:
    name: str
    age: int

p_dc1 = PersonDataclass(name="Alice", age=30)
print(f"dataclass Person: {p_dc1}") # PersonDataclass(name='Alice', age=30)
```

만약 필드 중 하나가 문자열(String) 타입이라면 문제는 더욱 복잡해집니다. 문자열은 `Mobi Dick` 소설 전체 내용, `Hello World`, 또는 빈 문자열 등 무한한 조합의 문자를 포함할 수 있습니다. 이로 인해 해당 필드가 가질 수 있는 값의 수가 사실상 무한대로 확장되어, 전체 프로덕트 타입이 가질 수 있는 조합의 수도 **무한대**가 됩니다.

이러한 특성 때문에 프로덕트 타입을 다루는 함수를 작성할 때 어려움이 발생합니다. 함수가 특정 프로덕트 타입의 객체를 인자로 받으면, **개발자는 `if/else` 문이나 `switch` 케이스를 무수히 많이 사용하여 예상치 못한 모든 가능한 값의 조합을 방어적으로 처리해야 합니다**. 이는 코드의 복잡성을 증가시키고 버그 발생 가능성을 높이는 주된 원인이 됩니다. 예를 들어, `Partner` 객체를 받아서 특정 로직을 수행하는 함수를 만든다면, `studies_finance`가 `True`일 때, `has_trust_fund`가 `True`일 때 등 모든 4가지 조합에 대해 각각 다른 로직을 작성해야 할 수도 있습니다. 함수형 프로그래밍에서는 이러한 복잡성을 줄이고 코드의 예측 가능성을 높이기 위해 **합 타입**의 개념에 주목합니다.

### 합 타입(Sum Types)

**합 타입은 가능한 값의 수가 미리 정해진 유한 집합인 타입을 의미합니다**. 프로덕트 타입과 달리, 합 타입은 특정 값의 집합만을 허용하며, 이를 통해 코드의 예측 가능성을 크게 향상시킵니다.

가장 단순한 합 타입의 예시는 **불리언(Boolean) 타입**입니다. 불리언은 `True` 또는 `False`라는 단 두 가지 값만을 가질 수 있습니다. 개발자는 불리언 변수를 다룰 때 이 두 가지 경우만 고려하면 되므로, 코드 로직이 훨씬 단순해지고 예측 가능해집니다. 다른 예시로는 요일(월, 화, 수, 목, 금, 토, 일)이나 교통 신호등의 색깔(빨강, 노랑, 초록) 등이 있습니다. 이들은 정해진 몇 가지 값 외에는 다른 값을 가질 수 없습니다.

**합 타입의 이점**은 다음과 같습니다:

- **코드의 예측 가능성 증가**: 가능한 값의 수가 제한적이므로, 함수가 받을 수 있는 입력의 범위를 명확히 알 수 있습니다.
    
- **유효하지 않은 값으로부터 보호**: 정의된 유한 집합 외의 값은 허용되지 않으므로, 유효하지 않은 데이터가 시스템에 유입되는 것을 방지합니다.
    
- **간결한 로직**: 무수히 많은 `if/else` 분기 처리가 줄어들어 코드가 훨씬 간결해집니다.
    
- **견고한 설계**: 모든 가능한 케이스를 명시적으로 처리하도록 강제하여, 놓치는 예외 상황을 줄이고 시스템의 견고성을 높입니다.
    

### 파이썬에서 Enum(열거형)으로 합 타입 구현하기

파이썬은 기본적으로 동적 타입(dynamically typed) 언어이므로, 다른 정적 타입(statically typed) 함수형 언어(예: Rust)처럼 컴파일 시점에 강력한 합 타입 검사를 제공하지는 않습니다. 하지만 **`enum` (열거형)을 사용하여 합 타입의 개념을 파이썬에서 구현하고 그 이점을 활용할 수 있습니다**. `enum`은 불리언과 유사하게 **고정된 값의 집합을 정의하는 방법**이며, "확장된 불리언"으로도 생각할 수 있습니다.

`enum`을 정의하는 방법은 `enum` 패키지를 임포트하고 클래스 내에서 가능한 값들을 지정하는 것입니다:

```
from enum import Enum, auto

# Enum을 사용하여 문서 타입을 정의합니다.
class DocType(Enum):
    PDF = auto()  # 자동으로 고유한 값을 할당 (보통 1부터 시작하는 정수)
    TXT = auto()
    DOCX = auto()
    MD = auto()
    HTML = auto()

# 또는 다음과 같이 명시적으로 값을 지정할 수도 있습니다.
# class DocType(Enum):
#     PDF = 1
#     TXT = 2
#     DOCX = 3
#     MD = 4
#     HTML = 5

# Enum 값 사용 예시
print(f"PDF 타입: {DocType.PDF}")           # DocType.PDF
print(f"PDF 타입 이름: {DocType.PDF.name}")      # PDF
print(f"PDF 타입 값: {DocType.PDF.value}")     # 1 (auto() 사용 시) 또는 지정된 값

# 유효하지 않은 Enum 값 사용 시 오류 발생 (런타임)
try:
    invalid_doc_type = DocType.XML
except AttributeError as e:
    print(f"오류 발생: {e}") # 오류: <enum 'DocType'> has no attribute 'XML'
```

위 예시처럼 `DocType.PDF`와 같이 정의된 값을 참조할 수 있습니다. 만약 정의되지 않은 값(예: `DocType.XML`)을 사용하려고 하면, **파이썬 인터프리터가 `AttributeError`를 발생시킵니다**. 이는 개발자가 코드를 실행해야만 오류를 발견할 수 있다는 점에서 Rust와 같은 정적 타입 언어의 컴파일 시점 검사와 차이가 있지만, 그래도 유효하지 않은 값을 사용할 가능성을 줄여줍니다.

`enum`을 사용함으로써 얻을 수 있는 합 타입의 주요 이점은 다음과 같습니다:

- **중앙 집중식 정의**: 유효한 값들이 하나의 `enum` 정의에 **중앙 집중적으로 명시되어** 있습니다. 개발자는 이 한 곳만 참조하여 어떤 값들이 유효한지 쉽게 파악할 수 있습니다.
    
- **코드의 간결성**: 개발자가 `if/else` 문을 사용하여 **수동으로 유효성 검사를 할 필요가 줄어듭니다**. 이는 코드베이스 전반의 중복된 유효성 검사 로직을 제거하여 코드를 더 깔끔하고 유지보수하기 쉽게 만듭니다.
    
- **예측 가능한 동작**: 함수가 `DocType`과 같은 `enum`을 인자로 받을 때, 함수는 오직 정의된 몇 가지 경우에 대해서만 동작을 고려하면 됩니다. 이는 함수의 동작을 더욱 예측 가능하게 하고, 예기치 않은 입력으로 인한 버그 발생을 줄입니다.
    
- **메모리 효율성**: `enum`의 내부 값은 일반적으로 문자열보다 적은 메모리를 차지하는 정수로 관리되므로, 성능에도 도움이 됩니다.
    

다음은 `DocType` `enum`을 활용하여 문서 처리 함수를 작성하는 예시입니다.

````
from enum import Enum, auto
from typing import Union # 타입 힌트를 위해 Union 임포트

class DocType(Enum):
    PDF = auto()
    TXT = auto()
    DOCX = auto()
    MD = auto()
    HTML = auto()

def process_document_by_type(doc_name: str, doc_type: DocType):
    """
    문서 타입에 따라 다른 처리 로직을 수행하는 함수.
    doc_type 인자는 DocType Enum 값만 받도록 명시적으로 설계되었습니다.
    """
    if doc_type == DocType.PDF:
        print(f"'{doc_name}' (PDF) 문서를 인쇄 준비 중...")
    elif doc_type == DocType.TXT:
        print(f"'{doc_name}' (TXT) 문서를 텍스트 편집기로 엽니다.")
    elif doc_type == DocType.DOCX:
        print(f"'{doc_name}' (DOCX) 문서를 워드 프로세서로 엽니다.")
    elif doc_type == DocType.MD:
        print(f"'{doc_name}' (MD) 문서를 마크다운 뷰어로 렌더링합니다.")
    elif doc_type == DocType.HTML:
        print(f"'{doc_name}' (HTML) 문서를 웹 브라우저로 엽니다.")
    else:
        # 이 else 블록은 DocType Enum을 올바르게 사용한다면 사실상 도달하지 않습니다.
        # 하지만 방어적인 코딩을 위해 남겨둘 수 있습니다.
        print(f"알 수 없는 문서 타입: {doc_type.name} - '{doc_name}' 문서를 처리할 수 없습니다.")

# 함수 사용 예시
print("\n--- Enum을 활용한 문서 처리 ---")
process_document_by_type("report.pdf", DocType.PDF)
process_document_by_type("notes.txt", DocType.TXT)
process_document_by_type("article.html", DocType.HTML)

# 잘못된 타입 전달 시 (런타임 오류는 아니지만, 의도치 않은 동작 가능성)
# process_document_by_type("config.xml", "XML") # DocType이 아닌 문자열 전달
# 파이썬의 타입 힌트(Type Hint)를 사용하면 이런 오류를 개발 단계에서 미리 감지할 수 있습니다.
```DocType` `enum`을 사용함으로써 `process_document_by_type` 함수는 오직 정의된 문서 타입만 처리하도록 명확히 제한됩니다. 이는 코드의 안정성을 높이고, 나중에 새로운 문서 타입이 추가될 때 `DocType` `enum`만 업데이트하면 관련 함수들의 변경 필요성을 명확히 알 수 있게 합니다.

### 오류를 값으로 표현하기: 함수형 접근 방식

함수형 프로그래밍에서는 **오류를 예외(exceptions)로 발생시키는 대신, 함수가 성공/실패 여부를 나타내는 값을 반환하는 방식**을 선호합니다. 이는 FP의 핵심 원칙인 **부수 효과(side effects) 회피**와 밀접한 관련이 있습니다.

**예외는 부수 효과로 간주됩니다**. 함수가 예외를 발생시키면, 이는 함수의 일반적인 반환 값 흐름을 벗어나 외부 환경에 영향을 미치는 "예측 불가능한" 동작으로 여겨질 수 있습니다. 함수 시그니처만으로는 어떤 예외가 발생할 수 있는지 명확히 알기 어렵기 때문에, 개발자는 모든 잠재적인 예외를 예측하고 `try-except` 블록으로 방어적으로 감싸야 합니다. 이 과정에서 **예외 처리를 누락하면 런타임 오류로 이어질 수 있습니다**.

대신 함수형 프로그래밍에서는 **오류를 값으로 표현하여 명시적으로 처리하도록 강제**합니다. 예를 들어, 어떤 파싱(parsing) 함수가 파일을 처리한 후 성공하거나 실패할 수 있는 경우, 다음과 같이 두 가지 합 타입(성공 OR 실패)을 나타내는 클래스를 정의할 수 있습니다:

```python
# 오류를 값으로 표현하기 위한 클래스 정의 (합 타입의 개념 활용)
# ParseResult는 Parse와 ParseError의 공통 부모 역할을 합니다.
class ParseResult:
    pass

class Parse(ParseResult):
    """파싱 성공을 나타내는 클래스. 성공 시 결과 데이터(doc_name, text)를 포함합니다."""
    def __init__(self, doc_name: str, text: str):
        self.doc_name = doc_name
        self.text = text

    def __repr__(self):
        # 긴 텍스트는 잘라서 표시하여 출력 가독성을 높입니다.
        return f"Parse(doc_name='{self.doc_name}', text='{self.text[:20]}...')"

class ParseError(ParseResult):
    """파싱 실패를 나타내는 클래스. 실패 시 오류 메시지를 포함합니다."""
    def __init__(self, doc_name: str, error_message: str):
        self.doc_name = doc_name
        self.error_message = error_message

    def __repr__(self):
        return f"ParseError(doc_name='{self.doc_name}', error_message='{self.error_message}')"

# 파싱 함수 예시: 오류를 값으로 반환합니다.
# 반환 타입에 Union[Parse, ParseError]를 명시하여 성공 또는 실패 타입을 명확히 합니다.
def parse_document(file_content: str, doc_name: str) -> Union[Parse, ParseError]:
    """
    주어진 파일 내용을 파싱하고, 성공 또는 실패 결과 객체를 반환합니다.
    예외를 발생시키지 않고, 오류를 값으로 표현합니다.
    """
    if "error" in file_content.lower():
        return ParseError(doc_name, "문서 내용에 'error' 키워드가 포함되어 있습니다.")
    if not file_content.strip():
        return ParseError(doc_name, "문서 내용이 비어 있습니다.")

    # 모든 오류 조건을 통과하면 성공적인 파싱으로 간주합니다.
    return Parse(doc_name, file_content)

# 함수 사용 예시
result1 = parse_document("Hello, functional programming!", "doc1.txt")
result2 = parse_document("This document contains an ERROR.", "doc2.txt")
result3 = parse_document("", "empty.txt")
result4 = parse_document("All good here.", "doc3.txt")

print(f"결과 1: {result1}")
print(f"결과 2: {result2}")
print(f"결과 3: {result3}")
print(f"결과 4: {result4}")

print("\n--- 파싱 결과 처리 로직 ---")
# 결과 처리 로직 (합 타입 처리와 유사)
# isinstance를 사용하여 반환된 객체의 타입을 확인하고 그에 따라 처리합니다.
if isinstance(result1, Parse):
    print(f"'{result1.doc_name}' 파싱 성공: '{result1.text}'")
elif isinstance(result1, ParseError):
    print(f"'{result1.doc_name}' 파싱 실패: {result1.error_message}")

if isinstance(result2, Parse):
    print(f"'{result2.doc_name}' 파싱 성공: '{result2.text}'")
elif isinstance(result2, ParseError):
    print(f"'{result2.doc_name}' 파싱 실패: {result2.error_message}")

if isinstance(result3, Parse):
    print(f"'{result3.doc_name}' 파싱 성공: '{result3.text}'")
elif isinstance(result3, ParseError):
    print(f"'{result3.doc_name}' 파싱 실패: {result3.error_message}")

if isinstance(result4, Parse):
    print(f"'{result4.doc_name}' 파싱 성공: '{result4.text}'")
elif isinstance(result4, ParseError):
    print(f"'{result4.doc_name}' 파싱 실패: {result4.error_message}")
````

이 접근 방식의 **주요 이점**은 다음과 같습니다:

- **명시적인 오류 처리**: 함수의 반환 타입에 성공(`Parse`)과 실패(`ParseError`) 모두가 포함되므로, **개발자는 반환 값을 통해 함수의 성공 여부를 명시적으로 확인하고 처리해야 합니다**. 이는 오류 처리 로직을 코드의 주요 흐름에 통합시켜, 오류를 놓칠 가능성을 줄입니다. `try-except` 블록처럼 코드의 흐름을 끊지 않고, 마치 일반적인 데이터처럼 오류를 다룰 수 있게 됩니다.
    
- **예측 가능한 동작**: 함수가 항상 특정 타입의 값을 반환하므로, **부수 효과 없이 함수 호출의 결과를 예측할 수 있습니다**. 함수가 예외를 발생시킬지 말지 걱정할 필요가 없습니다.
    
- **견고성 증가**: 특히 정적 타입 언어에서는 만약 개발자가 반환된 오류 값을 처리하지 않으면 컴파일러가 오류를 경고하여 **오류 처리를 강제**합니다. 파이썬과 같은 동적 타입 언어에서는 런타임에 `isinstance`와 같은 명시적인 검사를 통해 이를 구현할 수 있으며, 타입 힌트(`-> ParseResult` 또는 `-> Union[Parse, ParseError]`)를 사용하면 IDE나 정적 분석 도구의 도움을 받을 수 있습니다.
    
- **디버깅 용이성**: 오류 정보가 값 내부에 캡슐화되어 있으므로, 오류가 발생한 지점과 원인을 추적하기가 용이합니다.
    

이러한 "오류를 값으로 표현하는" 방식은 함수형 프로그래밍의 핵심 개념이며, 견고하고 예측 가능한 소프트웨어 시스템을 구축하는 데 기여합니다.

### 결론

이 장에서는 프로덕트 타입과 합 타입이라는 두 가지 중요한 데이터 모델을 통해 견고한 코드 설계의 기반을 살펴보았습니다. **프로덕트 타입은 유연하지만 무한한 값의 조합을 허용하여 복잡한 유효성 검사 로직을 야기할 수 있는 반면**, **합 타입은 가능한 값의 수를 유한하게 제한하여 코드의 예측 가능성과 안정성을 높입니다**. 파이썬에서는 `enum` 모듈을 활용하여 합 타입의 이점을 누릴 수 있으며, 이는 유효하지 않은 값으로부터 코드를 보호하고 중앙 집중적인 정의를 가능하게 합니다.

더 나아가, 함수형 프로그래밍에서는 부수 효과인 예외를 피하고 **오류를 명시적인 값으로 표현함으로써 코드의 견고성을 한층 더 강화합니다**. 이는 개발자가 함수의 성공과 실패를 항상 명시적으로 처리하도록 유도하여, 미처 예상하지 못한 런타임 오류를 줄이고 시스템의 안정성을 보장합니다. 이러한 타입과 데이터 모델에 대한 이해는 파이썬으로 더욱 깔끔하고 예측 가능하며 유지보수하기 쉬운 함수형 코드를 작성하는 데 필수적인 통찰력을 제공할 것입니다.