## 제3장: 순수 함수(Pure Functions)와 부수 효과(Side Effects)

여러분, "파이썬으로 쉽게 풀어 쓴 함수형 프로그래밍"의 세 번째 장에 오신 것을 환영합니다! 지난 두 장에서는 명령형과 선언형 프로그래밍의 차이점을 알아보고, 함수형 프로그래밍의 핵심 원칙인 **불변성(Immutability)**에 대해 깊이 있게 다뤄봤죠? 이번 장에서는 불변성과 떼려야 뗄 수 없는 관계인 **순수 함수(Pure Functions)**에 대해 이야기해 볼 거예요.

함수형 프로그래밍(Functional Programming, FP)은 코드를 작성하는 강력한 스타일 중 하나로, 주로 **선언적인(declarative) 프로그래밍 방식**을 지향합니다. 이는 '무엇을 원하는지'에 초점을 맞추고, '어떻게 달성할 것인지'에 대한 세부 구현은 숨기는 방식입니다. 이러한 패러다임의 핵심에는 **순수 함수**라는 개념이 있습니다. 순수 함수는 코드의 **버그를 줄이고, 이해하기 쉽게 만들며, 예측 가능한 동작을 보장**함으로써 코드의 품질을 크게 향상시킵니다. 이번 장에서는 순수 함수의 두 가지 중요한 속성을 살펴보고, 순수 함수가 제공하는 이점을 탐구하며, 실제 프로그래밍에서 피할 수 없는 부수 효과(Side Effects)를 어떻게 효과적으로 관리할지에 대해 논의합니다.

### 순수 함수의 두 가지 속성

순수 함수는 마치 수학 함수처럼, 다음 두 가지 핵심 속성을 만족하는 함수입니다:

#### 1. 결정론적(Deterministic): 동일한 입력에 대해 항상 동일한 출력 반환

**결정론적**이라는 것은 함수가 **주어진 입력에 대해 언제나 똑같은 결과를 반환**한다는 의미입니다. 마치 수학 공식처럼, 2 더하기 3은 항상 5인 것처럼, 순수 함수는 입력이 동일하면 호출 횟수나 시점에 관계없이 항상 동일한 출력을 보장합니다.

예를 들어, Python에서 두 숫자를 더하는 간단한 `add` 함수를 생각해 봅시다:

```python
def add(a, b):
    return a + b

print(add(2, 3)) # 5
print(add(2, 3)) # 5
# 언제나 5를 반환합니다.
```

이 `add` 함수는 결정론적입니다. `add(2, 3)`을 1조 번 호출하더라도 항상 5라는 동일한 결과를 얻을 것입니다. 함수가 오직 입력값에만 의존해서 결과를 내기 때문이죠.

반면, 결정론적이지 않은, 즉 **비순수(impure) 함수**는 외부 상태에 의존하여 예측 불가능한 결과를 초래할 수 있습니다. 다음 예시를 살펴봅시다:

```python
global_result = 0

def add_to_global(a):
    global global_result # 외부 변수를 수정함을 명시
    global_result += a
    return global_result

print(f"첫 번째 호출: {add_to_global(5)}") # global_result가 0이었으므로 0 + 5 = 5
print(f"두 번째 호출: {add_to_global(5)}") # global_result가 5였으므로 5 + 5 = 10
# 동일한 입력(5)에 대해 다른 출력(5, 10)을 반환합니다.
```

add_to_global` 함수는 `global_result`라는 전역 변수에 의존하고 이를 수정합니다. 따라서 이 함수는 동일한 입력 `5`에 대해 호출 시점에 따라 다른 결과를 반환하게 됩니다. `global_result`의 값이 함수 외부에서 변경될 수 있기 때문에, 함수를 호출할 때마다 `global_result`가 어떤 값일지 예측하기 어렵고, 이는 디버깅을 어렵게 만들고 코드의 예측 가능성을 떨어뜨립니다.

#### 2. 부수 효과 없음(No Side Effects): 함수의 실행이 외부 상태를 변경하지 않습니다.

순수 함수의 두 번째 속성은 **부수 효과가 없어야 한다**는 것입니다. **부수 효과**란 함수가 **입력을 받아 출력을 계산하고 반환하는 것 외에 수행하는 모든 외부 작업**을 의미합니다. 즉, 함수의 실행이 함수 외부의 어떤 상태도 변경해서는 안 됩니다.

쉽게 말해, 함수가 "세상을 바꾸는" 일을 하지 않는다는 뜻이에요. 함수가 실행된 후에도 함수 외부의 모든 것(변수, 파일, 화면 등)은 함수가 호출되기 전과 똑같은 상태여야 합니다.

일반적인 부수 효과의 예시는 다음과 같습니다:

-   **콘솔에 출력하기** (`print()`, `console.log()` 등).
-   **파일에 읽거나 쓰기** (File I/O).
-   **데이터베이스에 접근하거나 변경하기**.
-   **네트워크 요청 보내기**.
-   **전역 변수를 수정하기**.
-   **함수에 전달된 가변(mutable) 객체를 인플레이스(in-place)에서 변경하기** (예: 리스트, 딕셔너리, 세트).

함수가 부수 효과를 가지면 외부 상태를 변경하여 다른 코드 부분의 동작에 영향을 미칠 수 있습니다. 이는 "내 컴퓨터에서는 잘 되는데..."와 같은 상황을 유발하는 주된 원인이 되기도 합니다.

**예시 1: 콘솔 출력이라는 부수 효과**

```python
def greet_and_print(name):
    greeting = f"Hi, I'm {name}"
    print(greeting) # 콘솔 출력: 부수 효과!
    # 이 함수는 명시적인 반환값이 없으므로 None을 반환합니다.

# 이 함수는 "Hi, I'm Anjana"라는 문자열을 반환하는 것이 아니라,
# 콘솔에 출력하는 것이 주된 목적입니다.
greet_and_print("Anjana")
```

greet_and_print` 함수는 `print()` 문을 사용하여 콘솔에 출력을 수행합니다. 이는 함수가 입력을 받아 값을 계산하고 반환하는 것 외에 "세상을 바꾸는" 작업이므로 부수 효과에 해당합니다. 순수 함수는 이러한 IO(Input/Output) 작업을 수행하지 않습니다.

순수 함수는 대신 계산된 값을 **반환**하여 외부에서 활용하도록 합니다:

```python
def pure_greet(name):
    return f"Hi, I'm {name}"

# 함수는 값을 반환하고, 반환된 값으로 외부에서 작업을 수행합니다.
message = pure_greet("Anjana")
print(message) # "Hi, I'm Anjana"
```

pure_greet` 함수는 단순히 문자열을 구성하여 반환할 뿐, 어떤 외부 상태도 변경하지 않습니다. `print()` 호출은 함수 외부에 있으며, 이는 부수 효과를 관리하는 좋은 방법입니다.

**예시 2: 가변(mutable) 객체 변경이라는 부수 효과** Python에서 리스트(list), 딕셔너리(dictionary), 세트(set)와 같은 컬렉션은 **가변(mutable) 객체**입니다. 함수에 이러한 객체를 인자로 전달하고 함수 내부에서 객체를 직접 변경하면, 이는 함수 외부의 원래 객체를 변경하는 것이므로 부수 효과가 됩니다.

```python
# 가변 객체 변경 (부수 효과)
def append_item_impure(my_list, item):
    my_list.append(item) # 입력으로 받은 리스트를 직접 수정 (부수 효과)
    return my_list # 수정된 리스트 반환 (하지만 원본이 변경됨)

original_list = [1, 2, 3]
print(f"원본 리스트 (초기): {original_list}, ID: {id(original_list)}")

modified_list = append_item_impure(original_list, 4)
print(f"원본 리스트 (함수 호출 후): {original_list}, ID: {id(original_list)}") # 원본 리스트가 변경되었습니다!
print(f"반환된 리스트: {modified_list}, ID: {id(modified_list)}")
# original_list와 modified_list의 ID가 동일함을 볼 수 있습니다. 즉, 같은 객체가 변경된 것입니다.
```

append_item_impure` 함수는 `my_list`를 직접 수정합니다. 이는 함수 외부의 `original_list`도 함께 변경하는 부수 효과를 일으킵니다.

순수 함수는 이러한 변경을 피하기 위해 **새로운 복사본을 생성하여 반환**합니다:

```python
# 가변 객체 변경 피하기 (순수 함수)
def append_item_pure(my_list, item):
    # 새로운 리스트를 생성하여 반환 (원래 리스트는 변경하지 않음)
    return my_list + [item] # 또는 my_list.copy() + [item]

original_list = [1, 2, 3]
print(f"원본 리스트 (초기): {original_list}, ID: {id(original_list)}")

new_list = append_item_pure(original_list, 4)
print(f"원본 리스트 (함수 호출 후): {original_list}, ID: {id(original_list)}") # 원본 리스트는 변경되지 않았습니다!
print(f"새 리스트: {new_list}, ID: {id(new_list)}")
# original_list와 new_list의 ID가 다름을 볼 수 있습니다. 즉, 새로운 객체가 생성된 것입니다.
```

append_item_pure` 함수는 `original_list`를 수정하지 않고 새로운 리스트를 생성하여 반환합니다. 이는 함수가 외부 상태에 영향을 주지 않으므로 순수 함수의 조건을 만족합니다. 이러한 방식은 "복사본을 만들면 성능 문제가 발생할 수 있다"는 우려가 있을 수 있으나, 대규모 데이터가 아닌 이상 코드의 **예측 가능성과 안정성을 크게 높여**줍니다.

---

### 순수 함수의 이점

순수 함수는 위에서 언급된 두 가지 속성 덕분에 여러 가지 중요한 이점을 제공합니다:

1.  **쉬운 테스트 (Easier to Test)**: 순수 함수는 주어진 입력에 대해 항상 동일한 출력을 반환하고 외부 상태에 영향을 미치지 않으므로, **테스트 작성이 매우 간단**합니다. 함수를 특정 인자로 호출한 후 반환 값을 확인하기만 하면 됩니다. 데이터베이스 연결, 네트워크 상태 등 외부 환경에 대한 걱정 없이 독립적으로 함수를 테스트할 수 있으며, 이는 **유닛 테스트 스위트 작성에 매우 적합**합니다.
2.  **쉬운 디버깅 (Easier to Debug)**: 버그가 발생했을 때, 순수 함수는 문제의 원인을 추적하기가 훨씬 쉽습니다. 함수가 외부 상태를 변경하지 않으므로, 함수 호출 전후의 시스템 상태를 걱정할 필요가 없습니다. 이는 코드를 "블랙 박스"로 생각하고, 입력과 출력을 통해 문제를 빠르게 격리하고 해결할 수 있게 해줍니다. "내 컴퓨터에서는 잘 되는데..."와 같은 비결정론적 버그는 순수 함수에서는 발생하지 않습니다.
3.  **예측 가능한 동작 (Predictable Behavior)**: 결정론적이고 부수 효과가 없다는 특성 때문에, 순수 함수는 **매우 예측 가능**합니다. 숨겨진 무작위 숫자 생성기, 데이터베이스 상태, 인터넷 연결 여부 등 외부 요인에 따라 함수가 다르게 동작할까 봐 걱정할 필요가 없습니다. 이러한 예측 가능성은 프로그램 전체의 안정성을 높이고, 개발자가 코드의 동작을 추론하고 이해하기 쉽게 만듭니다.
4.  **병렬 처리 및 동시성 용이 (Concurrency Friendly)**: 순수 함수는 외부 상태를 변경하지 않기 때문에 **병렬(parallel)로 안전하게 실행**될 수 있습니다. 여러 스레드나 프로세스에서 동시에 순수 함수를 호출하더라도, **경쟁 조건(race conditions)**이나 예기치 않은 부작용 없이 독립적으로 작동합니다. 이는 멀티코어 프로세서 환경에서 성능을 극대화하는 데 큰 이점을 제공합니다.
5.  **조합 용이성 (Easier to Combine/Compose)**: 순수 함수는 레고 블록처럼 서로 조합하여 더 복잡한 기능을 쉽게 만들 수 있습니다. 함수의 출력이 항상 예측 가능하므로, 한 순수 함수의 출력을 다른 순수 함수의 입력으로 전달하는 것이 안전합니다. 이는 파이프라인(pipeline)과 같은 패턴을 통해 명확하고 간결한 코드 흐름을 가능하게 합니다.

---

### 부수 효과 관리

순수 함수가 이토록 많은 이점을 제공하지만, **모든 함수를 순수하게 만드는 것은 현실적으로 불가능하며, 심지어 프로그램의 목적과도 모순될 수 있습니다**. 예를 들어, 사용자의 입력을 받거나, 결과를 화면에 출력하거나, 파일에 데이터를 저장하는 것과 같은 작업은 모두 부수 효과를 동반합니다. 이러한 IO(Input/Output) 작업이 없다면 프로그램은 사실상 아무런 유용한 동작도 하지 않을 것입니다.

따라서 핵심은 **부수 효과를 완전히 제거하는 것이 아니라, 현명하게 관리하는 것**입니다. 권장되는 접근 방식은 다음과 같습니다:

-   **프로그램의 핵심 로직은 순수 함수로 작성**: 데이터 변환, 계산, 유효성 검사 등 프로그램의 대부분을 구성하는 핵심 비즈니스 로직은 순수 함수로 구현해야 합니다. 이는 코드의 대부분을 테스트, 디버깅, 추론하기 쉽게 만들어 줍니다. 예를 들어, 웹 애플리케이션에서 사용자 입력 유효성 검사, 데이터 정제 및 변환, 비즈니스 규칙 적용 등은 모두 순수 함수로 처리할 수 있습니다.
-   **부수 효과는 코드의 특정 고립된 부분에 집중**: IO 작업과 같이 불가피한 부수 효과는 **코드베이스의 특정, 고립된 영역에 제한**해야 합니다. 예를 들어, 프로그램의 시작 부분에서 입력을 받고(파일 읽기, 사용자 입력), 중간 단계에서는 순수 함수로 데이터를 처리하며, 마지막 단계에서 처리된 결과를 출력하거나 저장(콘솔 출력, 파일 쓰기, 데이터베이스 업데이트)하는 방식으로 구성할 수 있습니다.

다음은 부수 효과를 관리하는 예시입니다:

```python
# 1. 입력 (부수 효과 영역)
def get_user_input(prompt):
	return input(prompt) # 사용자 입력: 부수 효과 (외부 세계와 상호작용)

# 2. 핵심 로직 (순수 함수 영역)
def process_data(data):
	# 데이터 정제, 변환, 계산 등 순수하게 처리
	# 이 함수는 오직 입력값 'data'에만 의존하며, 외부 상태를 변경하지 않습니다.
	return data.upper() + " (Processed)"

# 3. 출력 (부수 효과 영역)
def display_output(message):
	print(message) # 콘솔 출력: 부수 효과 (외부 세계로 결과 전달)

# 프로그램의 흐름 (부수 효과와 순수 로직의 분리)
if __name__ == "__main__":
	# 프로그램 시작: 부수 효과 (입력)
	raw_input = get_user_input("데이터를 입력하세요: ")

	# 중간 단계: 순수 함수 (데이터 처리)
	processed_data = process_data(raw_input)

	# 마지막 단계: 부수 효과 (출력)
	display_output(f"처리된 데이터: {processed_data}")
```

이 구조에서는 `get_user_input`과 `display_output` 함수가 부수 효과를 가지지만, 이들을 호출하는 `main` 함수 내부에 명확히 분리되어 있습니다. `process_data`는 순수 함수이므로 어떤 외부 상태에도 영향을 미치지 않고, 예측 가능한 방식으로 작동합니다. 이렇게 부수 효과를 최소화하고 격리하면, 코드의 핵심 로직을 훨씬 더 안정적으로 만들 수 있습니다.

- **오류를 값으로 다루기 (Errors as Values)**: 예외(exceptions)를 발생시키는 것은 함수형 프로그래밍에서 부수 효과로 간주될 수 있습니다. 예외는 프로그램의 정상적인 흐름을 깨뜨리고, 외부에서 예측하기 어려운 방식으로 동작할 수 있기 때문이죠. 대신, 함수는 성공 또는 실패 상태와 함께 값을 반환하는 방식으로 오류를 처리할 수 있습니다. 예를 들어, Python에서 튜플 `(성공_여부, 결과_또는_오류_메시지)`와 같은 형식을 사용할 수 있습니다.

```python
# 오류를 값으로 반환하는 예시
def divide_pure(a, b):
	if b == 0:
		return (False, "0으로 나눌 수 없습니다.") # 오류를 값으로 반환 (튜플의 첫 번째 요소로 실패 여부, 두 번째 요소로 메시지)
	return (True, a / b) # 성공 시 결과 반환 (튜플의 첫 번째 요소로 성공 여부, 두 번째 요소로 결과)

# 사용 예시
success, result = divide_pure(10, 2)
if success:
	print(f"나눗셈 결과: {result}")
else:
	print(f"나눗셈 오류: {result}")

success, result = divide_pure(10, 0)
if success:
	print(f"나눗셈 결과: {result}")
else:
	print(f"나눗셈 오류: {result}")
```

이 방식은 오류 처리를 명시적으로 강제하고, 함수가 예측 가능한 반환값을 가지도록 하여 코드의 안정성을 높입니다. `try-except` 블록을 사용하는 대신, 함수의 반환값만으로 성공/실패 여부를 판단할 수 있게 되는 거죠.

Python은 순수하게 함수형 언어는 아니지만, 이러한 순수 함수와 부수 효과 관리 원칙을 적용함으로써 **더 깨끗하고, 견고하며, 유지보수하기 쉬운 코드를 작성**할 수 있습니다. 이러한 원칙은 객체 지향(Object-Oriented Programming, OOP)이나 절차적(Procedural Programming) 스타일과도 상충되지 않으며, 오히려 함께 사용하여 더욱 강력한 코드를 구축할 수 있습니다.