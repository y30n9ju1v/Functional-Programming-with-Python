## 제9장: 함수 변환(Function Transformations) 및 데코레이터(Decorators)

함수형 프로그래밍에서는 함수를 단순한 코드 블록이 아닌, 값처럼 다루는 **일급 객체(First-Class Objects)**로 취급합니다. 이는 함수를 변수에 할당하거나, 다른 함수의 인수로 전달하거나, 심지어 함수의 반환 값으로 사용할 수 있다는 의미입니다. 이러한 유연성 덕분에 우리는 함수를 단순히 호출하는 것을 넘어, **함수 자체를 변형하고 확장하는 강력한 기법**들을 활용할 수 있습니다. 이번 장에서는 이러한 기법 중 핵심인 **함수 변환(Function Transformations)**과 파이썬에서 이를 편리하게 사용할 수 있도록 돕는 **데코레이터(Decorators)**에 대해 깊이 있게 다뤄보겠습니다.

### 1. 함수 변환(Function Transformations)

**함수 변환**은 말 그대로 '함수를 다른 함수로 바꾸는 것'을 의미합니다. 기존 함수에 새로운 기능을 추가하거나, 함수의 '시그니처(signature, 인수 목록)'를 변경하여 코드의 재사용성과 유연성을 높이는 기법이죠. 이는 특정 유형의 **고차 함수(Higher-Order Function)**로 설명될 수 있으며, 함수를 입력으로 받아 새로운 함수를 반환하는 방식으로 동작합니다. 함수 변환은 여러 함수를 동적으로 조합하여 새로운 함수를 생성하는 데 사용됩니다.

함수 변환의 핵심 목표는 코드를 더 간결하고 이해하기 쉽게 만드는 것입니다. 동적으로 함수의 변형을 생성함으로써, 일반적인 기능을 여러 곳에서 쉽게 공유하고 재사용할 수 있게 됩니다. 예를 들어, `multiply`나 `add`와 같은 두 개의 인수를 받는 수학 함수를 받아, 인수를 하나만 받는 `square`나 `double`과 같은 새로운 함수를 반환하는 `self_math` 함수 등이 함수 변환의 좋은 예시입니다. 이러한 기법은 불필요한 코드 중복을 피하고, 로직을 더 추상화하여 유지보수를 용이하게 만듭니다.

```
# 예시: self_math 함수 (함수 변환의 기본 아이디어)
def self_math(math_func):
    """
    주어진 이항(두 인수를 받는) 수학 함수를 사용하여
    단일 인수를 두 번 적용하는 새로운 함수를 반환합니다.
    예: 곱하기 함수를 주면 제곱 함수를, 더하기 함수를 주면 두 배 함수를 반환.
    """
    def inner_func(x):
        # math_func에 동일한 인수를 두 번 적용하여 새로운 연산을 만듭니다.
        return math_func(x, x)
    return inner_func

# 두 개의 인수를 받는 기본 수학 함수 정의
def multiply(x, y):
    return x * y

def add(x, y):
    return x + y

# self_math를 사용하여 새로운 함수 생성
# multiply 함수를 변환하여 square 함수를 만듭니다.
square = self_math(multiply)
# add 함수를 변환하여 double 함수를 만듭니다.
double = self_math(add)

print(f"5의 제곱: {square(5)}")  # 출력: 5의 제곱: 25 (multiply(5, 5)와 동일)
print(f"5의 두 배: {double(5)}")  # 출력: 5의 두 배: 10 (add(5, 5)와 동일)
```

이 예시에서 `self_math`는 `multiply`나 `add`와 같은 함수를 변환하여 `square`나 `double`과 같은 새로운 함수를 동적으로 생성합니다. 이는 **함수를 유연하게 재사용하고 새로운 기능을 조합하는 함수 변환의 본질**을 보여줍니다. 이러한 동적 함수 생성 방식은 파이썬의 `map()` 함수와 같은 고차 함수와 함께 사용될 때 특히 강력합니다.

#### 커링(Currying)

**커링은 여러 인수를 받는 함수를 각 인수를 하나씩 받는 일련의 함수로 변환하는 기법**입니다. 즉, f(a,b,c) 와 같은 함수를 f(a)(b)(c) 와 같은 형태로 바꾸는 것입니다. 첫 번째 인수를 받으면 두 번째 인수를 받을 준비가 된 새 함수를 반환하고, 이 과정이 모든 인수를 받을 때까지 반복됩니다.

파이썬에서는 함수가 기본적으로 여러 인수를 직접 받을 수 있기 때문에 **특정 목적이 있을 때 드물게 사용**됩니다. 파이썬에서 커링을 사용하는 주된 이유는 **함수 시그니처를 특정 형태로 맞추기 위함**입니다. 예를 들어, 어떤 고차 함수가 인수가 하나인 함수만을 기대할 때, 여러 인수를 받는 기존 함수를 커링하여 이 요구사항을 충족시킬 수 있습니다. 함수를 나중에 호출하기 위해 전달할 때, 해당 함수가 몇 개의 인수를 받는지 아는 것이 중요하기 때문입니다.

파이썬에서 커링을 직접 구현하려면 클로저(closure)를 활용하여 중첩된 함수를 반환하는 방식을 사용해야 합니다. `functools.partial`과는 유사하지만, 커링은 인수를 하나씩 받는 반면, 부분 적용(Partial Application)은 여러 인수를 한 번에 고정할 수 있습니다. PyMonad 같은 외부 라이브러리에서는 `@curry` 데코레이터를 제공하여 더 쉽게 커링을 구현할 수 있습니다.

````
# 예시: 커링 (클로저를 활용한 수동 구현)
# 일반적인 두 인수를 받는 합계 함수
def sum_normal(a, b):
    return a + b

print(f"일반 함수 호출: {sum_normal(1, 2)}") # 출력: 일반 함수 호출: 3

# 커링된 합계 함수 구현
def sum_curried(a):
    """
    첫 번째 인수를 받고, 두 번째 인수를 받는 새 함수를 반환합니다.
    이는 클로저를 활용하여 외부 스코프의 'a' 값을 기억합니다.
    """
    def inner_sum(b):
        # inner_sum은 외부 함수 sum_curried의 변수 'a'를 기억합니다.
        return a + b
    return inner_sum

# 커링된 함수 사용
# sum_curried(5)를 호출하면, 'a'가 5로 고정된 새로운 함수(클로저)가 반환됩니다.
add_five = sum_curried(5) # add_five는 이제 'x에 5를 더하는 함수'가 됩니다.
print(f"add_five(3): {add_five(3)}") # 출력: add_five(3): 8 (5 + 3)

# 모든 인수를 즉시 적용하는 커링된 함수 사용
# sum_curried(1)이 먼저 호출되어 'a'가 1로 고정된 함수를 반환하고,
# 그 반환된 함수에 다시 (2)를 호출하여 'b'가 2로 적용됩니다.
print(f"sum_curried(1)(2): {sum_curried(1)(2)}") # 출력: sum_curried(1)(2): 3
```python
# functools.partial을 사용한 부분 적용 예시 (커링과 비교)
from functools import partial

def power(base, exponent):
    return base ** exponent

# partial을 사용하여 exponent가 2로 고정된 새로운 함수 'square_partial'을 만듭니다.
# 이는 power(x, 2)와 같습니다.
square_partial = partial(power, exponent=2)
print(f"partial을 이용한 4의 2제곱: {square_partial(4)}") # 출력: 16

# partial을 사용하여 base가 5로 고정된 새로운 함수 'five_to_the_power'를 만듭니다.
# 이는 power(5, x)와 같습니다.
five_to_the_power = partial(power, 5)
print(f"5의 3제곱: {five_to_the_power(3)}") # 출력: 125

# 커링과 partial의 차이점:
# 커링은 인수를 하나씩 순차적으로 받으며 함수를 반환하는 연쇄적인 호출을 만듭니다. (sum_curried(1)(2))
# partial은 여러 인자 중 일부를 '고정'하여 새로운 함수를 한 번에 만듭니다. (partial(func, arg1=val1, arg2=val2))
# 파이썬에서는 partial이 더 일반적이고 직관적인 '부분 적용' 방식입니다.
````

`sum_curried` 함수는 `a`를 인수로 받아 `inner_sum`이라는 새로운 함수를 반환합니다. 이 `inner_sum` 함수는 `b`를 인수로 받아 `a + b`를 계산합니다. 이러한 방식은 함수 호출의 연쇄를 통해 인수를 하나씩 적용할 수 있게 합니다. 커링된 함수는 **메모리 효율성 측면에서는 비용이 발생할 수 있으므로**, 파이썬에서는 명확한 목적이 있을 때만 드물게 사용하는 것이 권장됩니다.

### 2. 데코레이터(Decorators)

여러분은 혹시 함수에 마법 같은 능력을 부여하고 싶다는 생각을 해본 적 있으신가요? 파이썬의 데코레이터가 바로 그런 마법을 가능하게 합니다! 한마디로 **기존 함수에 추가 기능을 부여하는 파이썬의 문법적 설탕(Syntactic Sugar)**입니다. 여기서 '문법적 설탕'이란, 코드를 더 읽기 쉽고 간결하게 만들어주는 문법을 의미해요. 데코레이터는 사실 **고차 함수(Higher-Order Function)의 한 형태**로, 함수를 인수로 받아 새로운 함수를 반환합니다. 데코레이터를 사용하면 원본 함수의 코드를 직접 수정하지 않고도 함수의 동작을 변경하거나 확장할 수 있습니다. 일반적으로 데코레이터는 **함수 실행 전후에 특정 작업을 수행**하거나, **함수 인수를 변환**하거나, **함수 호출 횟수를 기록**하는 등 다양한 용도로 활용됩니다. 함수형 프로그래밍의 관점에서, 데코레이터는 부수 효과(Side Effect)가 필요한 부분을 격리하거나, 함수를 조합하는 데 유용하게 사용될 수 있습니다. 예를 들어, 함수가 콘솔에 출력하는 것이 부수 효과에 해당하며, 이는 데코레이터로 분리하여 관리할 수 있습니다.

#### `@` 문법을 사용한 데코레이터 적용

`@` 문법은 데코레이터를 함수에 적용하는 간결한 방법입니다. 함수 정의 바로 위에 `@데코레이터_이름` 형식으로 사용합니다.

```
# 예시: @ 문법을 사용한 데코레이터

# 함수의 호출 횟수를 세는 데코레이터
def log_call_count(func_to_decorate):
    # 이 변수는 데코레이터가 호출될 때마다 (즉, 함수가 데코레이트될 때마다)
    # 새로운 클로저 환경에서 초기화됩니다.
    # 즉, 각 데코레이트된 함수(greet, calculate_sum)는 자신만의 'count'를 가집니다.
    count = 0
    def wrapper(*args, **kwargs): # *args와 **kwargs는 아래에서 자세히 설명합니다.
        nonlocal count # 바깥 함수의 'count' 변수를 수정하겠다고 선언
        count += 1
        print(f"함수 '{func_to_decorate.__name__}' 호출 횟수: {count}회") # func_to_decorate.__name__은 데코레이트된 원래 함수의 이름을 가져옵니다. 부수 효과 (로깅)
        return func_to_decorate(*args, **kwargs) # 원래 함수 실행 및 결과 반환
    return wrapper

@log_call_count # greet = log_call_count(greet) 와 동일한 효과
def greet(name):
    """이름을 환영하는 함수"""
    return f"안녕하세요, {name}님!"

@log_call_count # calculate_sum = log_call_count(calculate_sum) 와 동일한 효과
def calculate_sum(a, b):
    """두 숫자의 합을 계산하는 함수"""
    return a + b

print(greet("앨리스"))
print(greet("밥"))
print(calculate_sum(10, 20))
print(calculate_sum(5, 7))

# 예상 출력:
# 함수 'greet' 호출 횟수: 1회
# 안녕하세요, 앨리스님!
# 함수 'greet' 호출 횟수: 2회
# 안녕하세요, 밥님!
# 함수 'calculate_sum' 호출 횟수: 1회
# 30
# 함수 'calculate_sum' 호출 횟수: 2회
# 12
```

위 코드에서 `@log_call_count`는 `greet` 함수와 `calculate_sum` 함수에 `log_call_count` 데코레이터를 적용합니다. 이는 실제로는 `greet = log_call_count(greet)`와 `calculate_sum = log_call_count(calculate_sum)`와 같이 함수를 재할당하는 것과 동일합니다. 즉, `greet`와 `calculate_sum`는 이제 `log_call_count`의 `wrapper` 함수가 되어, 호출될 때마다 추가된 로깅 기능을 수행하게 됩니다. 이 `wrapper` 함수는 **클로저**를 사용하여 `count` 변수의 상태를 유지합니다. 이는 `new_counter` 함수가 `add_health`와 `add_mana`라는 독립적인 카운터를 갖는 것과 유사합니다.

#### `*args`와 `**kwargs`를 사용하여 다양한 함수 시그니처에 적용 가능한 데코레이터 작성

데코레이터는 모든 종류의 함수 시그니처에 적용될 수 있어야 합니다. 즉, 인수가 없거나, 여러 개의 위치 인수를 받거나, 키워드 인수를 받는 함수 등 어떤 함수에도 적용되어야 합니다. 이를 위해 파이썬에서는 **`*args` (위치 인수를 튜플로 모음)와 `**kwargs` (키워드 인수를 딕셔너리로 모음) 구문을 사용**합니다.

- `*args`: 함수가 받을 수 있는 **위치 인수(positional arguments)의 개수가 정해져 있지 않을 때** 사용합니다. `*args`는 전달된 모든 위치 인수를 튜플 형태로 묶어서 함수 내부로 전달합니다.
    
- `**kwargs`: 함수가 받을 수 있는 **키워드 인수(keyword arguments)의 개수가 정해져 있지 않을 때** 사용합니다. `**kwargs`는 전달된 모든 키워드 인수를 딕셔너리 형태로 묶어서 함수 내부로 전달합니다.
    

`*args`와 `**kwargs`를 데코레이터의 `wrapper` 함수에 사용하면, `wrapper`는 어떤 인수가 전달되든 모두 수용할 수 있습니다. 그리고 이 `*args`와 `**kwargs`를 다시 원래 함수 (`func_to_decorate`)에 전달하면, 원래 함수는 자신이 기대하는 인수를 정확하게 받게 됩니다.

```
# 예시: *args와 **kwargs를 사용한 데코레이터

# 마크다운 헤딩 심볼을 제거하는 헬퍼 함수
# (실제 구현은 더 복잡할 수 있으나, 여기서는 예시를 위해 단순화)
def convert_md_to_text(text):
    if not isinstance(text, str): # 문자열이 아닌 경우 처리하지 않음
        return text
    if text.startswith("# "):
        return text[2:] # "# " 제거
    elif text.startswith("## "):
        return text[3:] # "## " 제거
    elif text.startswith("### "):
        return text[4:] # "### " 제거
    return text

# 함수 인수로 전달된 모든 문자열에서 마크다운 헤딩 심볼을 제거하는 데코레이터
def markdown_to_text_decorator(func_to_decorate):
    def wrapper(*args, **kwargs):
        # 1. 위치 인수를 변환: map 함수를 사용하여 각 인수에 convert_md_to_text 함수 적용
        # map의 결과는 이터러블이므로 list()로 변환하여 새로운 튜플로 만듭니다.
        processed_args = tuple(map(convert_md_to_text, args))

        # 2. 키워드 인수를 변환: 딕셔너리에서 items()로 (키, 값) 튜플을 얻은 후 처리
        processed_kwargs = {}
        for key, value in kwargs.items():
            processed_kwargs[key] = convert_md_to_text(value)

        # 3. 변환된 인수로 원래 함수 호출
        # '*'는 튜플을 개별 위치 인수로 언패킹하여 전달합니다.
        # '**'는 딕셔너리를 개별 키워드 인수로 언패킹하여 전달합니다.
        return func_to_decorate(*processed_args, **processed_kwargs)
    return wrapper

@markdown_to_text_decorator
def display_document_info(title, content, author="익명"):
    print(f"제목: {title}")
    print(f"내용: {content}")
    print(f"저자: {author}")

@markdown_to_text_decorator
def process_report(report_id, data):
    print(f"보고서 ID: {report_id}")
    print(f"처리된 데이터: {data}")

# 데코레이터 적용 함수 호출
display_document_info(
    "# 중요 공지", # 마크다운 헤딩이 제거될 것입니다.
    "## 회의록",   # 마크다운 헤딩이 제거될 것입니다.
    author="**관리자**" # convert_md_to_text 함수는 '# ', '## ', '### '와 같은 특정 마크다운 헤딩만 제거하도록 단순화된 예시이므로, 일반적인 볼드체 마크다운(**)은 처리하지 않습니다.
)

print("-" * 30) # 구분선

process_report(
    101,
    "### 월별 실적 요약" # 마크다운 헤딩이 제거될 것입니다.
)

# 예상 출력:
# 제목: 중요 공지
# 내용: 회의록
# 저자: **관리자**
# ------------------------------
# 보고서 ID: 101
# 처리된 데이터: 월별 실적 요약

```

이 예시에서 `markdown_to_text_decorator`는 `display_document_info`와 `process_report` 함수에 적용됩니다. `wrapper` 함수 내에서 `*args`와 `**kwargs`를 사용하여 전달된 모든 위치 및 키워드 인수를 캡처합니다. 그런 다음, 이 인수를 `convert_md_to_text` 함수로 처리하여 마크다운 헤딩 심볼을 제거한 후, `func_to_decorate` (즉, 원래 함수)에 `*processed_args`와 `**processed_kwargs`로 전달하여 실행합니다.

`*args`와 `**kwargs`의 핵심은 함수가 얼마나 많은 인수를 받는지, 또는 어떤 이름의 키워드 인수를 받는지 미리 알 필요 없이 **데코레이터가 유연하게 모든 종류의 함수를 감쌀 수 있게 해준다**는 점입니다. 이는 데코레이터의 재사용성을 극대화합니다.

### 결론 (Conclusion)

함수 변환과 데코레이터는 파이썬에서 함수형 프로그래밍 스타일을 적용할 때 매우 강력한 도구입니다. **함수 변환은 기존 함수의 기능을 확장하거나 시그니처를 조정하여 코드의 유연성과 재사용성을 높이는 추상화 기법**이며, **커링은 이를 위한 특정 변환 패턴**입니다. 반면, **데코레이터는 파이썬이 제공하는 문법적 설탕으로, 이러한 함수 변환을 간결하고 가독성 좋게 적용할 수 있도록 돕습니다**.

`@` 문법과 `*args`, `**kwargs`의 활용은 데코레이터의 힘을 배가시켜, 개발자가 **원본 함수의 로직에 영향을 주지 않으면서도 다양한 횡단 관심사(Cross-Cutting Concerns)를 깔끔하게 분리**할 수 있게 합니다. 여기서 '횡단 관심사'란 로깅, 인증, 캐싱처럼 여러 모듈이나 함수에 걸쳐 공통적으로 나타나는 부가적인 기능들을 의미합니다. 데코레이터를 사용하면 이러한 기능들을 핵심 비즈니스 로직과 분리하여 관리할 수 있어 코드가 훨씬 깔끔해집니다.

이로써 코드는 더욱 모듈화되고, 유지보수가 용이하며, 예측 가능한 동작을 보장하게 됩니다. 함수형 프로그래밍의 원칙을 파이썬에 적용하는 데 있어, 함수 변환과 데코레이터는 필수적인 이해와 활용이 요구되는 중요한 개념들입니다. 이들을 통해 우리는 **더 간결하고(concise), 디버그하기 쉬우며, 추상화하기 용이한 코드를 작성**할 수 있게 됩니다.