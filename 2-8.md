## 제8장: 클로저(Closures)

함수형 프로그래밍의 세계에서는 **데이터 불변성(immutability)**과 **부수 효과(side effects)의 최소화**가 중요한 원칙으로 강조됩니다. 하지만 실제 애플리케이션 개발에서는 상태(state)를 관리하고, 함수 호출 간에 특정 정보를 유지해야 하는 경우가 빈번하게 발생합니다. 이러한 상황에서 **클로저(Closures)**는 파이썬과 같은 다중 패러다임 언어에서 강력하고 유연한 해결책을 제공하며, 함수형 프로그래밍의 개념을 효과적으로 적용할 수 있게 돕습니다.

### 클로저의 정의

클로저란 **내부 함수(inner function)가 외부(둘러싸는) 함수의 변수를 참조하는 경우, 이 내부 함수와 그 환경이 묶여서 단일 엔티티를 형성하는 것**을 의미합니다. 핵심은 **함수가 정의된 시점의 환경(상태)을 기억한다**는 점입니다. 즉, 외부 함수가 실행을 마친 후에도 내부 함수는 외부 함수의 스코프에 있었던 변수들에 접근하고, 심지어는 변경할 수 있는 능력을 가집니다.

이게 무슨 말일까요? 쉽게 비유해볼게요. 여러분이 친구에게 "비밀 상자"를 하나 만들어달라고 부탁했어요. 이 상자 안에는 여러분만 아는 '비밀 숫자'가 들어있어요. 친구는 상자를 만들어서 여러분에게 주는데, 이 상자는 '비밀 숫자'를 기억하고 있어서, 여러분이 상자를 열 때마다 숫자를 하나씩 늘려줄 수 있어요. 여기서 '친구'가 외부 함수, '상자'가 내부 함수(클로저), '비밀 숫자'가 외부 함수의 변수라고 생각하면 됩니다. 친구는 상자를 만들고 나면 할 일을 다 했지만, 상자는 여전히 '비밀 숫자'를 기억하고 있는 거죠.

예를 들어, 간단한 카운터를 만드는 함수를 통해 클로저의 개념을 이해해봅시다:

```python
# new_counter: 외부(둘러싸는) 함수
def new_counter():
    count = 0  # 이 변수 'count'는 외부 함수의 지역 변수입니다.

    # counter: 내부 함수
    def counter():
        # nonlocal 키워드는 잠시 후에 설명합니다.
        # 이 내부 함수는 외부 함수의 'count' 변수를 참조하고 수정합니다.
        nonlocal count
        count += 1
        return count

    # 외부 함수는 내부 함수(클로저)를 반환합니다.
    return counter

# 클로저 사용 예시
print("--- 클로저 정의 및 사용 예시 ---")
# new_counter()를 호출하면 새로운 클로저 인스턴스가 생성됩니다.
# add_health는 자신만의 독립적인 'count' 변수를 기억하는 클로저입니다.
add_health = new_counter()
print(f"첫 번째 카운터 호출: {add_health()}") # 출력: 1
print(f"두 번째 카운터 호출: {add_health()}") # 출력: 2
print(f"세 번째 카운터 호출: {add_health()}") # 출력: 3

# 또 다른 클로저 인스턴스를 생성합니다.
# add_mana는 add_health와는 완전히 별개의 'count' 변수를 기억하는 클로저입니다.
add_mana = new_counter()
print(f"두 번째 카운터의 첫 번째 호출: {add_mana()}") # 출력: 1
print(f"두 번째 카운터의 두 번째 호출: {add_mana()}") # 출력: 2
```

위 예시에서 `new_counter()` 함수는 `count`라는 변수를 정의하고, 이 `count` 변수를 사용하는 `counter()`라는 내부 함수를 정의한 후, `counter()` 함수를 반환합니다. `new_counter()`가 실행을 마친 후에도, 반환된 `add_health`와 `add_mana`는 각각 자신만의 `count` 변수(즉, `new_counter`가 호출될 때마다 생성된 독립적인 `count` 변수)를 **기억하고 유지**합니다. 이처럼 **내부 함수가 자신의 정의 환경(외부 함수의 스코프)에 있는 변수를 "닫아두고"(enclose) 기억하는 것**이 클로저의 본질입니다.

### 클로저의 활용

클로저의 가장 중요한 활용 목적 중 하나는 **함수 호출 간에 상태를 유지하는 데 사용**될 수 있다는 점입니다. 이는 객체 지향 프로그래밍의 클래스 인스턴스가 인스턴스 변수를 통해 상태를 유지하는 방식과 유사하지만, 클래스를 정의하지 않고도 상태를 관리할 수 있는 유연성을 제공합니다.

**클로저의 주요 활용 시나리오**:

- **상태 비저장(stateless) 함수에서 상태 관리**: 일반적으로 함수는 호출될 때마다 독립적으로 실행되지만, 클로저를 사용하면 특정 함수가 이전 호출의 결과를 '기억'하고 다음 호출에 반영할 수 있습니다. 이는 함수의 시그니처(인수 목록)를 변경하지 않고도 상태를 유지할 수 있다는 큰 장점을 가집니다.
    
- **부분 적용(Partial Application) 및 커링(Currying)**: 여러 인수를 받는 함수를 단일 인수를 받는 여러 함수로 변환하는 기법입니다. 클로저는 이 과정에서 중간 상태(이미 적용된 인수)를 기억하는 데 사용될 수 있습니다. (제4장의 `functools.partial` 예시를 다시 떠올려보세요. 사실 `partial`도 내부적으로 클로저와 유사한 방식으로 동작합니다.)
    
- **동적 함수 생성**: 특정 조건이나 설정에 따라 동작이 달라지는 함수를 동적으로 생성할 수 있습니다. 예를 들어, 로깅 시스템에서 메시지 포맷터 함수를 동적으로 생성하거나, 특정 패턴에 따라 문자열을 처리하는 함수를 만드는 데 활용됩니다.
    
- **데이터 집계(Aggregation)**: 여러 번의 함수 호출에 걸쳐 데이터를 누적하거나 집계하는 데 사용될 수 있습니다.
    

예를 들어, 문서의 총 단어 수를 누적해서 계산하는 로깅 시스템을 클로저로 구현해봅시다:

```python
def word_count_aggregator():
    total_words = 0  # 외부 함수의 변수이자, 클로저가 기억할 '상태'

    def process_document(doc_content):
        nonlocal total_words # 외부 함수의 total_words 변수를 수정하겠다고 선언
        words = doc_content.split() # 공백 기준으로 단어 분리
        total_words += len(words)  # 누적 합계 업데이트
        return total_words # 현재까지의 총 단어 수 반환

    return process_document

# 클로저 활용 예시
print("\n--- 클로저를 이용한 단어 수 집계 ---")
# 각 문서 처리 시마다 total_words를 기억하고 업데이트하는 클로저 생성
document_word_counter = word_count_aggregator()

print(f"문서 1 처리 후 총 단어 수: {document_word_counter('Hello functional programming!')}") # 출력: 3
print(f"문서 2 처리 후 총 단어 수: {document_word_counter('Python is great for FP.')}")  # 출력: 9 (이전 3 + 6)
print(f"문서 3 처리 후 총 단어 수: {document_word_counter('Closures are powerful.')}") # 출력: 12 (이전 9 + 3)

# 새로운 집계기를 만들면 상태가 리셋됩니다.
new_aggregator = word_count_aggregator()
print(f"새로운 집계기 첫 번째 문서: {new_aggregator('Start fresh.')}") # 출력: 2
```

이처럼 `word_count_aggregator`는 `total_words`라는 상태를 캡슐화하는 클로저 `process_document`를 반환하며, 이 클로저는 호출될 때마다 `total_words`의 값을 누적하여 업데이트합니다.

### `nonlocal` 키워드

파이썬에서 클로저 내의 외부 변수를 **수정**할 때 `nonlocal` 키워드를 사용해야 합니다. 만약 내부 함수에서 외부 스코프의 변수를 단순히 읽기만 한다면 `nonlocal` 키워드는 필요하지 않습니다. 하지만 내부 함수 내에서 외부 스코프의 변수에 새로운 값을 할당(재할당)하려고 시도하면, 파이썬 인터프리터는 해당 변수를 내부 함수의 지역 변수로 간주해 버립니다. 이 문제를 방지하고, **둘러싸는 스코프(non-local scope)의 변수를 수정하겠다**는 의도를 명시하기 위해 `nonlocal` 키워드를 사용하는 것입니다.

`global` 키워드와 `nonlocal` 키워드는 모두 변수의 스코프를 명시적으로 다루지만, 그 대상이 다릅니다:

- `global`: 함수 외부의 **전역 변수(global variable)**를 참조하거나 수정할 때 사용합니다.
    
- `nonlocal`: 현재 함수를 둘러싸는 스코프(즉, 내부 함수 입장에서의 외부 함수 스코프)에 있는 변수를 참조하거나 수정할 때 사용하며, 전역 스코프는 아닙니다.
    

대부분의 다른 프로그래밍 언어에서는 클로저 내에서 외부 변수를 수정할 때 `nonlocal`과 같은 명시적인 키워드가 필요하지 않습니다. 파이썬의 이러한 특징은 처음 접하는 개발자에게는 혼란스러울 수 있지만, 변수 스코프에 대한 명확성을 높여줍니다.

다음은 `nonlocal` 키워드가 필요하지 않은 예시입니다. 리스트나 딕셔너리와 같은 **뮤터블(mutable) 객체**의 내용을 변경할 때는 `nonlocal`이 필요 없습니다. 이는 객체 자체를 재할당하는 것이 아니라, 객체의 메서드(`append`, `update` 등)를 통해 객체 _내부의 내용_을 변경하는 것이기 때문입니다.

```python
def new_collection(initial_docs):
    # 초기 리스트의 '복사본'을 닫음: docs는 이제 new_collection 스코프의 변수
    # 원본 리스트가 외부에서 변경되는 것을 방지하기 위해 .copy()를 사용합니다.
    docs = initial_docs.copy()

    def add_doc(doc_name):
        # docs.append()는 리스트 객체 자체를 재할당하는 것이 아니라
        # 리스트의 '내용'을 변경하는 것이므로 'nonlocal'이 필요 없습니다.
        docs.append(doc_name)
        return docs
    return add_doc

print("\n--- 'nonlocal' 키워드 없이 뮤터블 객체 변경 예시 ---")
my_initial_docs = ["document_A"]
my_collection_builder = new_collection(my_initial_docs)

print(f"원본 초기 리스트: {my_initial_docs}") # ['document_A']

print(f"문서 추가 후: {my_collection_builder('document_B')}") # ['document_A', 'document_B']
print(f"문서 추가 후: {my_collection_builder('document_C')}") # ['document_A', 'document_B', 'document_C']

print(f"원본 초기 리스트는 여전히 그대로: {my_initial_docs}") # ['document_A']
```

위 예시에서 `docs.append(doc_name)`은 `docs` 변수가 가리키는 리스트 객체 _내부_의 내용을 변경하는 것이지, `docs` 변수 자체가 새로운 리스트 객체를 가리키도록 재할당하는 것이 아닙니다. 따라서 `nonlocal`이 필요 없습니다.

**클로저 내부 검사**: 파이썬은 클로저가 어떤 외부 변수를 "닫아두고" 있는지 확인할 수 있는 방법을 제공합니다. 함수의 `__code__` 속성과 `__closure__` 속성을 통해 클로저의 내부를 검사할 수 있습니다.

```python
def get_salary_func(bonus=0, taxes=0, penalty=0):
    def compute(salary):
        # 외부 변수: bonus, taxes, penalty
        pre_bonus = (salary - penalty)
        pre_taxes = pre_bonus + pre_bonus * bonus
        return pre_taxes - pre_taxes * taxes
    return compute

print("\n--- 클로저 내부 변수 검사 ---")
salary_calculator = get_salary_func(bonus=0.1, penalty=5000)

# __code__.co_freevars: 클로저가 참조하는 외부 변수들의 이름을 튜플로 반환
print(f"참조하는 외부 변수 이름: {salary_calculator.__code__.co_freevars}")

# __closure__: 클로저가 닫고 있는 외부 변수들의 '셀' 객체들을 튜플로 반환
# 각 셀 객체의 cell_contents 속성에 실제 값이 들어 있습니다.
print(f"클로저 셀 객체들: {salary_calculator.__closure__}")

# 외부 변수 이름과 값 출력
for i, name in enumerate(salary_calculator.__code__.co_freevars):
    print(f'{name} = {salary_calculator.__closure__[i].cell_contents}')

# 출력:
# 참조하는 외부 변수 이름: ('bonus', 'penalty', 'taxes')
# 클로저 셀 객체들: (<cell at 0x...: float object at 0x...>, <cell at 0x...: int object at 0x...>, <cell at 0x...: int object at 0x...>)
# bonus = 0.1
# penalty = 5000
# taxes = 0
```

이러한 속성을 통해 클로저의 동작 방식을 더 깊이 이해할 수 있지만, 클로저가 닫고 있는 변수들은 일반적으로 **읽기 전용 값**으로 간주하며 직접 조작하지 않는 것이 좋습니다. 대신, 새로운 클로저 인스턴스를 생성하여 원하는 상태를 초기화하는 것이 바람직합니다.

### 클로저와 순수 함수의 관계

**클로저는 일반적으로 순수 함수가 아닙니다.**

순수 함수는 두 가지 핵심 속성을 가집니다:

1. **동일한 입력에 대해 항상 동일한 출력(결과)을 반환합니다.**
    
2. **부수 효과(side effects)를 일으키지 않습니다.** (외부 상태를 변경하거나 I/O 작업을 수행하지 않습니다. 예를 들어, 콘솔에 출력하거나, 파일에 쓰거나, 데이터베이스를 업데이트하는 것 등은 모두 부수 효과입니다.)
    

클로저는 이 두 가지 속성 중 적어도 하나, 혹은 둘 다를 위반할 수 있습니다:

- **동일한 입력에 대해 다른 출력**: 클로저는 외부 스코프의 변수를 변경할 수 있으므로, 동일한 인수를 받아도 호출될 때마다 닫힌 변수의 값에 따라 다른 결과를 반환할 수 있습니다. 예를 들어, 위에서 본 `add_health()` 클로저는 인수가 없어도 호출될 때마다 1, 2, 3...과 같이 다른 값을 반환했습니다. 이는 순수 함수의 첫 번째 속성을 위반합니다.
    
- **부수 효과 발생**: 클로저가 외부 스코프의 변수를 변경하는 것은 곧 '외부 상태'를 변경하는 것이므로, 이는 부수 효과에 해당합니다. 순수 함수는 자신의 스코프 내에서만 동작해야 하며, 외부의 어떤 것도 수정해서는 안 됩니다.
    

**중요한 구분**: 클로저를 반환하는 **외부 함수(outer function) 자체는 순수 함수일 수 있습니다.** 예를 들어, `new_counter()` 함수를 다시 생각해봅시다. `new_counter()`를 호출할 때마다 (입력이 없으므로 동일한 입력) 항상 새롭고 독립적인 `count` 변수를 캡슐화하는 새로운 `counter` 함수를 반환합니다. 이는 `new_counter()` 함수 자체가 항상 동일한 유형의 '새로운 함수'를 반환하므로 순수하다고 볼 수 있습니다.

따라서, **"외부 함수는 순수하지만, 그 외부 함수가 반환하는 클로저(내부 함수)는 순수하지 않을 수 있다"**는 점을 이해하는 것이 중요합니다.

함수형 프로그래밍에서는 부수 효과를 완전히 없앨 수는 없지만, 가능한 한 그 수를 줄이고, **부수 효과가 발생하는 부분을 코드의 특정 영역(예: 애플리케이션의 시작이나 끝 부분, 또는 I/O 전용 모듈)에 집중**시킴으로써 코드의 예측 가능성과 테스트 용이성을 높이는 것을 목표로 합니다. 클로저는 이러한 부수 효과를 격리하고 관리하는 데 사용될 수 있습니다. 즉, 프로그램의 핵심 로직은 순수 함수로 작성하고, 상태 변경이나 I/O와 같은 '더러운(dirty)' 작업은 클로저를 통해 제한된 영역에서 처리하도록 설계하는 것입니다.

순수 함수는 테스트, 디버깅, 추론이 매우 용이합니다. 반면, 클로저는 상태를 가지기 때문에 테스트 시 매번 새로운 클로저 인스턴스를 생성하여 '초기 상태'로 시작해야 하는 등 테스트가 더 복잡해질 수 있습니다.

### 결론

클로저는 파이썬에서 **상태를 관리하고, 함수의 유연성을 높이며, 재사용 가능한 코드를 작성하는 데 매우 강력하고 유용한 패턴**입니다. 객체 지향의 클래스 없이도 특정 상태를 캡슐화하고 유지할 수 있는 메커니즘을 제공하며, 함수형 프로그래밍의 원칙(예: 고차 함수)과도 잘 통합됩니다.

비록 클로저 자체가 순수 함수는 아니며 부수 효과를 가질 수 있지만, 이를 통해 프로그램의 다른 순수 함수 부분이 외부 상태에 의존하지 않도록 분리하고, 부수 효과를 특정 영역에 집중시키는 데 기여할 수 있습니다. 파이썬 개발자들은 클로저를 이해하고 적절히 활용함으로써 더 깔끔하고 강력하며 유지보수하기 쉬운 코드를 작성할 수 있을 것입니다. 클로저는 함수형 프로그래밍과 객체 지향 프로그래밍의 아이디어를 혼합하여 사용할 때 상태 관리에 대한 새로운 시야와 유연성을 제공하는 중요한 도구입니다.