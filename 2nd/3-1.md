## 3.1 내장 고차 함수 활용

파이썬은 다중 패러다임을 지원하는 언어로, 함수형 프로그래밍(Functional Programming, FP) 스타일로 프로그램을 작성하는 데 유용한 여러 내장 고차 함수(Higher-Order Functions)를 제공합니다. 고차 함수란 하나 이상의 함수를 인자로 받거나 함수를 결과로 반환하는 함수를 의미합니다. 이러한 함수들을 활용하면 코드를 더욱 **간결하고 명확하게** 작성할 수 있으며, **디버깅과 테스트 용이성**을 높이고, **재사용성과 조합성**을 향상시킬 수 있습니다. 이는 프로그램의 상태 변화를 최소화하고 데이터의 흐름에 집중하는 함수형 프로그래밍의 핵심 개념과 부합합니다.

함수형 프로그래밍에서는 명령형(imperative) 스타일 대신 **선언형(declarative) 스타일**을 지향합니다. 명령형 프로그래밍은 컴퓨터에게 "무엇을 할지"와 "어떻게 할지"에 대한 구체적인 명령어 목록을 제공하는 반면, 선언형 프로그래밍은 단순히 "무엇을 원하는지"를 명세하고, 언어 구현체가 그 방법을 결정하도록 합니다. 파이썬의 내장 고차 함수들은 이러한 선언형 스타일의 코드를 작성하는 데 큰 도움을 줍니다.

### `map()`: 각 요소에 함수 적용

`map()` 함수는 이터러블(iterable)의 모든 요소에 주어진 함수를 적용하고, 그 결과를 새로운 이터레이터(iterator)로 반환하는 고차 함수입니다. `map()`은 일반적으로 데이터 변환(transformation) 작업에 사용됩니다. 이 함수는 명시적인 반복문(`for` 또는 `while`) 없이 컬렉션의 각 항목에 작업을 수행할 수 있게 하여, 코드를 더 간결하게 만듭니다.

`map()`의 기본 형태는 `map(함수, 이터러블1, 이터러블2, ...)` 입니다. 여기서 `함수`는 `이터러블`의 각 요소에 적용될 함수이며, `이터러블`은 요소를 제공하는 시퀀스입니다. `map()`은 결과를 한 번에 모두 계산하여 목록으로 만드는 대신, 필요할 때마다 값을 계산하는 **게으른 평가(lazy evaluation)** 방식을 사용합니다. 따라서 매우 크거나 무한한 데이터 스트림을 다룰 때 메모리 효율적입니다.

**예시: 숫자 목록의 각 요소를 두 배로 만들기**

```
# 일반적인 명령형 방식 (for 루프 사용)
numbers =
doubled_numbers_imperative = []
for num in numbers:
    doubled_numbers_imperative.append(num * 2)
print(f"명령형 방식: {doubled_numbers_imperative}") # 명령형 방식:

# map()을 사용한 함수형 방식
def double(x):
    return x * 2

numbers =
doubled_numbers_functional = map(double, numbers)

# map 객체는 이터레이터이므로 리스트로 변환하여 출력
print(f"함수형 방식 (map): {list(doubled_numbers_functional)}") # 함수형 방식 (map):
```

에서 볼 수 있듯이, `map()`의 기능은 리스트 컴프리헨션(list comprehension)으로도 구현할 수 있습니다. 리스트 컴프리헨션은 더 간결한 파이썬스러운 구문을 제공하며, `map()`과 유사하게 데이터 변환에 유용하게 사용됩니다.

```
# 리스트 컴프리헨션을 사용한 방식
numbers =
doubled_numbers_listcomp = [num * 2 for num in numbers]
print(f"리스트 컴프리헨션: {doubled_numbers_listcomp}") # 리스트 컴프리헨션:
```

`map()`은 여러 이터러블을 인자로 받아, 함수가 그 이터러블들의 각 요소를 동시에 처리하도록 할 수도 있습니다.

```
# 여러 이터러블에 map() 적용
from operator import mul # operator 모듈의 mul 함수는 * 연산과 동일

numbers =
factors = [1.0, 1.5, 0.5, 2.0]

# 람다 표현식 사용
results_lambda = map(lambda n, f: n * f, numbers, factors)
print(f"람다 사용 결과: {list(results_lambda)}") # 람다 사용 결과: [7.0, 6.0, 1.5, 4.0]

# operator.mul 사용
results_mul = map(mul, numbers, factors)
print(f"operator.mul 사용 결과: {list(results_mul)}") # operator.mul 사용 결과: [7.0, 6.0, 1.5, 4.0]
```

### `filter()`: 조건에 맞는 요소 선택

`filter()` 함수는 이터러블의 요소들 중 특정 조건(predicate)을 만족하는 요소만 선택하여 새로운 이터레이터로 반환하는 고차 함수입니다. 여기서 **프레디케이트(predicate)**는 어떤 조건의 진릿값을 반환하는 함수를 의미하며, `filter()`와 함께 사용될 때는 단일 값을 인자로 받아야 합니다.

`filter()`의 기본 형태는 `filter(프레디케이트, 이터러블)` 입니다. `map()`과 마찬가지로, `filter()`도 게으른 평가를 사용하여 메모리 효율적입니다.

**예시: 숫자 목록에서 짝수만 선택하기**

```
# 일반적인 명령형 방식 (for 루프와 if 조건 사용)
numbers = range(10)
even_numbers_imperative = []
for num in numbers:
    if num % 2 == 0:
        even_numbers_imperative.append(num)
print(f"명령형 방식: {even_numbers_imperative}") # 명령형 방식:

# filter()를 사용한 함수형 방식
def is_even(x):
    return (x % 2) == 0

numbers = range(10)
even_numbers_functional = filter(is_even, numbers)
print(f"함수형 방식 (filter): {list(even_numbers_functional)}") # 함수형 방식 (filter):
```

`filter()` 역시 리스트 컴프리헨션으로 유사하게 구현할 수 있으며, 조건문을 포함하여 코드를 더욱 간결하게 표현할 수 있습니다.

```
# 리스트 컴프리헨션을 사용한 방식
numbers = range(10)
even_numbers_listcomp = [x for x in numbers if x % 2 == 0]
print(f"리스트 컴프리헨션: {even_numbers_listcomp}") # 리스트 컴프리헨션:
```

### `functools.reduce()`: 요소를 단일 값으로 집계

`functools` 모듈에 포함된 `reduce()` 함수는 이터러블의 모든 요소에 이항 함수를 누적적으로 적용하여 단일 결과 값을 산출하는 고차 함수입니다. 이는 이터러블의 요소들을 하나로 "줄여나가는" 작업에 사용됩니다. `reduce()`는 무한 이터러블에는 적용할 수 없습니다.

`reduce()`의 기본 형태는 `functools.reduce(함수, 이터러블, [초기값])` 입니다. `함수`는 두 개의 인자를 받아 단일 값을 반환하는 이항 함수여야 합니다. `reduce()`는 이터레이터에서 첫 두 요소 A와 B를 가져와 `함수(A, B)`를 계산합니다. 그리고 세 번째 요소 C와 이 결과를 결합하여 `함수(결과, C)`를 계산하는 식으로 이터러블이 소진될 때까지 계속합니다. `초기값`이 제공되면, 첫 계산은 `함수(초기값, 첫_요소)`가 됩니다.

**예시: 숫자 목록의 모든 요소를 곱하기**

```
import functools
import operator # operator 모듈은 파이썬 연산자에 해당하는 함수들을 제공합니다

# 일반적인 명령형 방식 (for 루프 사용)
numbers =
product_imperative = 1
for num in numbers:
    product_imperative *= num
print(f"명령형 방식: {product_imperative}") # 명령형 방식: 120

# functools.reduce()를 사용한 함수형 방식
# operator.mul은 * 연산과 동일
numbers =
product_functional = functools.reduce(operator.mul, numbers)
print(f"함수형 방식 (reduce): {product_functional}") # 함수형 방식 (reduce): 120
```

`initial_value` 인자를 사용하면 빈 시퀀스에 대한 `TypeError`를 방지하고, 계산의 시작점을 설정할 수 있습니다.

```
# 초기값을 사용하여 빈 리스트 처리
print(f"빈 리스트에 초기값 없이 reduce 적용: {functools.reduce(operator.mul, [], 1)}") # 빈 리스트에 초기값 없이 reduce 적용: 1
# 초기값 없이 빈 리스트에 reduce 적용 시 TypeError 발생
# print(functools.reduce(operator.mul, [])) # TypeError: reduce() of empty sequence with no initial value
```

`functools.reduce()`의 많은 사용 사례는 명시적인 `for` 루프로 작성하는 것이 더 명확할 수 있습니다.

### `sorted()`, `min()`, `max()`, `sum()`, `any()`, `all()`

파이썬은 이터러블을 처리하고 단일 값을 산출하는 여러 내장 함수들을 제공합니다. 이들은 **축소(reducing) 함수**라고도 불립니다.

- **`sorted(iterable, key=None, reverse=False)`**: 이터러블의 모든 요소를 수집하여 리스트로 정렬하고 그 결과를 반환합니다. 원본 리스트를 제자리에서 변경하는 `list.sort()` 메서드와 달리 `sorted()`는 정렬된 새 리스트를 반환합니다. `key` 인자를 사용하여 사용자 정의 정렬 기준을 제공할 수 있습니다.
    
    ```
    employees = [('Dilbert', 42), ('Alice', 37), ('Dogbert', 7), ('Ashok', 21)]
    
    # 이름 기준 정렬 (람다 사용)
    by_name = sorted(employees, key=lambda e: e)
    print(f"이름 기준 정렬: {by_name}") # 이름 기준 정렬: [('Alice', 37), ('Ashok', 21), ('Dilbert', 42), ('Dogbert', 7)]
    
    # 나이 기준 내림차순 정렬 (람다 및 reverse=True 사용)
    by_age_desc = sorted(employees, key=lambda e: e, reverse=True)
    print(f"나이 기준 내림차순 정렬: {by_age_desc}") # 나이 기준 내림차순 정렬: [('Dilbert', 42), ('Alice', 37), ('Ashok', 21), ('Dogbert', 7)]
    ```
    

에서 언급했듯이, `operator` 모듈의 `itemgetter` 함수를 사용하여 튜플의 특정 인덱스에 접근하는 클로저를 생성할 수도 있습니다. 클래스의 경우 `attrgetter`를 사용하여 속성에 이름으로 접근하고, `methodcaller`를 사용하여 각 항목의 메서드를 호출할 수 있습니다.

- **`min(iterable, *[, key, default])` / `max(iterable, *[, key, default])`**: 각각 이터러블의 가장 작거나 큰 요소를 반환합니다. 빈 이터러블에 적용할 경우 `ValueError`를 발생시키지만, `default` 인자를 제공하여 이를 방지할 수 있습니다. `key` 인자를 사용하여 비교 기준을 지정할 수 있습니다.
    
    ```
    numbers =
    print(f"최소값: {min(numbers)}, 최대값: {max(numbers)}") # 최소값: 1, 최대값: 9
    
    # 빈 리스트에 default 값 적용
    empty_list = []
    print(f"빈 리스트의 최소값 (default=0): {min(empty_list, default=0)}") # 빈 리스트의 최소값 (default=0): 0
    ```
    
- **`sum(iterable, /, start=0)`**: 이터러블의 항목들을 모두 더하고 그 합계를 반환합니다. 선택적으로 `start`값을 제공하여 합산의 시작점을 변경할 수 있습니다. 문자열 연결에는 사용할 수 없으며, `str.join()` 메서드를 사용해야 합니다.
    
    ```
    numbers =
    print(f"합계: {sum(numbers)}") # 합계: 10
    
    # 100부터 시작하는 합계
    print(f"100부터 시작하는 합계: {sum(numbers, 100)}") # 100부터 시작하는 합계: 110
    
    letters = ['abc', 'de', 'f']
    # print(sum(letters, '')) # TypeError 발생
    print(f"문자열 연결: {''.join(letters)}") # 문자열 연결: abcdef
    ```
    
- **`any(iterable)`**: 이터러블의 어떤 요소라도 참값(True)이면 `True`를 반환합니다. 모든 요소가 거짓(False)이면 `False`를 반환합니다. 빈 이터러블의 경우 `False`를 반환합니다.
    
    ```
    print(f"any(): {any()}")     # any(): True
    print(f"any(): {any()}")     # any(): False
    print(f"any(['', 'a']): {any(['', 'a'])}")   # any(['', 'a']): True
    print(f"any([]): {any([])}")                 # any([]): False
    ```
    
- **`all(iterable)`**: 이터러블의 모든 요소가 참값(True)이면 `True`를 반환하고, 하나라도 거짓(False)이면 `False`를 반환합니다. 빈 이터러블의 경우 `True`를 반환합니다.
    
    ```
    print(f"all(): {all()}")     # all(): True
    print(f"all(): {all()}")     # all(): False
    print(f"all(['a', 'b']): {all(['a', 'b'])}") # all(['a', 'b']): True
    print(f"all(['', 'b']): {all(['', 'b'])}")   # all(['', 'b']): False
    print(f"all([]): {all([])}")                 # all([]): True
    ```
    

### `enumerate()`, `zip()`: 여러 시퀀스 동시 처리

`enumerate()`와 `zip()`은 여러 시퀀스를 동시에 처리하는 데 유용한 내장 함수입니다.

- **`enumerate(iterable, start=0)`**: 이터러블의 요소를 세어 튜플로 반환하는 이터레이터를 생성합니다. 각 튜플은 `(카운트, 요소)` 형태를 가집니다. 특정 조건이 충족되는 인덱스를 기록하면서 목록을 반복할 때 자주 사용됩니다.
    
    ```
    fruits = ['apple', 'banana', 'cherry']
    
    # 기본 사용 (0부터 시작)
    for index, fruit in enumerate(fruits):
        print(f"{index}: {fruit}")
    # 0: apple
    # 1: banana
    # 2: cherry
    
    # 1부터 시작하는 카운트
    for index, fruit in enumerate(fruits, start=1):
        print(f"{index}. {fruit}")
    # 1. apple
    # 2. banana
    # 3. cherry
    ```
    
- **`zip(iterA, iterB, ...)`**: 여러 이터러블에서 각각 하나의 요소를 가져와 튜플로 묶어 반환하는 이터레이터를 생성합니다. 이는 인메모리 리스트를 먼저 구성하지 않고 요청 시에만 튜플을 구성하고 반환하는 게으른 평가 방식을 따릅니다. 결과 스트림의 길이는 가장 짧은 이터러블의 길이와 동일합니다.
    
    ```
    names = ['Dilbert', 'Dogbert', 'Ashok']
    jobs = ['Engineer', 'Consultant', 'Intern']
    salaries =
    
    # zip()으로 여러 리스트 결합
    employees = zip(names, jobs, salaries)
    for employee in employees:
        print(employee)
    # ('Dilbert', 'Engineer', 120000)
    # ('Dogbert', 'Consultant', 250000)
    # ('Ashok', 'Intern', 18000)
    
    # zip()을 이용한 언패킹
    names_unzipped, jobs_unzipped, salaries_unzipped = zip(*zip(names, jobs, salaries))
    print(f"언패킹된 이름: {list(names_unzipped)}")       # 언패킹된 이름: ['Dilbert', 'Dogbert', 'Ashok']
    print(f"언패킹된 직업: {list(jobs_unzipped)}")       # 언패킹된 직업: ['Engineer', 'Consultant', 'Intern']
    print(f"언패킹된 급여: {list(salaries_unzipped)}") # 언패킹된 급여:
    ```
    
    `zip()`은 모든 이터러블의 길이가 같다고 가정하고 사용해야 합니다. 길이가 다른 이터러블과 함께 사용하면 긴 이터러블의 요소가 버려질 수 있어 주의해야 합니다. `itertools` 모듈의 `zip_longest` 함수는 길이가 다른 이터러블을 처리할 때 짧은 이터러블이 소진되어도 멈추지 않고, 긴 이터러블이 소진될 때까지 `fillvalue`로 값을 채워 넣습니다.
    

### `filter()`, `map()`, `reduce()` 패턴 적용

`filter()`, `map()`, `reduce()`는 각각 다른 역할을 하지만, 함께 조합하여 데이터를 처리하는 **파이프라인(pipeline)**을 구성할 때 강력한 패턴을 이룹니다. 이 패턴은 복잡한 데이터 변환 및 집계 작업을 여러 단계로 나누어 수행할 수 있게 합니다.

1. **`filter()`**: 먼저, 원본 데이터에서 특정 조건을 만족하는 요소들을 걸러냅니다. 이는 처리할 데이터의 양을 줄이는 첫 번째 단계가 됩니다.
2. **`map()`**: 다음으로, 걸러진 각 요소에 함수를 적용하여 새로운 형태로 변환합니다. 이 단계는 데이터의 구조나 값을 변경합니다.
3. **`reduce()`**: 마지막으로, 변환된 요소들을 하나의 최종 결과 값으로 집계합니다. 이는 모든 중간 결과들을 요약하는 단계입니다.

이러한 함수들은 **게으른 평가** 방식으로 작동하기 때문에, 전체 이터러블을 한 번에 메모리에 로드하거나 중간 결과를 모두 계산할 필요 없이, 필요할 때마다 값을 처리하며 다음 단계로 넘겨줍니다. 이는 대규모 데이터 처리 시 메모리 및 성능 이점을 제공합니다.

**예시: 프로젝트의 총 인건비 계산**

이 예시는 직원들의 이름, 시간당 단가, 그리고 프로젝트에 투입된 시간을 포함하는 튜플 목록을 사용하여 프로젝트의 총 인건비를 계산하는 과정을 보여줍니다.

```
import functools
import operator

efforts = [ # (이름, 단가, 시간)
    ('Dilbert', 220, 13.5),
    ('Alice', 180, 16.0),
    ('Wally', 150, 0.0), # Wally는 작업 시간 0
    ('Ashok', 80, 42.5),
    ('Dogbert', 250, 3.5),
    ('Pointy Haired Boss', 500, 0.0), # 상사도 작업 시간 0
]

# 1. filter: 실제 작업 시간이 있는 (0.0보다 큰) 항목만 유지
# lambda e: e > 0.0 는 튜플의 세 번째 요소(시간)가 0보다 큰지 확인하는 프레디케이트
involved = filter(lambda e: e > 0.0, efforts)
print(f"필터링된 작업자: {list(involved)}")
# 필터링된 작업자: [('Dilbert', 220, 13.5), ('Alice', 180, 16.0), ('Ashok', 80, 42.5), ('Dogbert', 250, 3.5)]

# involved 이터레이터가 소진되었으므로 다시 생성
involved = filter(lambda e: e > 0.0, efforts)

# 2. map: 각 직원의 비용 계산 (단가 * 시간)
# lambda e: e * e 는 튜플의 두 번째 요소(단가)와 세 번째 요소(시간)를 곱하는 함수
cost_per_employee = map(lambda e: e * e, involved)
print(f"각 직원별 비용: {list(cost_per_employee)}")
# 각 직원별 비용: [2970.0, 2880.0, 3400.0, 875.0]

# cost_per_employee 이터레이터가 소진되었으므로 다시 생성
involved = filter(lambda e: e > 0.0, efforts)
cost_per_employee = map(lambda e: e * e, involved)

# 3. reduce: 모든 개별 비용을 합산
# operator.add는 + 연산과 동일
total_costs = functools.reduce(operator.add, cost_per_employee)
print(f"총 인건비: {total_costs}") # 총 인건비: 10125.0
```

위 예시에서 `filter()` 단계는 사실상 중복될 수 있습니다. 왜냐하면 작업 시간이 0인 직원은 총 비용에 영향을 미치지 않기 때문입니다. 또한 `reduce()` 단계는 `sum()` 함수로 간소화될 수 있습니다.

```
# filter() 단계를 생략하고 sum() 사용
cost_per_employee_simplified = map(lambda e: e * e, efforts)
total_costs_simplified = sum(cost_per_employee_simplified)
print(f"간소화된 총 인건비: {total_costs_simplified}") # 간소화된 총 인건비: 10125.0
```

이러한 파이프라인 접근 방식은 코드를 **더욱 모듈화**하고, 각 함수의 책임을 명확하게 분리하여 **이해하기 쉽고 테스트하기 용이한** 코드를 만듭니다. 명령형 코드에 비해 줄 수는 길어질 수 있지만, 각 기능 블록이 독립적으로 동작하며 예측 가능하므로 버그를 추적하고 수정하는 데 훨씬 효과적입니다.