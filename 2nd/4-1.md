## 4.1 클로저(Closures)

함수형 프로그래밍에서 함수는 데이터처럼 취급됩니다. 즉, 함수를 변수에 저장하고, 다른 함수의 인자로 전달하며, 심지어 다른 함수의 반환값으로 사용할 수 있습니다. 이러한 유연성 덕분에 파이썬과 같은 다중 패러다임 언어에서 함수형 프로그래밍 스타일을 구현할 수 있습니다. **클로저(Closure)**는 이러한 함수형 패러다임의 핵심 개념 중 하나로, 함수가 자신의 정의된 외부 환경의 변수를 "기억"하고 참조할 수 있게 해주는 특별한 유형의 함수입니다.

### 함수가 외부 환경의 변수를 참조하는 방식

**클로저**는 **외부 함수(outer function)**가 정의한 **내부 함수(inner function)**가 외부 함수의 스코프에 있는 변수(이를 **자유 변수(free variables)**라고 합니다)를 참조하고, 심지어 외부 함수가 실행을 완료하여 사라진 후에도 이 변수들에 접근할 수 있도록 하는 메커니즘을 말합니다.

일반적으로 함수가 실행을 마치면 그 함수의 지역 변수들은 소멸됩니다. 그러나 클로저는 이러한 일반적인 규칙을 벗어나, 내부 함수가 정의될 때 외부 함수의 환경(environment)이 내부 함수와 함께 "묶여(bundled)" 하나의 단일 엔티티를 형성합니다. 따라서 외부 함수가 값을 반환한 후에도, 반환된 내부 함수는 자신이 정의될 당시의 외부 스코프에 있던 자유 변수들의 값에 접근할 수 있게 됩니다.

파이썬에서 클로저가 작동하는 방식은 다음과 같습니다:

1. **외부 함수 정의**: 외부 함수는 하나 이상의 지역 변수를 선언합니다.
    
2. **내부 함수 정의**: 외부 함수 내부에 또 다른 함수(내부 함수)가 정의됩니다.
    
3. **자유 변수 참조**: 내부 함수는 외부 함수의 지역 변수 중 일부(자유 변수)를 참조합니다.
    
4. **내부 함수 반환**: 외부 함수는 내부 함수 자체를 반환합니다. 이때 내부 함수는 자신이 참조하는 외부 함수의 지역 변수들(즉, 자유 변수들)과 함께 "패키지"되어 반환됩니다.
    

이렇게 반환된 내부 함수를 호출하면, 마치 그 변수들이 여전히 존재했던 것처럼 자유 변수에 접근하고 사용할 수 있습니다. 이는 마치 함수가 특정 시점의 "상태"를 저장하고 그 상태 위에서 연산을 수행할 수 있도록 하는 것과 같습니다.

다음 예제를 통해 클로저가 외부 환경의 변수를 어떻게 참조하는지 살펴보겠습니다. `get_compute_salary_func`함수는 연도(year)를 인자로 받아 해당 연도의 보너스 비율(bonus_rate)을 결정하고, 이를 참조하는 내부 함수 `compute_yearly_salary`를 반환합니다.

```
# 클로저 예제: 외부 환경의 변수 참조
def get_compute_salary_func(year):
    """
    주어진 연도에 대한 연봉 계산 함수를 반환합니다.
    이때, 해당 연도의 보너스율을 클로저로 캡처합니다.
    """
    bonus_rates = {
        2018: 0.05,
        2019: 0.10,
        2020: 0.07,
    }
    # 외부 스코프의 변수 'bonus_rate'
    bonus_rate = bonus_rates.get(year, 0.0)

    def compute_yearly_salary(monthly):
        """
        월급을 기반으로 연봉과 캡처된 보너스율을 사용하여 총 연봉을 계산합니다.
        """
        base_salary = monthly * 12
        bonus = base_salary * bonus_rate # 외부 스코프의 bonus_rate 참조
        return base_salary + bonus

    return compute_yearly_salary # 내부 함수를 반환

# 2020년 연봉 계산 클로저 생성
compute_2020_salaries = get_compute_salary_func(2020)
# 2018년 연봉 계산 클로저 생성
compute_2018_salaries = get_compute_salary_func(2018)

# 생성된 클로저 함수들을 사용하여 연봉 계산
print(f"2020년 연봉 (월급 80000): {compute_2020_salaries(80000):.1f}")
# 출력: 2020년 연봉 (월급 80000): 1027200.0
print(f"2018년 연봉 (월급 80000): {compute_2018_salaries(80000):.1f}")
# 출력: 2018년 연봉 (월급 80000): 1008000.0

# 여러 연봉을 일괄 계산 (map 함수와 클로저 조합)
base_salaries = [50000, 80000, 100000]
total_2020_salaries = list(map(compute_2020_salaries, base_salaries))
print(f"2020년 기준 여러 연봉: {total_2020_salaries}")
# 출력: 2020년 기준 여러 연봉: [642000.0, 1027200.0, 1284000.0]
```

위 예시에서 `compute_yearly_salary` 함수는 `get_compute_salary_func`의 지역 변수인 `bonus_rate`를 참조합니다. `get_compute_salary_func`가 실행을 마친 후에도, 반환된 `compute_2020_salaries`나 `compute_2018_salaries`와 같은 클로저는 각각의 `bonus_rate` 값(2020년의 0.07, 2018년의 0.05)을 "기억"하고 있기 때문에, 나중에 호출될 때 해당 값을 사용하여 올바른 연봉을 계산할 수 있습니다.

파이썬에서는 내부 함수가 외부 함수의 변수를 **읽기만** 할 때는 특별한 키워드가 필요 없지만, 그 값을 **수정**할 때는 `nonlocal` 키워드를 사용해야 합니다. 이는 외부 스코프의 변수를 지역 변수로 재정의하는 것을 방지하고, 해당 변수가 외부 스코프에 정의된 것임을 명확히 합니다.

### 클로저를 이용한 상태 유지 및 불순 함수 생성

클로저는 함수가 **상태(state)**를 유지하고 업데이트할 수 있도록 하여, 매 호출마다 다른 결과를 생성할 수 있도록 합니다. 이는 매 호출 시마다 인자로 상태를 명시적으로 전달할 필요 없이, 함수가 이전에 호출되었을 때의 정보를 "기억"할 수 있게 해줍니다.

하지만 이러한 상태 유지 특성은 함수형 프로그래밍의 핵심 원칙 중 하나인 **순수 함수(pure function)**와 상충됩니다. 순수 함수는 다음과 같은 두 가지 중요한 속성을 가집니다:

1. **동일한 입력에 대해 항상 동일한 출력 반환**: 예측 가능한 동작을 보장합니다.
    
2. **부수 효과(side effects) 없음**: 함수 외부의 어떤 상태도 변경하지 않으며, 외부 환경에 영향을 주지 않습니다 (예: 콘솔 출력, 파일 쓰기, 전역 변수 변경 등).
    

클로저를 사용하여 상태를 유지하는 함수는, 그 상태가 매 호출마다 변경될 수 있으므로, **동일한 입력에 대해 다른 출력을 반환할 수 있게 됩니다.** 이러한 함수는 **불순 함수(impure function)**로 간주됩니다. 왜냐하면 함수의 동작이 입력 외에 "숨겨진" 내부 상태에 의존하기 때문입니다.

예를 들어, 카운터 함수를 클로저로 구현하면, 매 호출마다 카운트가 증가하여 다른 값을 반환하게 됩니다.

```
# 클로저를 이용한 상태 유지 및 불순 함수 생성 예제: 카운터
def new_counter():
    """
    내부 카운트 변수를 클로저로 캡처하여 증가시키는 카운터 함수를 반환합니다.
    """
    count = 0  # 이 변수는 클로저에 의해 '기억'됩니다.

    def counter():
        nonlocal count # 외부 스코프의 count 변수를 수정함을 명시
        count += 1
        return count
    return counter

# 새로운 카운터 인스턴스 생성
my_counter = new_counter()
another_counter = new_counter() # 독립적인 카운터 인스턴스

print(f"my_counter 호출 1: {my_counter()}") # 출력: 1
print(f"my_counter 호출 2: {my_counter()}") # 출력: 2
print(f"another_counter 호출 1: {another_counter()}") # 출력: 1
print(f"my_counter 호출 3: {my_counter()}") # 출력: 3
```

이 예시에서 `my_counter`와 `another_counter`는 각각 독립적인 `count` 변수를 기억하고 있어, 같은 인자(없음)로 호출해도 매번 다른 결과를 반환하는 **불순 함수**가 됩니다. 이러한 상태 변경은 함수의 "부수 효과" 중 하나로 볼 수 있습니다.

함수형 프로그래밍은 가능한 한 많은 함수를 순수하게 유지하고, 부수 효과는 코드의 특정 고수준 영역(예: I/O 작업)에 **포함(contain)**시키는 것을 권장합니다. 이는 디버깅과 테스트를 훨씬 용이하게 만들기 때문입니다. 불순 함수가 필요할 경우에도, 클로저를 사용하면 이러한 상태 변경 로직을 깔끔하게 캡슐화할 수 있습니다.

### 클래스(Classes)와 클로저의 비교

클래스와 클로저는 모두 **상태를 관리**하고 특정 동작을 수행하는 데 사용될 수 있다는 점에서 유사점을 가집니다. 하지만 이들은 근본적인 설계 철학과 사용 방식에서 차이가 있습니다.

**클래스(Classes)**는 객체 지향 프로그래밍(OOP)의 핵심 구성 요소로, 데이터(속성)와 그 데이터를 조작하는 메서드(행동)를 하나의 `캡슐(capsule)` 안에 묶습니다. 클래스 인스턴스는 `생성자(__init__)`를 통해 상태를 초기화하며, 메서드는 `self`를 통해 이 내부 상태에 접근하거나 수정합니다. 클래스는 복잡하고 오래 지속되는(long-lived) 상태를 가지는 `개체(entities)`를 모델링하고, 이 개체들이 서로 상호작용하는 시스템을 구성하는 데 매우 효과적입니다.

반면 **클로저(Closures)**는 함수형 프로그래밍의 개념으로, 외부 함수의 스코프에 있는 변수들을 "기억"하는 내부 함수를 통해 상태를 관리합니다. 클로저는 클래스처럼 명시적인 `self`나 `속성`을 가지지 않지만, 함수가 정의될 때 외부 환경의 변수들이 암묵적으로 `캡처`되어 내부 함수가 이들을 사용할 수 있게 됩니다.

다음은 반올림 기능을 클래스와 클로저로 각각 구현한 예시입니다.

```
# 클래스를 이용한 반올림 기능
class Rounder:
    """
    주어진 자릿수에 따라 값을 반올림하는 Rounder 클래스.
    __call__ 메서드를 통해 인스턴스를 함수처럼 호출할 수 있습니다.
    """
    def __init__(self, granularity):
        self._granularity = granularity # 상태 초기화 (생성자)

    def __call__(self, value): # __call__을 사용하여 객체를 함수처럼 호출 가능하게 함
        scaled_up = value * (1 / self._granularity)
        rounded = round(scaled_up)
        scaled_down = rounded * self._granularity
        return scaled_down

# 클로저를 이용한 반올림 기능
def get_round_to_func(granularity):
    """
    주어진 자릿수에 따라 값을 반올림하는 클로저 함수를 반환합니다.
    """
    def round_to(value):
        # 외부 스코프의 'granularity' 변수를 참조
        scaled_up = value * (1 / granularity)
        rounded = round(scaled_up)
        scaled_down = rounded * granularity
        return scaled_down
    return round_to

# 사용 예시
grades = [5.234, 4.738, 3.269]
granularity = 0.05

# 클래스 사용
rounder_obj = Rounder(granularity)
rounded_by_class = list(map(rounder_obj, grades)) # 객체를 함수처럼 호출
print(f"클래스를 사용한 반올림: {rounded_by_class}")
# 출력: 클래스를 사용한 반올림: [5.25, 4.75, 3.25]

# 클로저 사용
round_to_func = get_round_to_func(granularity)
rounded_by_closure = list(map(round_to_func, grades))
print(f"클로저를 사용한 반올림: {rounded_by_closure}")
# 출력: 클로저를 사용한 반올림: [5.25, 4.75, 3.25]
```

두 방식 모두 `granularity`라는 "상태"를 캡슐화하고, 그 상태에 따라 `value`를 처리하는 함수(또는 객체)를 생성합니다. 파이썬의 `__call__` 메서드는 클래스 인스턴스를 마치 함수처럼 호출할 수 있게 하여, 클래스와 클로저 간의 경계를 모호하게 만들기도 합니다.

**주요 비교점 및 권장 사용 사례:**

- **명확성과 구조**: 클래스는 복잡한 상태와 행동을 구조화하고 계층적으로 모델링하는 데 유리합니다. 반면 클로저는 더 간결하고, 특정 작업에 필요한 최소한의 상태를 캡슐화하는 데 적합합니다.
    
- **재사용성 및 유연성**: 클로저는 기존 함수의 일부 인자를 미리 채워 넣은 "변형 함수"를 동적으로 생성하는 데 유용합니다 (부분 함수 적용 및 커링과 관련). 클래스는 재사용 가능한 `Blueprint`를 제공하고 `다형성`과 `상속`을 통해 코드를 확장할 수 있지만, 함수형 프로그래밍에서는 `상속`이 잘 맞지 않는다고 보는 시각도 있습니다.
    
- **상태 관리의 명시성**: 클래스는 `self` 키워드를 통해 상태에 대한 접근이 명시적입니다. 클로저는 자유 변수를 통해 상태에 접근하지만, `nonlocal`을 사용하지 않는 한 변경이 명시적으로 드러나지 않을 수 있습니다.
    
- **디버깅 및 테스트**: 순수 함수와 달리 클로저나 클래스 인스턴스는 내부 상태에 따라 동작이 달라지므로 디버깅이 복잡해질 수 있습니다. 하지만 잘 설계된 경우, 클래스의 메서드나 클로저 자체를 독립적으로 테스트할 수 있습니다.
    
- **성능**: 일반적으로 재귀 대신 루프를 사용하거나 데이터 구조를 수정하는 대신 재생성하는 것과 같이, 특정 함수형 구성 요소는 절차적 또는 객체 지향 코드보다 효율성이 떨어질 수 있습니다.
    

**결론적으로**, `Boot Dev` 소스에서는 "필요한 경우 클래스를 사용하지만, 일반적으로는 함수를 우선적으로 사용하는 것이 좋다"고 조언합니다. 즉, 코드가 복잡하고 오래 지속되며 공유되는 가변 상태를 관리해야 할 때 클래스를 고려하는 것이 좋습니다. 반면, 특정 작업을 위한 간결한 상태 캡슐화나 함수 변형이 필요할 때는 클로저가 더 적합한 선택이 될 수 있습니다. 파이썬은 여러 패러다임을 지원하므로, 문제의 성격과 코드의 가독성, 유지보수성을 고려하여 가장 적절한 도구를 선택하는 것이 중요합니다.

파이썬에서는 클로저의 내부를 검사할 수 있는 특별한 속성도 제공합니다. `__code__.co_freevars`를 통해 클로저가 참조하는 자유 변수들의 이름을 얻을 수 있으며, `__closure__` 속성의 각 요소(`cell_contents`)를 통해 해당 변수들의 실제 값을 확인할 수 있습니다.

```
# 클로저 검사 예제
def get_salary_func(bonus=0, taxes=0, penalty=0):
    """
    주어진 인자들을 클로저로 캡처하여 연봉을 계산하는 함수를 반환합니다.
    """
    def compute(salary):
        pre_bonus = (salary - penalty)
        pre_taxes = pre_bonus + pre_bonus * bonus
        return pre_taxes - pre_taxes * taxes
    return compute

salary_func = get_salary_func(bonus=0.1, taxes=0.05, penalty=5000) # taxes 인자 추가

print(f"클로저의 자유 변수 이름: {salary_func.__code__.co_freevars}") # 자유 변수들의 이름 (튜플)
# 출력: 클로저의 자유 변수 이름: ('bonus', 'penalty', 'taxes')

# __closure__ 속성을 통해 각 자유 변수의 값을 접근
# 각 요소는 'cell' 객체이며, 실제 값은 cell_contents에 있습니다.
if salary_func.__closure__:
    for i, var_name in enumerate(salary_func.__code__.co_freevars):
        print(f"{var_name} 값: {salary_func.__closure__[i].cell_contents}")
# 출력:
# bonus 값: 0.1
# taxes 값: 0.05
# penalty 값: 5000
else:
    print("이 함수는 클로저가 아니거나 자유 변수를 캡처하지 않습니다.")

print(f"월급 100000에 대한 연봉: {salary_func(100000):.2f}")
# 출력: 월급 100000에 대한 연봉: 109250.00
```

이러한 속성은 주로 디버깅이나 이해를 돕기 위한 것이며, 클로저의 값을 직접 변경하는 것은 권장되지 않습니다. 대신 변경이 필요하면 새로운 클로저를 생성하는 것이 좋습니다.