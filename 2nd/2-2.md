## 2.2 불변 데이터와 효율적인 처리

함수형 프로그래밍(Functional Programming, FP)의 또 다른 핵심 원칙은 **데이터의 불변성(Immutability)**입니다. 불변성은 한번 생성된 데이터는 그 이후로 절대로 변경될 수 없음을 의미합니다. 대신, 데이터가 변경되어야 할 필요가 있을 때는 원본 데이터를 복사하여 새로운 데이터를 생성하고, 변경 사항은 이 새로운 복사본에 적용하는 방식입니다. 이러한 접근 방식은 프로그래밍에서 발생하는 많은 버그를 줄이고, 코드를 더 예측 가능하며 디버깅하기 쉽게 만듭니다.

파이썬은 다중 패러다임 언어이므로, 기본적으로 가변(Mutable) 데이터 타입과 불변(Immutable) 데이터 타입을 모두 제공합니다. 함수형 프로그래밍 스타일을 추구하려면 파이썬의 가변 데이터 타입을 불변적으로 다루는 방법을 이해하고 적용하는 것이 중요합니다.

### 파이썬의 불변 타입: 숫자, 문자열, 튜플, Frozen Set

파이썬에는 생성된 후에는 내용을 변경할 수 없는 **불변(Immutable)** 데이터 타입이 있습니다. 이러한 불변성은 함수형 프로그래밍의 핵심 개념과 자연스럽게 맞아떨어집니다.

주요 불변 타입은 다음과 같습니다:

- **숫자 (Numbers)**: 정수(int), 실수(float), 복소수(complex) 등은 모두 불변입니다.
    
    ```
    x = 10
    print(f"x의 초기 값: {x}") # 출력: x의 초기 값: 10
    x += 5 # x는 새로운 객체(15)를 참조하게 됩니다.
    print(f"x 변경 후 값: {x}") # 출력: x 변경 후 값: 15
    # 실제로는 10이라는 숫자 객체가 변경된 것이 아니라,
    # x가 15라는 새로운 숫자 객체를 가리키게 된 것입니다.
    ```
    
- **문자열 (Strings)**: 문자열은 불변 시퀀스 타입의 대표적인 예입니다. 한번 생성된 문자열은 특정 인덱스의 문자를 변경하거나, 문자열의 길이를 변경하는 것이 불가능합니다.
    
    ```
    s = "안녕하세요"
    print(f"s의 초기 값: {s}") # 출력: s의 초기 값: 안녕하세요
    
    # s[0] = '안' # TypeError: 'str' object does not support item assignment
    # 문자열은 직접 수정할 수 없습니다.
    
    # 문자열을 변경하려면 항상 새로운 문자열을 생성해야 합니다.
    new_s = s.replace("녕", "안녕")
    print(f"new_s: {new_s}") # 출력: new_s: 안안녕하세요
    print(f"원본 s: {s}")   # 출력: 원본 s: 안녕하세요 (원본은 변경되지 않음)
    ```
    
- **튜플 (Tuples)**: 튜플은 리스트와 유사하게 여러 요소를 담을 수 있는 시퀀스 타입이지만, 한번 생성되면 요소를 추가, 삭제, 변경할 수 없습니다.
    
    ```
    employee = ("김철수", 30, "개발자")
    print(f"employee 튜플: {employee}") # 출력: employee 튜플: ('김철수', 30, '개발자')
    
    # employee[1] = 31 # TypeError: 'tuple' object does not support item assignment
    # 튜플의 요소를 직접 수정할 수 없습니다.
    
    # 튜플을 변경하는 대신, 새 튜플을 생성해야 합니다.
    # 예를 들어, 나이를 업데이트하는 경우:
    new_employee = (employee[0], 31, employee[2]) # 새로운 튜플 생성
    print(f"새로운 employee 튜플: {new_employee}") # 출력: 새로운 employee 튜플: ('김철수', 31, '개발자')
    print(f"원본 employee 튜플: {employee}")   # 출력: 원본 employee 튜플: ('김철수', 30, '개발자')
    ```
    
    튜플은 불변이기 때문에 내부의 요소가 다른 가변 객체(예: 리스트)를 참조할 경우, 튜플 자체는 변경할 수 없지만, 튜플이 참조하는 가변 객체의 내용은 변경될 수 있습니다. 이것을 **"얕은 불변성(shallow immutability)"**이라고 합니다.
    
    ```
    mutable_list_in_tuple = [1, 2]
    immutable_data = (mutable_list_in_tuple, "immutable_string")
    print(f"튜플의 초기 값: {immutable_data}") # 출력: 튜플의 초기 값: ([1, 2], 'immutable_string')
    
    # 튜플 자체는 변경할 수 없지만, 튜플이 참조하는 내부 리스트는 변경 가능
    immutable_data[0].append(3) 
    print(f"튜플 내부 리스트 변경 후: {immutable_data}") # 출력: 튜플 내부 리스트 변경 후: ([1, 2, 3], 'immutable_string')
    # 튜플의 ID는 동일하지만, 내부 리스트의 내용은 변경되었습니다.
    print(f"튜플의 ID: {id(immutable_data)}") # 튜플의 ID
    print(f"튜플 내부 리스트의 ID: {id(immutable_data[0])}") # 튜플 내부 리스트의 ID
    ```
    
- **Frozen Set (불변 셋)**: 셋(Set)은 기본적으로 가변 타입이지만, `frozenset`은 셋의 불변 버전입니다. 해시 가능한(hashable) 요소를 담을 수 있으며, 생성 후에는 추가/삭제/변경이 불가능합니다.
    
    ```
    mutable_set = {1, 2, 3}
    immutable_set = frozenset({1, 2, 3})
    print(f"가변 셋: {mutable_set}")     # 출력: 가변 셋: {1, 2, 3}
    print(f"불변 셋 (frozenset): {immutable_set}") # 출력: 불변 셋 (frozenset): frozenset({1, 2, 3})
    
    mutable_set.add(4) # 가능
    print(f"가변 셋 변경 후: {mutable_set}") # 출력: 가변 셋 변경 후: {1, 2, 3, 4}
    
    # immutable_set.add(4) # AttributeError: 'frozenset' object has no attribute 'add'
    # frozenset은 변경할 수 없습니다.
    ```
    

**불변성의 이점**:

- **예측 가능성**: 데이터가 변경되지 않으므로, 코드를 읽고 추론하기가 훨씬 쉬워집니다. 특정 시점에 데이터의 상태를 알면, 그 이후로 해당 데이터가 변경될 걱정 없이 코드를 계속 추론할 수 있습니다.
    
- **디버깅 용이성**: 버그가 발생했을 때, 변수의 값이 예상치 않게 변경되었는지 여부를 걱정할 필요가 없으므로 문제를 추적하기가 더 쉬워집니다.
    
- **동시성 안전**: 여러 스레드나 프로세스에서 동일한 불변 데이터를 동시에 접근하더라도, 데이터를 변경할 수 없기 때문에 경쟁 조건(race condition)과 같은 동시성 관련 버그가 발생할 위험이 없습니다.
    
- **캐싱(Memoization) 효율**: 불변 데이터는 항상 동일한 해시 값을 가질 수 있으므로, 동일한 입력에 대해 동일한 출력을 보장하는 순수 함수(pure function)의 결과를 캐싱(memoization)하는 데 유리합니다.
    

### 가변 데이터(리스트, 딕셔너리, 셋)를 불변적으로 다루는 방법

파이썬의 `list`, `dict`, `set`와 같은 컬렉션 타입은 기본적으로 **가변(Mutable)**입니다. 즉, 생성된 후에 요소를 추가, 삭제, 변경할 수 있습니다. 객체 지향 프로그래밍에서는 이러한 내부 상태 변경이 자연스럽지만, 함수형 프로그래밍에서는 불변성을 지향합니다.

가변 데이터를 불변적으로 다루는 핵심 원칙은 **"원본을 수정하지 않고, 항상 새로운 복사본을 반환한다"**입니다.

가변 데이터를 불변적으로 다루는 주요 기법은 다음과 같습니다:

1. **새로운 컬렉션 생성 (복사본)**: 가장 기본적인 방법은 `list()`, `dict()`, `set()` 생성자를 사용하거나, 슬라이싱(`[:]`)을 통해 **얕은 복사본**을 만드는 것입니다.
    
    ```
    original_list = [1, 2, 3]
    print(f"원본 리스트: {original_list}") # 출력: 원본 리스트: [1, 2, 3]
    
    # 1. list() 생성자를 사용하여 새로운 리스트 생성
    new_list_copy = list(original_list)
    new_list_copy.append(4)
    print(f"list()로 생성된 새 리스트: {new_list_copy}") # 출력: list()로 생성된 새 리스트: [1, 2, 3, 4]
    print(f"원본 리스트 ( unchanged): {original_list}") # 출력: 원본 리스트 ( unchanged): [1, 2, 3]
    
    # 2. 슬라이싱 ([:])을 사용하여 새로운 리스트 생성
    new_list_slice = original_list[:]
    new_list_slice.append(5)
    print(f"슬라이싱으로 생성된 새 리스트: {new_list_slice}") # 출력: 슬라이싱으로 생성된 새 리스트: [1, 2, 3, 5]
    print(f"원본 리스트 (unchanged): {original_list}") # 출력: 원본 리스트 (unchanged): [1, 2, 3]
    
    # 딕셔너리와 셋도 유사하게 복사할 수 있습니다.
    original_dict = {'a': 1, 'b': 2}
    new_dict_copy = dict(original_dict)
    new_dict_copy['c'] = 3
    print(f"새 딕셔너리: {new_dict_copy}") # 출력: 새 딕셔너리: {'a': 1, 'b': 2, 'c': 3}
    print(f"원본 딕셔너리: {original_dict}") # 출력: 원본 딕셔너리: {'a': 1, 'b': 2}
    
    original_set = {1, 2, 3}
    new_set_copy = set(original_set)
    new_set_copy.add(4)
    print(f"새 셋: {new_set_copy}") # 출력: 새 셋: {1, 2, 3, 4}
    print(f"원본 셋: {original_set}") # 출력: 원본 셋: {1, 2, 3}
    ```
    
    **주의**: 이러한 복사본은 **얕은 복사(shallow copy)**이므로, 원본 컬렉션 안에 다른 가변 객체가 중첩되어 있을 경우, 해당 내부 객체는 여전히 원본과 공유됩니다. 즉, 내부 객체를 변경하면 원본과 복사본 모두에 영향을 미칩니다. 완전한 불변성을 위해서는 **깊은 복사(deep copy)**를 사용하거나, 중첩된 객체 또한 불변적으로 다뤄야 합니다.
    
    **예시: 얕은 복사와 깊은 복사**
    
    ```
    import copy
    
    original_nested_list = [1, [2, 3], 4]
    print(f"원본 중첩 리스트: {original_nested_list}, ID: {id(original_nested_list)}")
    print(f"원본 중첩 리스트 내부 리스트 ID: {id(original_nested_list[1])}")
    
    # 얕은 복사 (shallow copy)
    shallow_copied_list = list(original_nested_list)
    print(f"\n얕은 복사된 리스트: {shallow_copied_list}, ID: {id(shallow_copied_list)}")
    print(f"얕은 복사된 리스트 내부 리스트 ID: {id(shallow_copied_list[1])}")
    
    # 얕은 복사본의 내부 리스트를 변경하면 원본도 변경됨
    shallow_copied_list[1].append(5)
    print(f"얕은 복사 후 내부 리스트 변경: {original_nested_list}") # 원본도 변경됨!
    print(f"얕은 복사된 리스트 변경 후: {shallow_copied_list}")
    
    # 깊은 복사 (deep copy)
    original_nested_list_for_deep = [1, [2, 3], 4]
    deep_copied_list = copy.deepcopy(original_nested_list_for_deep)
    print(f"\n깊은 복사된 리스트: {deep_copied_list}, ID: {id(deep_copied_list)}")
    print(f"깊은 복사된 리스트 내부 리스트 ID: {id(deep_copied_list[1])}")
    
    # 깊은 복사본의 내부 리스트를 변경해도 원본은 변경되지 않음
    deep_copied_list[1].append(5)
    print(f"깊은 복사 후 내부 리스트 변경: {original_nested_list_for_deep}") # 원본은 변경되지 않음!
    print(f"깊은 복사된 리스트 변경 후: {deep_copied_list}")
    ```
    
2. **컬렉션 컴프리헨션 (Comprehensions)**: 리스트 컴프리헨션(list comprehension), 딕셔너리 컴프리헨션(dictionary comprehension), 셋 컴프리헨션(set comprehension)은 기존 이터러블을 기반으로 새로운 컬렉션을 생성하는 강력하고 간결한 문법입니다. 특히 기존 요소에 변형을 가하거나 조건을 적용하여 필터링할 때 유용하며, 항상 새로운 컬렉션을 반환하여 불변성을 유지합니다.
    
    ```
    numbers = [1, 2, 3, 4, 5]
    
    # 리스트 컴프리헨션: 각 숫자의 제곱으로 구성된 새 리스트 생성
    squares = [x ** 2 for x in numbers]
    print(f"제곱 리스트: {squares}") # 출력: 제곱 리스트: [1, 4, 9, 16, 25]
    
    # 리스트 컴프리헨션: 짝수만 필터링하여 새 리스트 생성
    even_numbers = [x for x in numbers if x % 2 == 0]
    print(f"짝수 리스트: {even_numbers}") # 출력: 짝수 리스트: [2, 4]
    
    # 딕셔너리 컴프리헨션: 키와 값의 관계를 변형하여 새 딕셔너리 생성
    price_data = {'apple': 1000, 'banana': 500, 'cherry': 2000}
    discounted_prices = {item: price * 0.9 for item, price in price_data.items()}
    print(f"할인된 가격 딕셔너리: {discounted_prices}") # 출력: 할인된 가격 딕셔너리: {'apple': 900.0, 'banana': 450.0, 'cherry': 1800.0}
    
    # 셋 컴프리헨션: 유니크한 값만 포함하는 새 셋 생성
    text_data = ["hello", "world", "hello", "python"]
    unique_lengths = {len(word) for word in text_data}
    print(f"단어 길이 셋: {unique_lengths}") # 출력: 단어 길이 셋: {5, 9, 6}
    ```
    
3. **`map()`, `filter()`와 같은 고차 함수 (Higher-Order Functions)**: `map()`과 `filter()` 같은 내장 고차 함수는 함수형 프로그래밍에서 가변 데이터를 불변적으로 다루는 데 자주 사용됩니다. 이들은 인자로 함수와 이터러블을 받아, 원본 데이터를 변경하지 않고 새로운 이터레이터(iterator)를 반환합니다. 이 이터레이터를 `list()`, `tuple()` 등으로 감싸면 새로운 컬렉션을 얻을 수 있습니다.
    
    ````
    scores = [30, 25, 40, 19]
    max_score = 50
    
    # map(): 각 점수를 등급으로 변환 (새로운 이터레이터 반환)
    # lambda score: score / max_score * 5 + 1은 등급 계산을 위한 익명 함수
    grades_iterator = map(lambda score: score / max_score * 5 + 1, scores)
    grades = list(grades_iterator) # 리스트로 변환하여 실제 값 확인
    print(f"변환된 등급 리스트: {grades}") # 출력: 변환된 등급 리스트: [4.0, 3.5, 5.0, 2.9]
    
    # filter(): 특정 조건(예: 40점 이상)을 만족하는 점수만 필터링 (새로운 이터레이터 반환)
    passing_scores_iterator = filter(lambda score: score >= 40, scores)
    passing_scores = list(passing_scores_iterator)
    print(f"합격 점수 리스트: {passing_scores}") # 출력: 합격 점수 리스트: [40]
    ```map()`과 `filter()`는 **게으른 평가(lazy evaluation)**를 사용합니다. 즉, 결과가 실제로 필요할 때까지 계산을 지연합니다. 이는 특히 대용량 데이터나 무한 시퀀스를 다룰 때 메모리 및 성능 효율성을 높이는 데 기여합니다.
    
    
    ````
    

불변성을 유지하는 방식은 코드를 더 안전하고 이해하기 쉽게 만들지만, 모든 변경에 대해 새로운 복사본을 만드는 방식은 특히 대용량 컬렉션에서 성능 및 메모리 오버헤드를 유발할 수 있습니다. 이러한 한계를 보완하기 위해 **구조적 공유(Structural Sharing)** 개념이 등장합니다.

### 구조적 공유(Structural Sharing) 개념 소개 (외부 정보)

가변 데이터를 불변적으로 다룰 때 발생하는 주요 효율성 문제는 다음과 같습니다. 예를 들어, 요소가 100만 개 있는 리스트에서 단 하나의 요소를 변경하려 할 때, 파이썬의 `list()` 또는 슬라이싱(`[:]`)을 사용하면 100만 개의 요소를 모두 복사하여 새 리스트를 생성해야 합니다. 이는 상당한 시간과 메모리 자원을 소모할 수 있습니다.

이러한 문제를 해결하기 위해 함수형 프로그래밍 언어 및 라이브러리에서 사용하는 고급 기법이 바로 **구조적 공유(Structural Sharing)**입니다. 이는 **영속적 데이터 구조(Persistent Data Structures)**의 핵심 개념 중 하나입니다.

**개념 설명 (외부 정보):** 구조적 공유는 "변경되지 않은 부분은 공유하고, 변경된 부분만 새로 생성한다"는 아이디어에 기반합니다. 이를 통해 새로운 버전의 데이터를 만들 때, 원본 데이터 구조의 일부를 재사용하여 메모리 사용량을 최적화하고 복사 오버헤드를 줄일 수 있습니다.

예를 들어, 리스트와 같은 선형 데이터 구조를 **트리(Tree)** 형태로 표현하는 것을 상상해 보세요.

- 일반적인 리스트에서 `[H1, H2, H3]`가 있을 때, `H3`를 `H4`로 변경하려면 일반적으로 `[H1, H2, H4]`라는 완전히 새로운 리스트를 생성해야 합니다.
    
- 하지만 이 리스트를 트리 구조로 표현한다면, 각 요소가 트리의 리프 노드(leaf node)가 되고, 중간 노드들이 이들을 연결한다고 가정할 수 있습니다.
    
- 이 상황에서 `H3`를 `H4`로 변경하고 싶다면, `H4`라는 새로운 리프 노드를 생성하고, `H1`과 `H2`를 가리키는 기존 노드들은 그대로 재사용합니다. 그리고 이 재사용된 노드들과 새로운 `H4` 노드를 연결하는 새로운 중간 노드들만 생성하여 새로운 버전의 트리를 만듭니다. 이렇게 하면 `H1`과 `H2`는 메모리상에서 단 한 번만 존재하며, 여러 버전의 데이터 구조에서 공유될 수 있습니다.
    

아래는 개념적인 이해를 돕기 위한 예시입니다. (실제 파이썬의 리스트나 딕셔너리는 이러한 구조적 공유를 기본적으로 제공하지 않습니다. 이 부분은 파이썬 외부의 정보임을 명확히 합니다.)

**구조적 공유의 특징 (외부 정보):**

- **부분적인 복사**: 변경이 필요한 부분만 새로 생성하고, 변경되지 않은 부분은 원본 데이터 구조와 메모리를 공유합니다.
    
- **효율성**: 대규모 데이터 구조에서 작은 변경이 자주 발생하는 경우, 전체를 복사하는 것보다 훨씬 효율적입니다. 메모리 사용량과 변경 작업의 성능이 향상됩니다.
    
- **복잡성**: 이러한 데이터 구조를 직접 구현하는 것은 복잡하며, 일반적인 프로그래밍 언어에서는 기본적으로 제공되지 않는 경우가 많습니다.
    

**파이썬에서의 구조적 공유 (외부 정보):** 파이썬의 내장 `list`, `dict`, `set` 타입은 기본적으로 구조적 공유를 지원하지 않습니다. 따라서 `list()`, `[:]`, 컴프리헨션 등을 통한 불변성 구현은 내부적으로는 전체 또는 상당 부분의 복사를 수반하게 됩니다.

그러나 다른 언어(예: Clojure, Haskell)에서는 이러한 영속적 데이터 구조를 기본으로 제공하며, JavaScript 생태계에서는 Immutable.js나 Mori와 같은 라이브러리가 이러한 개념을 구현하여 활용됩니다. 파이썬에서도 `pyrsistent`나 `immutables`와 같은 서드파티 라이브러리를 통해 이러한 영속적 데이터 구조를 사용할 수 있습니다. 이들 라이브러리는 내부적으로 구조적 공유를 구현하여 불변성을 유지하면서도 효율적인 데이터 조작을 가능하게 합니다.

**결론적으로**, 파이썬에서 함수형 프로그래밍을 할 때는 불변 타입의 장점을 최대한 활용하고, 가변 타입을 다룰 때는 항상 새로운 복사본을 만들어 원본을 변경하지 않는 원칙을 고수해야 합니다. 비록 파이썬의 내장 타입이 구조적 공유를 효율적으로 지원하지 않아 대규모 데이터 처리에서 성능 병목이 발생할 수 있지만, 이러한 원칙을 지키는 것만으로도 코드의 안정성과 가독성을 크게 향상시킬 수 있습니다. 필요에 따라서는 외부 라이브러리를 고려하여 성능 최적화를 꾀할 수 있습니다.