파이썬으로 쉽게 풀어쓴 함수형 프로그래밍

### 4.2 커링(Currying)

**커링(Currying)**은 **함수형 프로그래밍(Functional Programming)**의 핵심 개념 중 하나로, 여러 인자를 받는 함수를 **단일 인자를 받는 함수들의 연속**으로 변환하는 특별한 **함수 변환(Function Transformation)** 기법입니다. 이 기법은 수학자 **하스켈 커리(Haskell Curry)**의 이름을 따서 명명되었으며, 순수 함수형 언어인 **하스켈(Haskell)**에서는 모든 함수가 기본적으로 **커리(curried)**되어 있습니다.

예를 들어, `f(a, b, c)`와 같이 세 개의 인자를 동시에 받는 함수가 있다고 가정해 봅시다. 이 함수를 **커링**하면 `f(a)(b)(c)`와 같이 첫 번째 인자 `a`를 받아서 두 번째 인자 `b`를 받을 새로운 함수를 반환하고, 이 함수가 다시 세 번째 인자 `c`를 받을 함수를 반환하며, 마지막으로 모든 인자를 사용하여 최종 결과를 계산하는 방식으로 작동합니다. 즉, 각 인자가 순차적인 단계에서 점진적으로 적용되는 일련의 함수를 생성하는 것입니다.

**부분 함수 적용(Partial Function Application)과의 차이점**

**커링**과 종종 혼동되는 개념이 바로 **부분 함수 적용(Partial Function Application)**입니다. 두 가지 모두 기존 함수로부터 새로운 함수를 생성하지만, 작동 방식에 중요한 차이가 있습니다.

- **부분 함수 적용**: 함수의 전체 인자 중 일부를 미리 채워 넣고, 나머지 인자를 나중에 받을 새로운 함수를 만드는 것을 의미합니다. Python의 `functools` 모듈에 있는 `partial()` 함수가 이 역할을 합니다. `f(a, b, c, x)`라는 함수가 있을 때, `partial(f, 2, 4, 6)`와 같이 `a, b, c`에 해당하는 인자를 미리 지정하고, `x`를 나중에 받는 `g(x)`라는 함수를 만드는 것이 부분 함수 적용입니다. 이때, 인자들은 원래 함수의 인자 순서에 따라 채워져야 합니다.
    
- **커링**: 다중 인자 함수를 **항상 단일 인자를 받는 함수들의 연속**으로 변환합니다. 즉, `f(a, b)`라는 함수는 `f_curried(a)(b)`와 같이 변환되며, `f_curried(a)`는 단일 인자 `a`를 받은 후 `b`를 기다리는 새로운 함수를 반환합니다. 모든 인자는 이처럼 단일 인자를 받는 함수를 통해 순차적으로 전달됩니다. Python의 `functools.partial`은 **커링**의 기능을 일부 수행할 수 있지만, 진정한 의미에서 모든 다중 인자 함수를 단일 인자 함수들의 연속으로 만드는 **커링**은 아닙니다.
    

다음은 `functools.partial`을 사용한 **부분 함수 적용**의 예시입니다.

```
# 일반적인 다중 인자 함수: ax^2 + bx + c를 계산
def quadratic_equation(a, b, c, x):
    return a * x**2 + b * x + c

from functools import partial

# a, b, c 인자를 미리 채워 새로운 함수 f를 생성 (부분 함수 적용)
# f는 이제 x 인자만 받습니다.
f = partial(quadratic_equation, 1, 2, 3) # a=1, b=2, c=3으로 고정
print(f"f(0): {f(0)}") # x=0, 결과: 1*0^2 + 2*0 + 3 = 3
print(f"f(1): {f(1)}") # x=1, 결과: 1*1^2 + 2*1 + 3 = 6
print(f"f(2): {f(2)}") # x=2, 결과: 1*2^2 + 2*2 + 3 = 11

# 다른 계수로 g 함수 생성
g = partial(quadratic_equation, 2, 0, 1) # a=2, b=0, c=1으로 고정
print(g"g(0): {g(0)}") # x=0, 결과: 2*0^2 + 0*0 + 1 = 1
print(g"g(1): {g(1)}") # x=1, 결과: 2*1^2 + 0*1 + 1 = 3
```

이처럼 `partial`은 기존 함수의 일부 인자를 고정하여 더 적은 인자를 받는 새로운 함수를 생성하는 데 초점을 맞춥니다.

#### 파이썬에서의 커링 구현

Python은 기본적으로 **커링(Currying)**을 직접 지원하지는 않습니다. 하지만 **클로저(Closure)**와 **데코레이터(Decorator)**를 활용하여 **커리된 함수(Curried Function)**와 유사한 동작을 구현할 수 있습니다.

1. **클로저를 이용한 수동 커링 구현**
    
    **클로저**는 중첩된 함수에서 바깥 함수의 스코프에 있는 변수를 참조하는 내부 함수를 의미하며, 바깥 함수가 실행을 마친 후에도 이 변수들을 "기억"하는 특징을 가집니다. 이 특성을 활용하면 각 인자를 순차적으로 받는 함수들을 정의하고, 이들이 이전 인자의 상태를 유지하도록 만들 수 있습니다.
    
    예를 들어, 세 개의 인자를 받는 `add_three_numbers(a, b, c)` 함수를 **커리드 스타일**로 변환하는 과정을 살펴보겠습니다.
    
    - 가장 바깥 함수는 첫 번째 인자 `a`를 받습니다.
    - 이 함수는 두 번째 인자 `b`를 받을 새로운 내부 함수를 반환합니다.
    - 이 두 번째 함수는 세 번째 인자 `c`를 받을 또 다른 내부 함수를 반환합니다.
    - 마지막 내부 함수는 모든 인자 `a, b, c`를 사용하여 최종 연산을 수행하고 결과를 반환합니다.
    
    ```
    def add_three_numbers_curried(a):
        """
        세 숫자를 더하는 함수를 커리드 스타일로 구현.
        첫 번째 인자 'a'를 받고, 두 번째 인자를 받을 함수를 반환합니다.
        """
        def add_b(b):
            """
            두 번째 인자 'b'를 받고, 세 번째 인자를 받을 함수를 반환합니다.
            """
            def add_c(c):
                """
                세 번째 인자 'c'를 받고, 세 숫자의 합을 반환합니다.
                바깥 함수의 스코프에 있는 'a'와 'b'를 참조합니다 (클로저).
                """
                return a + b + c # 클로저를 통해 바깥 스코프의 a와 b에 접근
            return add_c
        return add_b
    
    # 커리드 함수 사용 예시: 각 인자를 순차적으로 전달하며 함수를 호출
    result = add_three_numbers_curried(1)(2)(3)
    print(f"커리드 함수 호출 결과: {result}") # 출력: 커리드 함수 호출 결과: 6
    
    # 중간 단계의 함수를 변수에 저장하여 재사용할 수 있습니다.
    add_1 = add_three_numbers_curried(1) # a=1을 고정한 함수
    add_1_and_2 = add_1(2) # a=1, b=2를 고정한 함수
    final_result = add_1_and_2(3) # c=3을 전달하여 최종 결과 계산
    print(f"중간 함수를 사용한 결과: {final_result}") # 출력: 중간 함수를 사용한 결과: 6
    
    # 특정 인자(여기서는 첫 번째 인자)를 고정하여 여러 곳에서 재사용
    add_to_five = add_three_numbers_curried(5)
    print(f"5 + 1 + 2 = {add_to_five(1)(2)}") # 출력: 5 + 1 + 2 = 8
    print(f"5 + 3 + 4 = {add_to_five(3)(4)}") # 출력: 5 + 3 + 4 = 12
    ```
    
    이처럼 수동으로 **커링**된 함수를 작성하는 것은 함수의 인자 개수가 많아질수록 코드가 길고 복잡해지며 가독성이 떨어질 수 있습니다.
    
2. **`PyMonad` 라이브러리를 이용한 커링 구현**
    
    Python의 표준 라이브러리는 직접적인 **커링** 기능을 제공하지 않지만, `PyMonad`와 같은 서드파티 라이브러리를 통해 이 기능을 활용할 수 있습니다. `PyMonad`는 함수형 프로그래밍 기법을 Python에서 사용할 수 있도록 돕는 라이브러리로, 특히 `@curry` 데코레이터를 제공하여 함수를 쉽게 **커리드 스타일**로 변환할 수 있게 합니다.
    
    `PyMonad`를 설치하려면 다음 명령어를 사용합니다: `pip install --user PyMonad==2.4.0`
    
    이제 `PyMonad`의 `@curry` 데코레이터를 사용하여 이전 `quadratic_equation` 함수를 **커리드 함수**로 변환하는 예시를 살펴보겠습니다:
    
    ```
    from pymonad.tools import curry
    
    # @curry(4) 데코레이터는 이 함수가 4개의 인자를 받아 커리될 것임을 나타냅니다.
    @curry(4)
    def quadratic_equation_curried(a, b, c, x):
        """
        ax^2 + bx + c를 계산하는 이차 방정식 함수 (커리드 버전)
        """
        return a * x**2 + b * x + c
    
    # 커리드 함수 호출 예시: 각 인자를 순차적으로 전달
    # 각 호출은 다음 인자를 받는 새로운 함수를 반환합니다.
    result1 = quadratic_equation_curried(1)(2)(3)(0) # a=1, b=2, c=3, x=0
    print(f"커리드 호출 결과 1 (1*0^2 + 2*0 + 3): {result1}") # 출력: 3
    
    result2 = quadratic_equation_curried(2)(0)(1)(1) # a=2, b=0, c=1, x=1
    print(f"커리드 호출 결과 2 (2*1^2 + 0*1 + 1): {result2}") # 출력: 3
    
    # 중간 단계의 커리드 함수를 변수에 저장하여 재사용할 수 있습니다.
    # partial 함수와 유사하게, 일부 인자를 묶어서 전달할 수도 있습니다.
    f_curried = quadratic_equation_curried(1, 2, 3) # a=1, b=2, c=3을 고정한 함수
    print(f"부분 인자 전달 후 호출 1 (x=0): {f_curried(0)}") # 출력: 3
    print(f"부분 인자 전달 후 호출 2 (x=1): {f_curried(1)}") # 출력: 6
    print(f"부분 인자 전달 후 호출 3 (x=2): {f_curried(2)}") # 출력: 11
    
    # 또는 인자를 하나씩 순차적으로 전달하여 중간 함수를 생성할 수도 있습니다.
    g_step1 = quadratic_equation_curried(2) # a=2를 고정
    g_step2 = g_step1(0)                  # b=0을 고정
    g_step3 = g_step2(1)                  # c=1을 고정
    print(f"단계별 커리드 호출 1 (x=0): {g_step3(0)}") # 출력: 1
    print(f"단계별 커리드 호출 2 (x=1): {g_step3(1)}") # 출력: 3
    ```
    
    `PyMonad`의 `@curry` 데코레이터를 사용하면 개발자가 중첩된 함수를 일일이 작성할 필요 없이, 데코레이터 하나만으로 함수를 **커리드 형태**로 만들 수 있어 코드가 훨씬 간결해집니다. 그러나 **커리된 함수**는 자동으로 백그라운드에서 많은 함수들을 생성하므로, 명시적으로 `partial`을 사용하는 것보다 덜 명확할 수 있습니다. 따라서 함수의 이름, 문서 또는 모듈 내의 규칙을 통해 함수가 **커리드**된 것임을 사용자에게 명확히 알려주는 것이 중요합니다.
    

#### 커링의 실용적 활용

**커링(Currying)**은 단순히 코드를 짧게 만드는 기술이 아니라, **함수형 프로그래밍**에서 강력한 **설계 도구**로 활용될 수 있습니다. 특히 다음과 같은 상황에서 유용하게 사용됩니다.

1. **함수 시그니처 일치(Function Signature Conformance) 및 재사용성:**
    
    - **고차 함수(Higher-order function)**는 다른 함수를 인자로 받거나 함수를 반환하는 함수를 의미하며, `map()`, `filter()`, `reduce()`와 같은 내장 고차 함수는 특정 형식의 함수(예: 단일 인자를 받는 함수)를 기대할 때가 많습니다.
    - 이때, 다중 인자 함수를 **커링**하여 필요한 **함수 시그니처**에 맞출 수 있습니다. 예를 들어, `map()` 함수는 단일 인자를 받는 함수를 기대하는데, `power(base, exponent)`와 같은 두 인자를 받는 함수가 있다면, 이를 **커링**하여 `map(power(2), numbers)`처럼 사용할 수 있습니다. `power(2)`는 `base=2`로 고정된, 단일 인자(`exponent`)를 받는 **커리드 함수**를 반환하여 `map()`이 요구하는 시그니처에 맞춰줍니다. 이는 특정 인자를 고정하여 범용 함수를 재사용 가능한 특정 함수로 **특수화(Specialization)**하는 데 기여합니다.
    
    ```
    from pymonad.tools import curry
    
    @curry(2)
    def power(base, exponent):
        """base의 exponent 제곱을 계산합니다."""
        return base ** exponent
    
    numbers =
    
    # map()은 단일 인자 함수를 기대합니다.
    # power(2)는 base=2로 고정된, 단일 인자(exponent)를 받는 커리드 함수를 반환합니다.
    squared_numbers = list(map(power(2), numbers)) # power(2)(x) -> 2^x
    print(f"2의 제곱근 (2^1, 2^2, ...): {squared_numbers}")
    # 출력: 2의 제곱근 (2^1, 2^2, ...):
    
    # 3의 제곱근을 계산하는 새로운 함수 생성
    cubed_numbers = list(map(power(3), numbers)) # power(3)(x) -> 3^x
    print(f"3의 제곱근 (3^1, 3^2, ...): {cubed_numbers}")
    # 출력: 3의 제곱근 (3^1, 3^2, ...):
    
    # 이처럼 커링을 통해 기존의 다중 인자 함수를
    # 고차 함수가 요구하는 단일 인자 함수 형태로 쉽게 변환할 수 있습니다.
    ```
    
2. **함수 조합(Function Composition) 용이성:**
    
    - **함수 조합**은 여러 함수를 연결하여 하나의 새로운 함수를 만드는 것을 의미합니다. 예를 들어, `f(g(x))`는 `x`에 `g` 함수를 먼저 적용하고, 그 결과를 `f` 함수에 적용하는 것을 뜻합니다.
    - **커링**된 함수는 각 인자를 독립적인 단계로 분리하므로, 이러한 함수 조합을 더욱 자연스럽고 유연하게 만듭니다. 모든 중간 함수가 단일 인자를 받기 때문에, 복잡한 데이터 파이프라인을 구축할 때 각 단계를 명확하게 정의하고 조합하기 편리합니다.
    
    ```
    from functools import reduce
    from pymonad.tools import curry
    
    # 함수 조합을 위한 고차 함수
    def compose(*fns):
        """주어진 함수들을 오른쪽에서 왼쪽으로 순서대로 조합합니다. (f(g(h(x))) 형태)"""
        def compose_pair(f, g):
            return lambda x: f(g(x)) # 두 함수를 조합하여 새로운 함수 반환
        # 함수 목록을 compose_pair 함수로 reduce (빈 목록 처리: identity 함수 반환)
        return reduce(compose_pair, fns, lambda x: x)
    
    # 커리드 함수 (PyMonad 사용 예시)
    @curry(2)
    def add(x, y):
        return x + y
    
    @curry(2)
    def multiply(x, y):
        return x * y
    
    # 특정 인자를 고정하여 단일 인자 함수처럼 사용할 수 있습니다.
    def increment(x):
        return add(1)(x) # 커리된 add 함수를 사용하여 x에 1을 더하는 함수 생성
    
    def twice(x):
        return multiply(2)(x) # 커리된 multiply 함수를 사용하여 x에 2를 곱하는 함수 생성
    
    # increment와 twice 함수를 조합 (increment 먼저 적용, 그 다음 twice 적용)
    # compose(twice, increment)는 (twice(increment(x)))를 의미
    process_value = compose(twice, increment)
    
    print(f"조합 함수 호출 (x=3): {process_value(3)}")
    # 과정: increment(3) -> 4, twice(4) -> 8. 결과: 8
    
    # 여러 단계를 가진 복잡한 처리 파이프라인 구성
    @curry(2)
    def power_of(exponent, base): # 인자 순서를 바꿔 power(base, exponent)와 호환되도록 curried
        return base ** exponent
    
    def add_one(x): return x + 1
    def times_two(x): return x * 2
    def cubed(x): return power_of(3)(x) # x^3
    def subtract_one(x): return x - 1
    
    # 목표: f(x) = (((x + 1) * 2)^3) - 1
    complex_transformation = compose(subtract_one, cubed, times_two, add_one)
    print(f"복잡한 조합 함수 호출 (x=1): {complex_transformation(1)}")
    # 과정: add_one(1)=2, times_two(2)=4, cubed(4)=64, subtract_one(64)=63. 결과: 63
    ```
    
3. **코드의 선언성(Declarative) 증대 및 디버깅 용이성 (간접적 효과):**
    
    - **커링** 자체는 직접적으로 코드를 선언적으로 만드는 것은 아니지만, **커리드 함수**와 **함수 조합**을 함께 사용하면 코드의 흐름을 **데이터 변환 파이프라인**으로 명확하게 표현할 수 있습니다. 이는 "무엇을 할 것인가(What)"에 집중하고 "어떻게 할 것인가(How)"에 대한 구현 세부 사항을 숨기므로, **선언적 프로그래밍 스타일**을 장려합니다.
    - 각 함수가 단일 책임을 가지고 작은 단위로 분리되어 있기 때문에, 문제가 발생했을 때 특정 함수의 입출력을 확인하여 버그의 원인을 빠르게 격리하고 디버깅하는 데 용이합니다.
4. **불변성(Immutability)과의 시너지 (간접적 효과):**
    
    - **함수형 프로그래밍**은 **불변 데이터(Immutable Data)**를 선호합니다. 데이터가 한번 생성되면 변경되지 않고, 모든 "변환"은 새로운 데이터 사본을 생성합니다.
    - **커리드 함수**는 인자를 순차적으로 받아 새로운 함수를 반환하는 과정에서 중간 상태를 변경하지 않으므로, 이러한 불변성의 원칙과 잘 어울립니다. 이는 **부수 효과(Side Effect)**를 줄이고 예측 가능한 코드를 작성하는 데 도움이 됩니다.

---

**Python에서의 커링 사용 시 고려사항:**

Python은 **커링**에 대한 기본 지원이 부족하고, `PyMonad`와 같은 외부 라이브러리를 사용해야 한다는 점과 언어의 주류 패러다임이 아니라는 점에서 몇 가지 고려사항이 있습니다.

1. **가독성과 복잡성:**
    
    - Python에서 수동으로 **커링**을 구현할 경우, 중첩된 함수 구조로 인해 코드가 길고 복잡해질 수 있으며 가독성이 떨어질 수 있습니다.
    - `PyMonad`의 `@curry` 데코레이터를 사용하면 코드는 간결해지지만, Python 개발자에게 익숙하지 않은 패턴일 수 있어, 팀원 간의 합의와 충분한 문서화가 필요합니다.
2. **성능 (꼬리 호출 최적화 부재):**
    
    - **커링**은 내부적으로 여러 함수 호출을 연속적으로 발생시킵니다. **순수 함수형 언어**인 **하스켈(Haskell)**이나 **OCaml** 등은 **꼬리 호출 최적화(Tail Call Optimization, TCO)**를 지원하여 재귀 함수 호출 스택의 메모리 사용량을 효율적으로 관리합니다.
    - 하지만 Python은 **꼬리 호출 최적화**를 지원하지 않습니다. 따라서 깊게 중첩된 커리드 함수 호출은 스택 오버플로우를 발생시키거나, 일반적인 반복문(for/while loop)에 비해 성능이 저하될 수 있습니다. 특히 메모리나 성능에 민감한 작업에서는 이러한 점을 고려해야 합니다.
3. **Python의 다중 패러다임 특성:**
    
    - Python은 절차형, 객체 지향, 함수형 프로그래밍 등 여러 패러다임을 지원하는 **다중 패러다임(Multi-paradigm)** 언어입니다. 이는 개발자가 특정 문제에 가장 적합한 스타일을 선택할 수 있는 유연성을 제공하지만, 동시에 특정 패러다임을 '강제'하지는 않습니다.
    - 따라서 Python에서 **커링**을 포함한 **함수형 프로그래밍** 스타일을 적용할 때는, 해당 방식이 코드의 명확성, 유지보수성, 재사용성을 실질적으로 개선하는지 신중하게 판단해야 합니다. 때로는 간단한 반복문이나 명시적인 `partial` 사용이 더 명확하고 효율적인 해결책이 될 수 있습니다.

결론적으로, Python에서 **커링**은 복잡한 함수 조합, 특정 시그니처 일치, 또는 유연한 함수 생성이 필요할 때 강력한 도구가 될 수 있습니다. 그러나 Python의 언어적 특성과 주류 관행을 고려하여, 코드의 가독성 및 성능 영향에 대한 충분한 이해와 함께 신중하게 적용하는 것이 중요합니다. **함수형 프로그래밍**의 핵심 원칙을 이해하고 이를 Python의 강점과 결합하는 것이 효과적인 개발로 이어질 것입니다.