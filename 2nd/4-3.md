## 4.3 데코레이터(Decorators)

파이썬에서 함수형 프로그래밍을 논할 때 **데코레이터(Decorators)**는 빼놓을 수 없는 중요한 개념입니다. 데코레이터는 파이썬에서 **고차 함수(Higher-Order Functions)**를 더욱 **간결하고 가독성 좋게** 사용할 수 있도록 돕는 **문법적 설탕(Syntactic Sugar)**에 해당합니다. 이는 단순히 코드를 짧게 만드는 것을 넘어, 코드의 **모듈성**과 **재사용성**을 크게 향상시키며, **관심사의 분리(Separation of Concerns)**를 효과적으로 구현할 수 있게 해줍니다.

### 고차 함수의 문법적 설탕(Syntactic Sugar)

함수형 프로그래밍에서 고차 함수는 다른 함수를 인자로 받거나 함수를 결과로 반환하는 함수를 의미합니다. 데코레이터는 이러한 고차 함수를 적용하는 특별한 방법이라고 할 수 있습니다.

예를 들어, 특정 함수가 실행되기 전후에 추가적인 로직(예: 로깅, 시간 측정)을 적용하고 싶다고 가정해 봅시다. 고차 함수를 직접 사용하여 이를 구현하면 다음과 같을 것입니다.

```
# 일반적인 함수
def greet(name):
    return f"안녕하세요, {name}님!"

# 함수를 '장식'하는 고차 함수 (데코레이터의 원형)
def logger_decorator(func):
    def wrapper(*args, **kwargs): # *args와 **kwargs는 뒤에서 자세히 설명합니다.
        print(f"함수 '{func.__name__}'이(가) 호출되었습니다.")
        result = func(*args, **kwargs)
        print(f"함수 '{func.__name__}'이(가) 실행을 완료했습니다.")
        return result
    return wrapper

# greet 함수를 logger_decorator로 장식
decorated_greet = logger_decorator(greet)

# 장식된 함수 호출
print(decorated_greet("김철수"))
# 출력:
# 함수 'greet'이(가) 호출되었습니다.
# 함수 'greet'이(가) 실행을 완료했습니다.
# 안녕하세요, 김철수님!
```

이 코드를 실행하면 `greet` 함수가 호출되기 전과 후에 메시지가 출력되는 것을 볼 수 있습니다.

데코레이터 문법인 `@` 기호를 사용하면 위 과정을 훨씬 더 직관적이고 깔끔하게 표현할 수 있습니다. 다음 코드를 보시죠.

```
# 함수를 '장식'하는 고차 함수 (데코레이터)
def logger_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"함수 '{func.__name__}'이(가) 호출되었습니다.")
        result = func(*args, **kwargs)
        print(f"함수 '{func.__name__}'이(가) 실행을 완료했습니다.")
        return result
    return wrapper

@logger_decorator
def greet(name):
    """주어진 이름으로 인사말을 생성합니다."""
    return f"안녕하세요, {name}님!"

# 장식된 함수 호출
print(greet("이영희"))
# 출력:
# 함수 'greet'이(가) 호출되었습니다.
# 함수 'greet'이(가) 실행을 완료했습니다.
# 안녕하세요, 이영희님!
```

이 두 번째 예시는 첫 번째 예시와 **동일하게 작동**합니다. `@logger_decorator`라는 한 줄의 코드만으로 `greet` 함수는 `logger_decorator`에 의해 반환된 `wrapper` 함수로 대체됩니다. 즉, `greet = logger_decorator(greet)`와 같은 의미인 것이죠. 이러한 문법은 코드를 훨씬 더 **가독성 좋게** 만들고, 어떤 함수가 어떤 방식으로 **장식(decorate)**되었는지 명확하게 보여줍니다.

데코레이터는 주로 다음과 같은 경우에 사용하면 코드의 품질을 높일 수 있습니다:

- **코드 재사용성**: 여러 함수에 걸쳐 동일한 전처리/후처리 로직이 필요할 때, 데코레이터를 통해 중복 코드를 제거하고 재사용성을 높일 수 있습니다.
    
- **관심사 분리**: 함수의 핵심 비즈니스 로직과 부가적인 기능(로깅, 인증, 유효성 검사, 캐싱 등)을 분리하여 코드를 더 **모듈화**하고 관리하기 쉽게 만듭니다.
    
- **디버깅 및 테스트 용이성**: 장식된 함수가 어떤 추가적인 동작을 하는지 명확하게 알 수 있으며, 필요에 따라 데코레이터를 쉽게 추가하거나 제거하여 디버깅 및 테스트를 용이하게 할 수 있습니다.
    

### `*args`와 `**kwargs`를 사용한 유연한 함수 장식

데코레이터가 다양한 형태의 함수에 유연하게 적용되기 위해서는, 장식될 함수가 어떤 인자를 받을지 미리 알 수 없는 경우가 많습니다. 이때 **`*args`와 `**kwargs`** 문법이 매우 유용하게 사용됩니다.

- **`*args`**: 함수가 **가변적인 개수의 위치 인자(positional arguments)**를 받을 수 있도록 합니다. `*args`는 함수 호출 시 전달된 모든 위치 인자들을 튜플(tuple) 형태로 묶어서 함수 내부로 전달합니다.
    
- **`**kwargs`**: 함수가 **가변적인 개수의 키워드 인자(keyword arguments)**를 받을 수 있도록 합니다. `**kwargs`는 함수 호출 시 전달된 모든 키워드 인자들을 딕셔너리(dictionary) 형태로 묶어서 함수 내부로 전달합니다.
    

데코레이터의 `wrapper` 함수에서 `*args`와 `**kwargs`를 사용하면, 장식될 원본 함수가 어떤 인자(개수, 종류)를 가지든 상관없이 해당 인자들을 `wrapper` 함수가 받아 원본 함수로 **"통과(pass through)"**시킬 수 있습니다.

예시를 통해 자세히 살펴보겠습니다.

#### `*args`와 `**kwargs`의 기본 활용

먼저 `*args`와 `**kwargs`가 어떻게 작동하는지 간단한 예시로 알아봅니다.

```
def print_arguments(*args, **kwargs):
    print("\n--- 위치 인자 (args) ---")
    for i, arg in enumerate(args): # args는 튜플입니다.
        print(f"{i+1}. {arg}")

    print("\n--- 키워드 인자 (kwargs) ---")
    # kwargs는 딕셔너리입니다. 정렬된 출력을 위해 sorted(kwargs.items()) 사용
    for key, value in sorted(kwargs.items()):
        print(f"*{key}: {value}")

# 다양한 방식으로 함수 호출
print_arguments("사과", "바나나", "체리")
# 출력:
# --- 위치 인자 (args) ---
# 1. 사과
# 2. 바나나
# 3. 체리
# --- 키워드 인자 (kwargs) ---

print_arguments(name="앨리스", age=30, city="서울")
# 출력:
# --- 위치 인자 (args) ---
# --- 키워드 인자 (kwargs) ---
# *age: 30
# *city: 서울
# *name: 앨리스

print_arguments("첫째", "둘째", id=101, status="활성")
# 출력:
# --- 위치 인자 (args) ---
# 1. 첫째
# 2. 둘째
# --- 키워드 인자 (kwargs) ---
# *id: 101
# *status: 활성

print_arguments()
# 출력:
# --- 위치 인자 (args) ---
# --- 키워드 인자 (kwargs) ---
```

이 코드를 실행하면 `print_arguments` 함수가 어떤 인자로 호출되든 상관없이, `*args`가 위치 인자들을 튜플로, `**kwargs`가 키워드 인자들을 딕셔너리로 깔끔하게 수집하는 것을 볼 수 있습니다.

#### 데코레이터에 `*args`와 `**kwargs` 적용

이제 이 유연성을 데코레이터에 적용하여, 인자 개수나 종류에 상관없이 어떤 함수든 장식할 수 있는 데코레이터를 만들어보겠습니다.

다음은 함수 실행 시간을 측정하는 데코레이터입니다.

```
import time

def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        print(f"함수 '{func.__name__}' 실행 시작...")
        result = func(*args, **kwargs) # 원본 함수에 모든 인자를 전달
        end_time = time.time()
        print(f"함수 '{func.__name__}' 실행 완료. 소요 시간: {end_time - start_time:.4f}초")
        return result
    return wrapper

@timer_decorator
def calculate_sum(a, b):
    """두 숫자의 합을 계산합니다."""
    time.sleep(0.1) # 시간 측정을 위해 잠시 대기
    return a + b

@timer_decorator
def greet_person(name, greeting="안녕하세요"):
    """이름과 인사말로 사람에게 인사합니다."""
    time.sleep(0.05)
    return f"{greeting}, {name}님!"

@timer_decorator
def complex_computation(data_list, factor=1.0, verbose=False):
    """복잡한 계산을 수행합니다."""
    total = 0
    for item in data_list:
        total += item * factor
    time.sleep(0.2)
    if verbose:
        print("계산 결과 보고서 생성 중...")
    return total

# 다양한 인자를 가진 함수들을 호출하여 데코레이터의 유연성 확인
print(calculate_sum(10, 20))
# 출력:
# 함수 'calculate_sum' 실행 시작...
# 함수 'calculate_sum' 실행 완료. 소요 시간: 0.1...초
# 30

print(greet_person("김민수", greeting="안녕"))
# 출력:
# 함수 'greet_person' 실행 시작...
# 함수 'greet_person' 실행 완료. 소요 시간: 0.0...초
# 안녕, 김민수님!

print(greet_person(name="박지영")) # 키워드 인자 사용
# 출력:
# 함수 'greet_person' 실행 시작...
# 함수 'greet_person' 실행 완료. 소요 시간: 0.0...초
# 안녕하세요, 박지영님!

print(complex_computation([1, 2, 3, 4, 5], factor=2.5, verbose=True))
# 출력:
# 함수 'complex_computation' 실행 시작...
# 계산 결과 보고서 생성 중...
# 함수 'complex_computation' 실행 완료. 소요 시간: 0.2...초
# 37.5
```

이 예시에서 `timer_decorator`는 `calculate_sum`, `greet_person`, `complex_computation` 등 **서로 다른 인자 서명(signature)**을 가진 함수들을 모두 성공적으로 장식합니다. `wrapper` 함수 내의 `func(*args, **kwargs)` 라인이 핵심입니다. 이 구문은 `wrapper` 함수가 받은 **모든 위치 인자(`*args`)와 모든 키워드 인자(`**kwargs`)**를 마치 원래 `func`가 직접 호출된 것처럼 `func`로 그대로 전달해 줍니다. 이를 통해 데코레이터는 장식할 함수의 구체적인 인자 목록에 얽매이지 않고 **재사용 가능한 범용적인 기능**을 제공할 수 있게 됩니다.

### 데코레이터의 고급 활용 및 주의사항

#### 로깅 데코레이터 예시

`*args`와 `**kwargs`는 특히 **로깅(logging)**과 같은 부가 기능에 매우 유용합니다. 함수 호출 시 전달된 모든 인자들을 기록할 수 있기 때문이죠.

```
def log_function_call(func):
    def wrapper(*args, **kwargs):
        # 함수 이름과 인자들을 출력
        arg_strings = [repr(arg) for arg in args]
        kwarg_strings = [f"{key}={repr(value)}" for key, value in kwargs.items()]
        all_args_string = ", ".join(arg_strings + kwarg_strings)

        print(f"[LOG] '{func.__name__}' 함수가 다음 인자와 함께 호출됨: ({all_args_string})")

        result = func(*args, **kwargs)

        print(f"[LOG] '{func.__name__}' 함수가 반환값 '{repr(result)}'으로 완료됨.")
        return result
    return wrapper

@log_function_call
def divide(numerator, denominator):
    """두 숫자를 나눕니다."""
    if denominator == 0:
        raise ValueError("0으로 나눌 수 없습니다!")
    return numerator / denominator

@log_function_call
def process_data(data, strategy="default", debug_mode=False):
    """데이터를 처리합니다."""
    processed = [item * 2 for item in data]
    if debug_mode:
        print("디버그 모드 활성화됨.")
    return processed

# 함수 호출
print(divide(10, 2))
# 출력:
# [LOG] 'divide' 함수가 다음 인자와 함께 호출됨: (10, denominator=2)
# [LOG] 'divide' 함수가 반환값 '5.0'으로 완료됨.
# 5.0

try:
    print(divide(5, 0))
except ValueError as e:
    print(e)
# 출력:
# [LOG] 'divide' 함수가 다음 인자와 함께 호출됨: (5, denominator=0)
# 0으로 나눌 수 없습니다!

print(process_data([1, 2, 3], strategy="fast", debug_mode=True))
# 출력:
# [LOG] 'process_data' 함수가 다음 인자와 함께 호출됨: ([1, 2, 3], strategy='fast', debug_mode=True)
# 디버그 모드 활성화됨.
# [LOG] 'process_data' 함수가 반환값 '[2, 4, 6]'으로 완료됨.
# [2, 4, 6]
```

이 데코레이터는 호출된 함수의 이름과 함께 전달된 모든 인자들을 깔끔하게 로깅합니다. 에러가 발생하더라도 데코레이터는 이를 감지하고 에러 메시지를 출력할 수 있죠. 이는 함수가 어떻게 호출되고 어떤 결과를 반환하는지 추적하는 데 매우 강력한 도구입니다.

#### 캐싱/메모이제이션 데코레이터

파이썬 표준 라이브러리의 `functools` 모듈은 이미 유용한 데코레이터들을 제공합니다. 그중 하나인 `functools.lru_cache`는 **메모이제이션(Memoization)**을 구현하는 데코레이터입니다. 메모이제이션은 함수가 동일한 인자로 여러 번 호출될 때, 이전에 계산했던 결과를 저장해 두었다가 다시 계산하는 대신 저장된 결과를 즉시 반환하여 성능을 최적화하는 기법입니다.

````
from functools import lru_cache

@lru_cache(maxsize=None) # maxsize=None은 캐시 크기 제한 없음
def fibonacci(n):
    """피보나치 수열을 계산합니다 (캐싱 적용)."""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# 캐싱이 적용되기 전과 후의 호출 횟수를 비교하면 엄청난 차이를 알 수 있습니다.
# (이 예제는 calls 카운터를 추가하지 않았지만, 실제로는 호출 횟수가 극적으로 줄어듭니다.)
print(f"피보나치(10): {fibonacci(10)}")
# 출력: 피보나치(10): 55
print(f"피보나치(10): {fibonacci(10)}") # 캐시된 결과 반환
# 출력: 피보나치(10): 55
print(f"피보나치(20): {fibonacci(20)}")
# 출력: 피보나치(20): 6765
print(f"피보나치(30): {fibonacci(30)}")
# 출력: 피보보나치(30): 832040
```lru_cache` 데코레이터는 `fibonacci` 함수가 순수 함수(동일 입력에 동일 출력, 외부 상태 변경 없음)라는 전제하에 매우 효과적으로 작동합니다. 이처럼 데코레이터는 특정 함수에 **교차 절단 관심사(cross-cutting concerns)**를 적용하여 코드의 효율성과 가독성을 높이는 데 기여합니다.

#### 데코레이터와 순수성(Purity)

함수형 프로그래밍의 핵심 원칙 중 하나는 **순수 함수(Pure Functions)**의 사용입니다. 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하며, **어떤 부수 효과(Side Effects)도 발생시키지 않습니다**. 하지만 로깅, 시간 측정, 캐싱과 같은 기능을 수행하는 데코레이터들은 종종 **부수 효과**를 동반합니다 (예: 콘솔에 출력, 외부 캐시 상태 변경).

이는 데코레이터를 사용하지 말아야 한다는 의미가 아닙니다. 파이썬과 같은 다중 패러다임 언어에서는 모든 함수를 완벽하게 순수하게 유지하는 것이 **실용적이지 않거나 불가능할 때가 많습니다**. 대신, 부수 효과를 일으키는 코드를 **최대한 격리하고 제어 가능한 범위 내에 두는 것**이 중요합니다. 데코레이터는 이러한 부수 효과를 함수의 핵심 로직으로부터 분리하고, 명시적으로 `wrapper` 함수 내에 캡슐화함으로써, 코드의 **전반적인 이해도를 높이는 데 기여**할 수 있습니다. `functools.lru_cache`와 같은 데코레이터는 내부적으로 상태(캐시)를 관리하지만, 외부에서 봤을 때는 순수 함수의 특성을 유지하는 것처럼 보이게 합니다.

### 결론

**데코레이터**는 파이썬에서 **고차 함수**의 강력한 개념을 **간결하고 표현력 있게** 사용할 수 있도록 하는 **문법적 설탕**입니다. 특히 `*args`와 `**kwargs`의 활용은 데코레이터가 다양한 함수의 인자 서명에 구애받지 않고 **유연하게 적용될 수 있도록** 하는 핵심적인 요소입니다. 이를 통해 개발자는 로깅, 성능 측정, 인증, 캐싱 등 다양한 **교차 절단 관심사**를 함수의 핵심 로직과 분리하여, 더욱 **재사용 가능하고 모듈화된 파이썬 코드**를 작성할 수 있습니다. 데코레이터는 파이썬의 함수형 프로그래밍 스타일을 익히는 데 있어 필수적인 도구이며, 코드의 **가독성과 유지보수성**을 크게 향상시킬 수 있습니다.
````