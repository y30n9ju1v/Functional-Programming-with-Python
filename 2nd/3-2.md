## 3.2 `itertools` 모듈: 강력한 이터레이터 도구

파이썬의 표준 라이브러리인 **`itertools` 모듈**은 함수형 프로그래밍 패러다임에 매우 적합한 강력한 도구들을 제공합니다. 이 모듈은 효율적인 **이터레이터(iterator)**를 생성하고 조작하는 데 특화되어 있으며, 대부분의 함수들이 **지연 평가(lazy evaluation)**를 사용하여 메모리 사용량을 최적화하고 불필요한 계산을 줄여줍니다. 함수형 프로그래밍에서 데이터를 불변(immutable)하게 유지하고 부수 효과(side effect)를 피하는 것을 중요시하는 만큼, `itertools`의 함수들은 이러한 원칙과 잘 부합하며, 간결하고 선언적인 코드를 작성할 수 있도록 돕습니다.

`itertools` 모듈의 함수들은 크게 이터레이터 생성, 이터레이터 결합 및 복제, 그리고 요소 선택 및 변환으로 나눌 수 있습니다.

### 무한/유한 시퀀스 생성

`itertools`는 특정 패턴을 따르는 시퀀스를 생성하는 함수들을 제공합니다. 이들은 무한 시퀀스를 만들 수 있으므로, `islice`와 같은 다른 함수와 함께 사용하여 필요한 만큼만 값을 가져오는 것이 일반적입니다.

- `itertools.count(start=0, step=1)`: 이 함수는 지정된 `start` 값(기본값 0)부터 `step` 간격(기본값 1)으로 증가하는 **무한 시퀀스**를 생성하는 이터레이터를 반환합니다. 숫자를 세거나, 고유한 ID를 생성하거나, 무한 스트림을 처리할 때 유용합니다.
    
    ```
    import itertools
    
    # 0부터 시작하여 1씩 증가하는 무한 시퀀스
    counter = itertools.count()
    print(f"count() 예시: {next(counter)}, {next(counter)}, {next(counter)}...")
    # 출력: count() 예시: 0, 1, 2...
    
    # 10부터 시작하여 5씩 증가하는 시퀀스
    counter_from_10_step_5 = itertools.count(10, 5)
    print(f"count(10, 5) 예시: {next(counter_from_10_step_5)}, {next(counter_from_10_step_5)}, {next(counter_from_10_step_5)}...")
    # 출력: count(10, 5) 예시: 10, 15, 20...
    
    # 무한 시퀀스이므로, 일반적으로 for 루프에 직접 사용하지 않고 islice와 함께 사용합니다.
    print("\ncount()를 islice와 함께 사용하여 5개만 출력:")
    for i in itertools.islice(itertools.count(), 5): 
        print(i, end=' ')
    print()
    # 출력: count()를 islice와 함께 사용하여 5개만 출력:
    # 0 1 2 3 4
    ```
    
- `itertools.cycle(iterable)`: 이 함수는 제공된 이터러블의 모든 요소를 **복사하여 저장**한 다음, 그 요소들을 **무한히 반복하여 반환**하는 새 이터레이터를 생성합니다. 특정 리소스나 상태를 순환적으로 사용할 때 유용합니다.
    
    ```
    import itertools
    
    colors = ['빨강', '초록', '파랑']
    color_cycler = itertools.cycle(colors)
    
    # 무한 반복이므로, 처음 몇 개만 출력합니다.
    print("\ncycle()로 색상 무한 반복 (5개만):")
    for _ in range(5):
        print(next(color_cycler), end=' ')
    print()
    # 출력: cycle()로 색상 무한 반복 (5개만):
    # 빨강 초록 파랑 빨강 초록
    ```
    
- `itertools.repeat(element, [times])`: 이 함수는 특정 요소(`element`)를 `times`만큼 반복하는 이터레이터를 반환합니다. `times`가 제공되지 않으면 `element`를 무한히 반복합니다. 동일한 값으로 목록을 채우거나, 반복적인 작업에 상수 값을 제공할 때 사용됩니다.
    
    ```
    import itertools
    
    # 'Python'을 3번 반복하는 이터레이터
    repeater_limited = itertools.repeat('Python', 3)
    print(f"\nrepeat('Python', 3) 예시: {list(repeater_limited)}")
    # 출력: repeat('Python', 3) 예시: ['Python', 'Python', 'Python']
    
    # 'FP'를 무한 반복하는 이터레이터 (처음 4개만 출력)
    repeater_infinite = itertools.repeat('FP')
    print("\nrepeat('FP')로 무한 반복 (4개만):")
    for _ in range(4):
        print(next(repeater_infinite), end=' ')
    print()
    # 출력: repeat('FP')로 무한 반복 (4개만):
    # FP FP FP FP
    ```
    

### 이터레이터 결합 및 복제

`itertools`는 여러 이터레이터를 유연하게 결합하거나, 하나의 이터레이터를 여러 개로 복제하는 기능을 제공합니다.

- `itertools.chain(*iterables)`: 여러 이터러블(예: 리스트, 튜플, 집합 등)을 인수로 받아, 첫 번째 이터러블의 모든 요소를 반환한 다음, 두 번째, 세 번째 이터러블의 요소를 순서대로 모두 반환하는 **하나의 이터레이터**를 생성합니다. 마치 여러 시퀀스를 하나로 연결하는 것과 같습니다.
    
    ```
    import itertools
    
    list1 = [1, 2, 3]
    tuple1 = ('a', 'b', 'c')
    set1 = {7, 8, 9} # Set은 순서가 보장되지 않을 수 있습니다.
    
    combined_iter = itertools.chain(list1, tuple1, set1)
    print(f"\nchain()으로 여러 이터러블 결합: {list(combined_iter)}")
    # 출력: chain()으로 여러 이터러블 결합: [1, 2, 3, 'a', 'b', 'c', 8, 9, 7] (셋의 순서는 다를 수 있음)
    ```
    
- `itertools.zip_longest(*iterables, fillvalue=None)`: 여러 이터러블에서 각각 하나의 요소를 가져와 튜플로 묶어 반환합니다. 내장 `zip()` 함수가 가장 짧은 이터러블의 길이에 맞춰 중단되는 것과 달리, `zip_longest()`는 **가장 긴 이터러블이 소진될 때까지 계속되며, 길이가 짧은 이터러블의 부족한 요소는 `fillvalue`로 채워집니다** (기본값은 `None`). 길이가 다른 시퀀스를 함께 처리해야 할 때 매우 유용합니다.
    
    ```
    import itertools
    
    names = ['앨리스', '밥', '찰리']
    scores = [90, 85]
    
    # zip()은 가장 짧은 길이에 맞춰 중단됩니다.
    zipped_normal = list(zip(names, scores))
    print(f"\nzip()의 결과 (짧은 길이에 맞춤): {zipped_normal}") 
    # 출력: zip()의 결과 (짧은 길이에 맞춤): [('앨리스', 90), ('밥', 85)]
    
    # zip_longest()는 긴 길이에 맞춰 부족한 요소를 fillvalue로 채웁니다.
    zipped_longest = list(itertools.zip_longest(names, scores, fillvalue='미제공'))
    print(f"zip_longest()의 결과 (fillvalue 사용): {zipped_longest}") 
    # 출력: zip_longest()의 결과 (fillvalue 사용): [('앨리스', 90), ('밥', 85), ('찰리', '미제공')]
    ```
    
- `itertools.tee(iterable, n=2)`: 하나의 이터레이터를 `n`개의 독립적인 이터레이터로 복제합니다. `n`을 지정하지 않으면 기본값은 2입니다. **주의할 점은, 이터레이터를 복제하려면 원본 이터레이터의 일부 내용을 저장해야 하므로, 이터레이터가 크고 새로 생성된 이터레이터 중 하나가 다른 것보다 더 많이 소비될 경우 상당한 메모리를 소비할 수 있습니다**. 동일한 데이터 스트림을 여러 파이프라인에서 독립적으로 처리해야 할 때 사용됩니다.
    
    ```
    import itertools
    
    data_stream = iter(range(5)) # 한 번만 소비될 수 있는 원본 이터레이터
    
    # tee()를 사용하여 3개의 독립적인 이터레이터 생성
    iter1, iter2, iter3 = itertools.tee(data_stream, 3)
    
    # 참고: 원본 이터레이터(data_stream)는 tee()에 의해 내부적으로 소비되므로,
    # 복제 이후 원본을 직접 소비하려 하면 비어있을 수 있습니다.
    # tee()는 복제 시점에 원본의 진행 상태를 '저장'해 둡니다.
    print(f"\ntee()로 복제된 이터레이터들:")
    print(f"Iter1: {list(iter1)}")
    print(f"Iter2: {list(iter2)}")
    print(f"Iter3: {list(iter3)}")
    # 출력:
    # tee()로 복제된 이터레이터들:
    # Iter1: [0, 1, 2, 3, 4]
    # Iter2: [0, 1, 2, 3, 4]
    # Iter3: [0, 1, 2, 3, 4]
    ```
    

### 요소 선택 및 변환

`itertools`는 이터레이터의 요소를 조건에 따라 선택하거나, 변환하는 다양한 함수를 제공합니다.

- `itertools.islice(iterable, start, stop[, step])`: 파이썬의 슬라이싱 문법(예: `list[start:stop:step]`)과 유사하게 이터레이터의 특정 구간을 잘라내어 새로운 이터레이터를 반환합니다. 이 함수는 무한 이터레이터에서 유한한 부분만 가져올 때 특히 유용합니다. 파이썬의 리스트 슬라이싱과 달리, `start`, `stop`, `step`에 음수 값을 사용할 수 없습니다.
    
    ```
    import itertools
    
    numbers_infinite = itertools.count() # 무한 시퀀스
    
    # 0부터 시작하는 무한 시퀀스에서 처음 5개 요소 선택 (stop=5)
    first_five = itertools.islice(numbers_infinite, 5)
    print(f"\nislice(count(), 5)로 5개만 가져오기: {list(first_five)}") 
    # 출력: islice(count(), 5)로 5개만 가져오기: [0, 1, 2, 3, 4]
    
    # 0부터 9까지의 시퀀스에서 인덱스 2부터 7까지 (stop=8) 선택 (start=2, stop=8)
    slice_2_to_7 = itertools.islice(range(10), 2, 8)
    print(f"islice(range(10), 2, 8)로 구간 슬라이싱: {list(slice_2_to_7)}") 
    # 출력: islice(range(10), 2, 8)로 구간 슬라이싱: [2, 3, 4, 5, 6, 7]
    
    # 인덱스 2부터 7까지 2칸씩 건너뛰며 선택 (start=2, stop=8, step=2)
    slice_with_step = itertools.islice(range(10), 2, 8, 2)
    print(f"islice(range(10), 2, 8, 2)로 스텝 슬라이싱: {list(slice_with_step)}") 
    # 출력: islice(range(10), 2, 8, 2)로 스텝 슬라이싱: [2, 4, 6]
    ```
    
- `itertools.starmap(function, iterable)`: `iterable`의 각 요소가 튜플 스트림이라고 가정하고, 이 **튜플의 요소들을 `function`의 개별 인수로 사용하여 `function`을 호출한 결과를 반환**하는 이터레이터를 생성합니다. 일반 `map()`이 단일 인수를 받는 함수에 사용되는 반면, `starmap()`은 여러 인수를 받는 함수에 튜플 형태의 인자를 '언팩(unpack)'하여 전달할 때 유용합니다.
    
    ```
    import itertools
    import operator # operator 모듈은 파이썬 연산자에 해당하는 함수들을 제공합니다.
    
    # (수량, 가격) 튜플 리스트
    inventory = [ (17, 0.99), (32, 0.49), (12, 5.49) ]
    
    # 각 품목의 총액 계산 (수량 * 가격)
    # 람다를 사용하여 (n, p) 튜플을 받아 n * p 계산
    total_prices_lambda = itertools.starmap(lambda n, p: n * p, inventory)
    print(f"\nstarmap() (람다 사용): {list(total_prices_lambda)}")
    # 출력: starmap() (람다 사용): [16.83, 15.68, 65.88]
    
    # operator.mul을 사용하여 동일한 결과. operator.mul(a, b)는 a * b와 같습니다.
    total_prices_mul = itertools.starmap(operator.mul, inventory)
    print(f"starmap() (operator.mul 사용): {list(total_prices_mul)}")
    # 출력: starmap() (operator.mul 사용): [16.83, 15.68, 65.88]
    ```
    
- `itertools.filterfalse(predicate, iterable)`: 내장 `filter()` 함수의 반대 동작을 수행합니다. `predicate` 함수가 `False`를 반환하는 요소들만 필터링하여 반환합니다. `predicate`는 조건의 참/거짓을 반환하는 함수를 의미합니다.
    
    ```
    import itertools
    
    def is_even(x): 
        return x % 2 == 0
    
    numbers = range(10) # 0부터 9까지의 숫자
    
    # is_even이 False를 반환하는 (즉, 짝수가 아닌) 숫자만 선택합니다.
    odd_numbers = itertools.filterfalse(is_even, numbers)
    print(f"\nfilterfalse()로 홀수만 선택: {list(odd_numbers)}") 
    # 출력: filterfalse()로 홀수만 선택: [1, 3, 5, 7, 9]
    ```
    
- `itertools.takewhile(predicate, iterable)`: `predicate` 함수가 `True`를 반환하는 동안은 요소를 계속해서 반환합니다. **한 번이라도 `predicate`가 `False`를 반환하면, 그 시점부터 이터레이터는 더 이상 결과를 생성하지 않고 종료됩니다**.
    
    ```
    import itertools
    
    def less_than_10(x): 
        return x < 10
    
    # 0부터 시작하는 무한 시퀀스에서 10보다 작은 숫자들만 가져옵니다.
    numbers_from_0 = itertools.islice(itertools.count(), 15) # 예시를 위해 0~14 생성
    first_segment = itertools.takewhile(less_than_10, numbers_from_0)
    print(f"\ntakewhile()로 10 미만 값 가져오기: {list(first_segment)}") 
    # 출력: takewhile()로 10 미만 값 가져오기: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    # 짝수만 가져오다가 첫 번째 홀수(7)가 나오면 중단합니다.
    mixed_numbers = [2, 4, 6, 7, 8, 10]
    even_prefix = itertools.takewhile(is_even, mixed_numbers)
    print(f"takewhile()로 짝수 프리픽스 가져오기: {list(even_prefix)}") 
    # 출력: takewhile()로 짝수 프리픽스 가져오기: [2, 4, 6]
    ```
    
- `itertools.dropwhile(predicate, iterable)`: `predicate` 함수가 `True`를 반환하는 동안은 요소를 무시하고 버립니다. **`predicate`가 처음으로 `False`를 반환하는 시점부터, 이후의 모든 요소들을 반환합니다.** 이 점은 `takewhile`과 다릅니다.
    
    ```
    import itertools
    
    # 0부터 시작하는 무한 시퀀스에서 10보다 작은 숫자들을 버립니다.
    numbers_from_0 = itertools.islice(itertools.count(), 15) # 예시를 위해 0~14 생성
    remaining_segment = itertools.dropwhile(less_than_10, numbers_from_0)
    print(f"\ndropwhile()로 10 미만 값 버리기: {list(remaining_segment)}") 
    # 출력: dropwhile()로 10 미만 값 버리기: [10, 11, 12, 13, 14]
    
    # 짝수를 버리다가 첫 번째 홀수(7)가 나오면 그 이후부터 모두 반환합니다.
    mixed_numbers = [2, 4, 6, 7, 8, 10]
    non_even_prefix = itertools.dropwhile(is_even, mixed_numbers)
    print(f"dropwhile()로 짝수 프리픽스 버리기: {list(non_even_prefix)}") 
    # 출력: dropwhile()로 짝수 프리픽스 버리기: [7, 8, 10]
    # 7은 is_even에 대해 False를 반환하므로, 7부터 나머지 모든 요소가 반환됩니다.
    ```
    
- `itertools.compress(data, selectors)`: 두 개의 이터레이터(`data`와 `selectors`)를 받아, `selectors` 이터레이터의 해당 요소가 `True`인 경우에만 `data` 이터레이터의 해당 요소를 반환합니다. 어느 한 이터레이터가 소진되면 중단됩니다. 불리언 마스크를 사용하여 데이터를 필터링하는 것과 유사합니다.
    
    ````
    import itertools
    
    data = ['사과', '바나나', '체리', '대추', '엘더베리']
    # selectors 리스트의 True/False 값에 따라 data의 요소가 선택됩니다.
    selectors = [True, False, True, True, False]
    
    compressed_data = itertools.compress(data, selectors)
    print(f"\ncompress()로 데이터 선택: {list(compressed_data)}") 
    # 출력: compress()로 데이터 선택: ['사과', '체리', '대추']
    
    # 길이가 다른 경우, 짧은 쪽에 맞춰 중단됩니다.
    data_short = [10, 20, 30]
    selectors_long = [True, True, False, True, False]
    compressed_short = itertools.compress(data_short, selectors_long)
    print(f"compress() (selector가 더 긴 경우): {list(compressed_short)}") 
    # 출력: compress() (selector가 더 긴 경우): [10, 20]
    ```itertools` 모듈은 파이썬에서 함수형 프로그래밍 스타일을 적용할 때 매우 유용한 도구들을 제공합니다. 이 함수들은 대부분 **이터레이터를 반환하고 지연 평가를 활용**하여 메모리 효율성을 높이고 불필요한 계산을 피합니다. 이를 통해 개발자는 데이터 변환 및 필터링 로직을 더욱 간결하고 선언적으로 표현할 수 있으며, 복잡한 반복문을 직접 작성하는 대신 고수준의 추상화를 사용할 수 있게 됩니다. `itertools`의 함수들을 잘 활용하면 파이썬에서도 강력하고 효율적인 함수형 코드를 작성하는 데 큰 도움이 됩니다.
    ````