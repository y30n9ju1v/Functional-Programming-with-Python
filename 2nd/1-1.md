## 1.1 함수형 프로그래밍이란 무엇인가?

소프트웨어 개발은 끊임없이 진화하며 다양한 문제 해결 방법론을 제시합니다. 그중 **함수형 프로그래밍(Functional Programming, FP)**은 최근 몇 년간 개발자들 사이에서 다시금 주목받고 있는 핵심 패러다임 중 하나입니다. 이 책은 파이썬이라는 친숙하고 강력한 언어를 통해 함수형 프로그래밍의 본질을 이해하고, 이를 여러분의 코드에 적용하는 방법을 안내할 것입니다.

### 문제 분해와 함수의 역할

함수형 프로그래밍은 근본적으로 **문제를 작고 독립적인 함수의 집합으로 분해하여 해결**하는 방식입니다. 이는 프로그램을 데이터의 흐름으로 바라봅니다. 즉, 입력 데이터가 일련의 함수를 통해 변환되어 최종적인 출력을 생성하는 과정으로 이해하는 것입니다. 각 함수는 자신의 입력에 따라 동작하며, 그 결과를 다음 함수의 입력으로 전달합니다. 이 과정에서 **이상적으로 함수는 오직 입력만을 받고 출력을 생성하며, 주어진 입력에 영향을 미치는 어떠한 내부 상태도 가지지 않습니다**.

이러한 접근 방식의 핵심은 **'순수 함수(Pure Functions)'**의 활용에 있습니다. 순수 함수는 두 가지 중요한 속성을 가집니다:

1. **동일한 입력에 대해 항상 동일한 출력을 반환합니다.** 이는 함수의 예측 가능성을 극대화합니다. 예를 들어, `add(2, 3)` 함수는 언제, 어디서 호출되든 항상 `5`를 반환해야 합니다.
2. **어떤 '부수 효과(Side Effects)'도 발생시키지 않습니다.** 부수 효과란 함수의 반환 값 외에 프로그램의 외부 상태를 변경하거나 외부에 영향을 미치는 모든 행위를 의미합니다. 예를 들어, 전역 변수 변경, 파일 읽기/쓰기, 데이터베이스 업데이트, 화면 출력(`print()`), 네트워크 요청, 또는 `time.sleep()`과 같이 유용한 값을 반환하지 않고 실행을 일시 중지하는 함수 호출 등은 모두 부수 효과에 해당합니다. 순수 함수는 이러한 부수 효과를 피함으로써 코드의 예측 불가능성을 제거하고, 디버깅 및 테스트를 훨씬 용이하게 만듭니다.

예시를 통해 순수 함수와 부수 효과의 차이를 살펴보겠습니다.

**예시 1: 부수 효과가 있는 함수 (순수하지 않음)**

```
# 전역 변수 (외부 상태)
balance = 1000

def withdraw_impure(amount):
    global balance # 전역 변수를 수정합니다 (부수 효과)
    balance -= amount
    print(f"현재 잔액: {balance}") # 콘솔 출력 (부수 효과)
    return balance

print(f"초기 잔액: {balance}")
withdraw_impure(200) # 첫 번째 호출: 잔액 800 출력
withdraw_impure(100) # 두 번째 호출: 잔액 700 출력

# 함수가 호출될 때마다 전역 'balance'가 변경됩니다.
# 또한, 'print' 함수 호출 자체가 부수 효과입니다.
# 동일한 입력(예: 200)으로 두 번 호출해도 동일한 'balance' 결과를 보장할 수 없습니다.
# (이 경우 'balance'의 초기 값에 따라 달라지므로)
```

**예시 2: 순수 함수**

```
def withdraw_pure(current_balance, amount):
    # 외부 상태를 변경하지 않고, 오직 입력에만 의존합니다.
    new_balance = current_balance - amount
    return new_balance

initial_balance = 1000

# 함수는 입력에 대해서만 작동하고, 새로운 값을 반환합니다.
# 외부 변수 'initial_balance'는 변경되지 않습니다.
balance_after_first_withdrawal = withdraw_pure(initial_balance, 200)
print(f"첫 번째 인출 후 잔액: {balance_after_first_withdrawal}") # 800

balance_after_second_withdrawal = withdraw_pure(balance_after_first_withdrawal, 100)
print(f"두 번째 인출 후 잔액: {balance_after_second_withdrawal}") # 700

print(f"원래 초기 잔액: {initial_balance}") # 1000 (변하지 않음)
```

위 예시에서 `withdraw_pure`는 순수 함수입니다. 이는 코드의 **예측 가능성을 높이고 디버깅 및 테스트를 훨씬 용이**하게 합니다. 순수 함수를 사용하면 특정 함수의 동작을 이해하기 위해 전체 프로그램의 상태 변화를 추적할 필요가 없어지기 때문입니다.

파이썬은 함수를 다른 데이터 타입처럼 다룰 수 있는 **'일급 함수(First-Class Functions)'**를 지원합니다. 이는 함수를 변수에 저장하거나, 다른 함수의 인자로 전달하거나, 심지어 다른 함수에서 반환할 수 있다는 것을 의미합니다. 이러한 특성은 **'고차 함수(Higher-Order Functions)'**의 구현을 가능하게 합니다. 고차 함수는 하나 이상의 함수를 인자로 받거나, 함수를 결과로 반환하는 함수를 말합니다. `map()`, `filter()`, `reduce()`와 같은 파이썬의 내장 함수들은 대표적인 고차 함수이며, 이들은 반복문 없이 데이터를 처리하는 강력한 패턴을 제공합니다.

**예시 3: 고차 함수 `map` 사용**

```
# 숫자를 제곱하는 순수 함수
def square(x):
    return x * x

numbers =

# map 함수는 'square' 함수를 인자로 받아 'numbers' 리스트의 각 요소에 적용합니다.
# 결과는 이터레이터이므로 list()로 변환하여 출력합니다.
squared_numbers = list(map(square, numbers))
print(f"제곱된 숫자: {squared_numbers}") #

# 람다 표현식(익명 함수)으로 더 간결하게 표현할 수 있습니다.
squared_numbers_lambda = list(map(lambda x: x * x, numbers))
print(f"람다로 제곱된 숫자: {squared_numbers_lambda}") #
```

또한, 함수형 프로그래밍은 **'불변성(Immutability)'**을 중요하게 여깁니다. 데이터가 한 번 생성되면 변경할 수 없으며, 변경이 필요할 때는 항상 새로운 복사본을 만들어 사용합니다. 이는 예기치 않은 버그를 줄이고, 특히 병렬 및 동시성 환경에서 데이터 일관성 문제를 방지하는 데 큰 도움이 됩니다. 파이썬에서는 문자열(`str`), 튜플(`tuple`), 숫자(`int`, `float`), 불리언(`bool`) 등이 불변 객체입니다. 리스트(`list`), 딕셔너리(`dict`), 세트(`set`)와 같은 가변 객체는 함수형 스타일로 다루려면 새로운 복사본을 생성하는 방식으로 사용해야 합니다.

**예시 4: 불변성을 지키는 리스트 변환**

```
original_list =

# 불변성을 지키는 방식 (새로운 리스트 생성)
# 리스트 컴프리헨션은 함수형 스타일에 맞는 간결한 표기법입니다.
new_list = [x * 2 for x in original_list]
print(f"새로운 리스트: {new_list}") #
print(f"원본 리스트: {original_list}") # (변하지 않음)

# (참고: 아래는 지양해야 할 가변성 코드 예시)
# original_list =
# original_list = 100 # 원본 리스트를 직접 수정 (부수 효과)
# print(original_list) #
```

### 명령형(Imperative) vs. 선언형(Declarative) 프로그래밍

프로그래밍 패러다임은 크게 **명령형(Imperative) 프로그래밍**과 **선언형(Declarative) 프로그래밍**으로 나눌 수 있으며, 함수형 프로그래밍은 선언형 패러다임에 속합니다.

- **명령형 프로그래밍**: 컴퓨터에게 **'무엇을 어떻게 할지(how to do)'**를 단계별로 명시하는 방식입니다. 이는 일련의 명령어 목록으로 구성되며, 프로그램의 상태를 변경하는 방식에 중점을 둡니다. C, Pascal, Unix 쉘 스크립트 등이 대표적인 명령형 언어입니다.
    
    **예시 5: 명령형 방식 - 특정 조건의 요소 필터링 (Java 예시를 Python으로 변환)**
    
    ```
    # 사람 데이터를 표현하는 간단한 클래스 (편의상 필터링에 필요한 속성만 정의)
    class Person:
        def __init__(self, name, gender):
            self.name = name
            self.gender = gender
    
        def __repr__(self):
            return f"Person(name='{self.name}', gender='{self.gender}')"
    
    people = [
        Person("John", "Male"),
        Person("Maria", "Female"),
        Person("Aisha", "Female"),
        Person("Alex", "Male"),
        Person("Alice", "Female")
    ]
    
    # 명령형 접근 방식: '어떻게(how)' 여성만 필터링할지 명시합니다.
    females = [] # 빈 리스트를 초기화합니다.
    for person in people: # 각 사람을 반복합니다.
        if person.gender == "Female": # 조건문을 사용하여 필터링합니다.
            females.append(person) # 조건에 맞는 사람을 리스트에 추가합니다.
    
    print("명령형 방식 (여성):", females)
    # 출력: 명령형 방식 (여성): [Person(name='Maria', gender='Female'), Person(name='Aisha', gender='Female'), Person(name='Alice', gender='Female')]
    ```
    
    위 코드에서 우리는 '빈 리스트를 만들고', '각 요소를 순회하며', '조건을 검사한 뒤', '조건에 맞는 요소를 추가'하는 모든 단계를 직접 지시합니다.
    
- **선언형 프로그래밍**: 컴퓨터에게 **'무엇을 할지(what to do)'**를 기술하고, '어떻게' 수행할지는 언어의 구현에 맡기는 방식입니다. SQL이 가장 흔히 접할 수 있는 선언형 언어의 예시입니다. SQL 쿼리는 검색하려는 데이터셋을 기술하며, SQL 엔진이 테이블을 스캔할지, 인덱스를 사용할지 등을 결정합니다. 함수형 프로그래밍은 이러한 선언형 사고방식을 따르며, 문제 해결 방식을 함수들의 조합으로 바라봅니다.
    
    **예시 6: 선언형 방식 - 특정 조건의 요소 필터링 (Java 예시를 Python으로 변환)**
    
    ```
    # people 리스트는 예시 5와 동일하다고 가정합니다.
    
    # 선언형 접근 방식: '무엇을(what)' 필터링할지 명시합니다.
    # filter 함수와 람다를 사용하여 간결하게 표현합니다.
    # list()로 변환하여 출력합니다.
    females_declarative = list(filter(lambda person: person.gender == "Female", people))
    
    print("선언형 방식 (여성):", females_declarative)
    # 출력: 선언형 방식 (여성): [Person(name='Maria', gender='Female'), Person(name='Aisha', gender='Female'), Person(name='Alice', gender='Female')]
    ```
    
    이 선언형 코드에서는 '사람들 중에서 성별이 여성인 사람들을 필터링하라'는 **'무엇을'** 원하는지에만 집중합니다. `filter` 함수가 내부적으로 어떻게 반복하고 조건을 검사하는지는 우리가 직접 명시할 필요가 없습니다. 파이썬의 리스트 컴프리헨션(List Comprehension)도 이러한 선언형 스타일에 해당하며, 더욱 간결한 코드를 작성할 수 있게 해줍니다.
    
    **예시 7: 리스트 컴프리헨션을 이용한 선언형 방식**
    
    ```
    # people 리스트는 예시 5와 동일하다고 가정합니다.
    
    # 리스트 컴프리헨션을 사용하여 '무엇을' 필터링할지 명시합니다.
    females_listcomp = [person for person in people if person.gender == "Female"]
    
    print("리스트 컴프리헨션 방식 (여성):", females_listcomp)
    # 출력: 리스트 컴프리헨션 방식 (여성): [Person(name='Maria', gender='Female'), Person(name='Aisha', gender='Female'), Person(name='Alice', gender='Female')]
    ```
    
    선언형 코드는 일반적으로 **더 명확하고, 간결하며, 유지보수가 쉬운** 경향이 있습니다. 이는 개발자가 코드의 실행 흐름보다는 문제의 논리에 더 집중할 수 있도록 돕기 때문입니다.
    

### 객체 지향(Object-Oriented) 프로그래밍과의 관계 및 패러다임 혼합

**객체 지향 프로그래밍(Object-Oriented Programming, OOP)**은 프로그램을 '객체'라는 작은 캡슐의 모음으로 보며, 이 객체들은 내부 상태를 가지고 있고, 이 상태를 질의하거나 수정하는 메서드를 제공합니다. 프로그램은 주로 이러한 객체들의 상태 변화를 조작함으로써 구성됩니다. Smalltalk, Java는 객체 지향 언어의 대표적인 예시이며, C++와 파이썬은 객체 지향 프로그래밍을 지원하지만 그 사용을 강제하지는 않는 언어입니다.

함수형 프로그래밍은 객체 지향 프로그래밍과 **상반되는 것처럼 보일 수 있습니다**. 객체 지향이 내부 상태와 그 상태를 변경하는 메서드에 중점을 두는 반면, 함수형 프로그래밍은 **상태 변경을 최대한 피하고 데이터가 함수들 사이를 흐르는 방식**으로 작업합니다. 함수형 프로그래밍은 순수 함수와 불변 데이터 구조를 통해 예측 가능한 동작을 추구하며, 이는 특히 병렬 처리나 동시성 프로그래밍에서 예상치 못한 부작용(Race Condition)을 줄이는 데 유리합니다.

그러나 파이썬과 같은 현대의 많은 프로그래밍 언어들은 **'다중 패러다임(Multi-Paradigm)'**을 지원합니다. 이는 개발자가 특정 문제에 가장 적합한 패러다임을 선택하거나, 필요에 따라 여러 패러다임을 혼합하여 사용할 수 있음을 의미합니다. Lisp, C++, 파이썬이 이러한 다중 패러다임 언어에 해당합니다. 예를 들어, 대규모 프로그램에서는 GUI(그래픽 사용자 인터페이스) 부분은 객체 지향적으로, 핵심 처리 로직은 함수형 또는 절차형으로 작성될 수 있습니다.

파이썬 개발자는 함수형과 객체 지향적 접근 방식을 결합하여 사용할 수 있습니다. 예를 들어, 애플리케이션의 객체(이메일 메시지, 거래 등)를 나타내는 인스턴스를 입력으로 받아 새로운 인스턴스를 반환하는 함수를 작성할 수 있습니다. 이는 객체의 상태를 직접 변경하는 대신, 함수를 통해 객체의 새로운 버전을 생성함으로써 불변성을 유지하고 함수형 원칙을 따르는 것입니다.

**예시 8: 객체 지향과 함수형 스타일의 결합**

```
# 객체 지향: Customer 클래스가 데이터를 캡슐화합니다.
class Customer:
    def __init__(self, name, email):
        self.name = name
        self.email = email

    # 객체의 불변성을 유지하기 위해 __repr__ 추가
    def __repr__(self):
        return f"Customer(name='{self.name}', email='{self.email}')"

# 함수형: 고객 이메일을 업데이트하는 '순수' 함수
# 기존 객체를 변경하는 대신, 새로운 객체를 반환합니다.
def update_customer_email(customer: Customer, new_email: str) -> Customer:
    # 기존 고객 객체를 수정하지 않고, 새로운 고객 객체를 생성하여 반환합니다.
    return Customer(customer.name, new_email)

# 사용 예시
customer1 = Customer("Alice", "alice@example.com")
print(f"원래 고객: {customer1}")

# 함수형 스타일로 이메일 업데이트
customer2 = update_customer_email(customer1, "alice.new@example.com")
print(f"업데이트된 고객: {customer2}")
print(f"원래 고객 (변화 없음): {customer1}") # 원래 객체는 변경되지 않습니다.

# 이메일을 대문자로 변환하는 또 다른 순수 함수
def capitalize_email(customer: Customer) -> Customer:
    return Customer(customer.name, customer.email.upper())

# 함수 조합 (파이프라인) - 함수형 프로그래밍의 핵심 아이디어
# 고객 객체가 여러 함수를 거치며 변환됩니다.
processed_customer = update_customer_email(customer1, "alice_temp@example.com")
processed_customer = capitalize_email(processed_customer)
print(f"파이프라인 처리 고객: {processed_customer}")

# 더 함수형답게 체이닝 또는 compose 함수를 사용할 수도 있습니다 (고급 개념).
# from functools import reduce
# def compose(*funcs):
#     return reduce(lambda f, g: lambda x: f(g(x)), funcs, lambda x: x)
#
# transform_customer = compose(capitalize_email, lambda c: update_customer_email(c, "alice_chained@example.com"))
# customer_chained = transform_customer(customer1)
# print(f"체이닝 처리 고객: {customer_chained}")
```

이처럼 파이썬은 유연하게 다양한 프로그래밍 스타일을 수용할 수 있으며, 함수형 프로그래밍의 원칙들은 코드를 더 견고하고 예측 가능하며 유지보수하기 쉽게 만드는 데 기여할 수 있습니다. 이 책을 통해 여러분은 파이썬에서 함수형 프로그래밍의 강력한 도구들을 익히고, 이를 실제 개발 프로젝트에 효과적으로 적용하는 방법을 배우게 될 것입니다.