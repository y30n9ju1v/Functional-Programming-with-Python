### **4.4 Functor, Applicative, Monad 소개**

함수형 프로그래밍(FP)은 **데이터의 변형과 흐름**에 중점을 두는 프로그래밍 패러다임입니다. 이상적으로 함수는 입력만을 받아 출력을 생성하며, 주어진 입력에 대한 출력에 영향을 미치는 내부 상태를 가지지 않습니다. 이러한 이상적인 함수는 **순수 함수(Pure Function)**라고 불리며, 예측 가능하고 디버깅 및 테스트하기 쉽다는 장점을 가집니다. 하지만 실제 세상의 애플리케이션은 사용자 인터랙션, 파일 읽기/쓰기, 네트워크 통신과 같은 **부수 효과(Side Effect)**를 필연적으로 포함합니다.

하스켈(Haskell)과 같은 순수 함수형 언어에서는 이러한 부수 효과를 직접적으로 허용하지 않습니다. 대신, 부수 효과를 안전하게 관리하고 예측 가능한 방식으로 데이터 흐름을 처리하기 위해 **Functor, Applicative, Monad**와 같은 고급 추상화 개념을 도입합니다. 파이썬은 다중 패러다임 언어이므로 부수 효과와 변경 가능한 상태를 허용하지만, 이러한 개념을 이해하고 적용함으로써 코드를 더욱 함수형답고 견고하게 만들 수 있습니다. 파이썬에서는 `oslash`와 같은 서드파티 라이브러리를 통해 이러한 하스켈 스타일의 추상화를 활용할 수 있습니다.

---

#### **데이터를 감싸고 함수 적용을 제어하는 Functor**

**Functor**는 **값을 감싸는(wrap) 타입**으로, 그 감싸진 값에 함수를 적용하는 방식을 제어합니다. 즉, 감싸진 값을 "풀지 않고" 그 컨텍스트 내에서 함수를 적용할 수 있게 해주는 역할을 합니다. 이는 마치 컨테이너 안에 있는 값에 대해 어떤 작업을 수행하지만, 컨테이너 자체는 그대로 유지하는 것과 같습니다.

**주요 특징:**

- **`map()` 메서드 또는 `%` 연산자**: Functor는 일반적으로 `map()` 메서드나 특정 연산자(`%`와 같은)를 제공하여 감싸진 값에 함수를 적용합니다.
- **컨텍스트 유지**: 함수가 적용된 후에도 값은 여전히 Functor 컨텍스트(즉, 감싸진 상태) 내에 있습니다.
- **유용한 시나리오**: 값이 누락될 수 있는 상황(예: 선택적 값), 또는 함수가 스칼라 값만 처리할 수 있는데 리스트와 같은 컬렉션에 적용해야 하는 경우에 유용합니다.

**하스켈에서의 Functor**: 하스켈에서 Functor는 `fmap`이라는 핵심 함수를 통해 정의됩니다. `fmap`은 `(a -> b)` 타입의 함수와 `F a` 타입의 Functor를 받아 `F b` 타입의 Functor를 반환합니다. 여기서 `F`는 Functor 컨텍스트를 나타냅니다. 하스켈의 리스트(`[]`), `Maybe` 타입 등이 Functor의 인스턴스입니다.

**파이썬에서의 Functor (with `oslash`):** 파이썬의 `oslash` 라이브러리는 하스켈 스타일의 Functor를 제공합니다. 대표적인 예시로 `Just`와 `Nothing` Functor가 있습니다.

- **`Just` Functor**: 유효한 값을 감싸는 Functor입니다.
    
    ```
    from oslash import Just
    
    def increment(x):
        """값을 1 증가시키는 순수 함수"""
        return x + 1
    
    # Just Functor: 5라는 값을 감쌈
    wrapped_value = Just(5)
    print(f"원래 Just 값: {wrapped_value}") # 출력: Just 5
    
    # map() 메서드를 사용하여 함수 적용
    result_map = wrapped_value.map(increment)
    print(f"map() 적용 결과: {result_map}") # 출력: Just 6
    
    # '%' 연산자를 사용하여 함수 적용 (함수가 왼쪽에, Functor가 오른쪽에 위치)
    result_percent = increment % wrapped_value
    print(f"%' 연산자 적용 결과: {result_percent}") # 출력: Just 6
    
    # 일반 함수 호출은 불가능 (TypeError 발생)
    # try:
    #     invalid_call = increment(wrapped_value)
    #     print(invalid_call)
    # except TypeError as e:
    #     print(f"에러 발생: {e}")
    ```
    
    위 예시에서 `increment` 함수는 `Just(5)`를 직접 받아들일 수 없지만, `map()` 메서드나 `%` 연산자를 통해 `Just`컨텍스트 내에서 안전하게 적용됩니다. 결과 또한 `Just` 컨텍스트 내에 감싸져 반환됩니다.
    
- **`Nothing` Functor**: 값이 없는 상태를 나타내는 Functor로, 파이썬의 `None`과 유사하지만 더욱 **예측 가능한 동작**을 제공합니다. `Nothing` Functor에 함수를 적용하면 항상 `Nothing`이 반환되며, 예외가 발생하지 않습니다.
    
    ```
    from oslash import Nothing
    
    def multiply_by_two(x):
        """값을 2배로 만드는 순수 함수"""
        return x * 2
    
    # Nothing Functor: 값이 없음
    empty_value = Nothing()
    print(f"원래 Nothing 값: {empty_value}") # 출력: Nothing
    
    # Nothing에 함수 적용
    result_nothing = multiply_by_two % empty_value
    print(f"Nothing에 함수 적용 결과: {result_nothing}") # 출력: Nothing
    ```
    
    이는 오류가 발생할 수 있는 연산을 체인할 때 특히 유용합니다. 중간에 오류(값 없음)가 발생하더라도 전체 체인이 중단되지 않고 `Nothing`을 전파하여 최종 결과를 예측 가능하게 만듭니다.
    
- **`List` Functor**: 리스트를 감싸고, 스칼라 값을 다루는 함수를 전체 리스트에 적용할 수 있게 합니다. 이는 파이썬 내장 `map()` 함수와 유사합니다.
    
    ```
    from oslash import Just, List
    
    def square(x):
        """값을 제곱하는 순수 함수"""
        return x * x
    
    # List Functor: 리스트를 감쌈
    numbers_list = List.from_iterable()
    print(f"원래 List 값: {numbers_list}") # 출력:
    
    # Just로 감싼 함수를 List Functor에 apply (소스 코드 예시를 따름)
    wrapped_square_func = Just(square)
    squared_numbers = wrapped_square_func.apply(numbers_list)
    print(f"List Functor 적용 결과: {squared_numbers}") # 출력: (오류, 실제는이 나와야함. 소스 코드 예시가 `twice` 함수로 되어있으므로 `square` 함수로 수정하는게 맞음.)
    # Note: The source code example for List functor actually shows `twice` function
    # `ys = f.apply(xs)` (where f = Just(twice)).
    # The output is for input so `twice` is applied correctly.
    # My example above used `square` function but the output from the source is using `twice`.
    # Let's adjust to be consistent with source.
    ```
    
    (정정) 소스 코드 ``의 `List` Functor 예시를 정확히 따르자면, `twice` 함수를 `Just`로 감싸서 `List`에 `apply`하는 형태입니다.
    
    ```
    from oslash import Just, List
    
    def twice(x):
        """값을 두 배로 만드는 순수 함수"""
        return x * 2
    
    # List Functor: 리스트를 감쌈
    numbers_list = List.from_iterable()
    print(f"원래 List 값: {numbers_list}") # 출력:
    
    # Just로 감싼 함수를 List Functor에 apply (소스 코드 예시와 동일)
    wrapped_twice_func = Just(twice)
    doubled_numbers = wrapped_twice_func.apply(numbers_list)
    print(f"List Functor 적용 결과: {doubled_numbers}") # 출력:
    ```
    
    이처럼 `List` Functor는 스칼라 함수를 컬렉션에 적용하는 과정을 깔끔하게 추상화합니다.
    

---

#### **함수를 감싸고 적용하는 Applicative**

**Applicative**는 Functor의 **특별한 종류**입니다. Functor가 값을 감싸고 그 값에 함수를 적용하는 것을 제어한다면, Applicative는 **함수 자체를 감싸고(wrap) 그 함수를 감싸진 값에 적용**할 수 있게 해줍니다. 이는 여러 개의 감싸진 값에 대해 단일 함수를 적용해야 할 때 특히 유용합니다.

**주요 특징:**

- **함수 감싸기**: Applicative는 `Just(func)`와 같이 함수를 감쌀 수 있습니다.
- **`apply()` 메서드**: 감싸진 함수를 감싸진 값에 적용하기 위해 `apply()` 메서드를 사용합니다.
- **부분 적용(Partial Application)**: 여러 인자를 받는 함수를 감쌌을 때, `apply()`를 연속적으로 호출하여 인자를 하나씩 채워나가는 부분 적용이 가능합니다.

**하스켈에서의 Applicative**: 하스켈에서 Applicative는 `Applicative F` 클래스로 정의되며, `pure`와 `(<*>)` (Nemo 연산자)라는 두 가지 핵심 함수를 가집니다. `pure`는 일반 값을 Applicative 컨텍스트로 "들어 올리는(lift)" 역할을 하며, `(<*>)`는 감싸진 함수를 감싸진 값에 적용합니다.

**파이썬에서의 Applicative (with `oslash`):** `oslash`의 `Just` Functor는 Applicative의 역할도 수행합니다.

```
from oslash import Just

def add_three_numbers(a, b, c):
    """세 숫자를 더하는 함수"""
    return a + b + c

# 1. 함수를 Just Applicative로 감싸기
wrapped_adder = Just(add_three_numbers)
print(f"감싸진 함수: {wrapped_adder}") # 출력: Just <function add_three_numbers at ...>

# 2. apply() 메서드를 사용하여 인자를 하나씩 적용 (부분 적용)
# 첫 번째 인자 (a) 적용
partial_adder_1 = wrapped_adder.apply(Just(10))
print(f"첫 번째 인자 적용 후: {partial_adder_1}") # 출력: Just <functools.partial object at ...>

# 두 번째 인자 (b) 적용
partial_adder_2 = partial_adder_1.apply(Just(20))
print(f"두 번째 인자 적용 후: {partial_adder_2}") # 출력: Just <functools.partial object at ...>

# 세 번째 인자 (c) 적용 및 최종 결과 얻기
final_result = partial_adder_2.apply(Just(30))
print(f"최종 결과 (단계별 apply): {final_result}") # 출력: Just 60

# 3. apply() 호출을 한 줄로 체인하여 적용
chained_result = Just(add_three_numbers).apply(Just(1)).apply(Just(2)).apply(Just(3))
print(f"최종 결과 (체인 apply): {chained_result}") # 출력: Just 6
```

이 예시에서 `add_three_numbers` 함수는 세 개의 인자를 받습니다. `Just(add_three_numbers)`로 함수를 감싼 후, `apply(Just(값))`을 연속적으로 호출하여 인자를 하나씩 전달합니다. 각 `apply` 호출은 부분 적용된 함수를 반환하며, 모든 인자가 채워지면 최종 결과가 `Just` 컨텍스트 내에 반환됩니다. 이는 여러 개의 의존적인 인자가 있는 상황에서 함수를 조합하고 적용하는 유연한 방법을 제공합니다.

---

#### **Monad: 복잡한 연산 및 부수 효과 처리 추상화**

**Monad**는 Functor이자 Applicative의 **가장 강력하고 복잡한 형태**입니다. Monad는 단순히 값을 감싸거나 함수를 적용하는 것을 넘어, **함수가 반환하는 값(결과) 또한 감싸서** 다음 연산에 전달하는 방식을 제어합니다. 이는 특히 **순서가 중요한 연산, 오류 처리, 비동기 작업, 또는 다른 부수 효과**를 포함하는 복잡한 데이터 흐름을 처리할 때 사용되는 추상화입니다.

**주요 특징:**

- **`bind()` 메서드**: Monad의 핵심은 `bind()` 메서드입니다. 이 메서드는 Monad 값을 받아 함수를 적용하며, 그 함수는 다시 Monad 값을 반환해야 합니다. 이를 통해 Monad 연산을 연속적으로 "체인"할 수 있습니다.
- **순수 함수형 언어에서의 중요성**: 하스켈과 같은 순수 함수형 언어에서 Monad는 **부수 효과를 순수성 원칙을 깨지 않고 다룰 수 있는 유일한 방법**입니다.
- **오류 전파**: `Nothing` Monad와 같이 실패를 나타내는 Monad는 체인된 연산 전체에 실패를 자동으로 전파하여 복잡한 오류 처리 로직을 단순화합니다.

**하스켈에서의 Monad**: 하스켈에서 Monad는 `Monad M` 클래스로 정의되며, `return`과 `(>>=)` (bind 연산자)라는 핵심 함수를 가집니다. `return`은 순수 값을 Monad 컨텍스트로 "들어 올리는(lift)" 역할을 하며, `(>>=)`는 Monad 값을 함수에 전달하고, 그 함수가 반환한 새로운 Monad 값을 처리합니다. 하스켈의 `IO`, `Maybe`, `List` 등 많은 타입이 Monad의 인스턴스입니다. Monad는 **세 가지 법칙(좌항 동일성, 우항 동일성, 결합 법칙)**을 따라야 합니다.

**파이썬에서의 Monad (with `oslash`):** `oslash`의 `Just`와 `Nothing`은 Monad의 역할도 수행합니다. 특히 `bind()` 메서드를 통해 순차적인 연산 및 오류 처리를 추상화할 수 있습니다.

```
from oslash import Just, Nothing

def safe_division(numerator, denominator):
    """안전한 나눗셈을 수행하는 함수. 0으로 나누면 Nothing을 반환."""
    if denominator == 0:
        print(f"오류: {numerator}를 0으로 나누려 했습니다.")
        return Nothing() # 실패를 Nothing Monad로 표현
    return Just(numerator / denominator) # 성공을 Just Monad로 표현

# 1. Monad - 성공적인 연산 체인
print("--- 성공적인 연산 체인 ---")
# Just(10)에서 시작하여 2로 나누고, 그 결과를 다시 5로 나눔
result_ok = Just(10).bind(lambda n1: safe_division(n1, 2)).bind(lambda n2: safe_division(n2, 5))
print(f"최종 결과: {result_ok}") # 출력: Just 1.0 (10/2=5, 5/5=1)

# 2. Monad - 중간에 실패하는 연산 체인
print("\n--- 중간에 실패하는 연산 체인 ---")
# Just(10)에서 시작하여 0으로 나누려 하므로 실패 발생. 이후 연산은 수행되지 않고 Nothing이 전파됨.
result_fail = Just(10).bind(lambda n1: safe_division(n1, 0)).bind(lambda n2: safe_division(n2, 5))
print(f"최종 결과: {result_fail}") # 출력: Nothing (오류 메시지 출력 후 Nothing)

# 3. Monad - 초기 값이 없는 경우
print("\n--- 초기 값이 Nothing인 연산 체인 ---")
# Nothing에서 시작하면 어떤 bind 함수도 호출되지 않고 Nothing이 그대로 반환됨.
initial_nothing = Nothing()
result_initial_nothing = initial_nothing.bind(lambda n1: safe_division(n1, 2))
print(f"초기 Nothing 결과: {result_initial_nothing}") # 출력: Nothing
```

이 예시에서 `safe_division` 함수는 나눗셈이 성공하면 `Just`를, 실패하면 `Nothing`을 반환하는 Monad를 사용합니다. `bind()`를 통해 이 함수들을 연속적으로 연결할 수 있으며, 중간에 `Nothing`이 반환되면 그 이후의 `bind` 연산은 더 이상 실행되지 않고 `Nothing`이 최종 결과로 전파됩니다. 이는 **오류 처리 로직을 명시적으로 작성하지 않아도 오류가 자동으로 전파되는** 강력한 이점을 제공합니다.

---

#### **Haskell과 파이썬에서의 역할 차이**

Functor, Applicative, Monad는 순수 함수형 언어인 하스켈에서 그 중요성이 극대화됩니다.

- **하스켈에서의 역할**:
    
    - **순수성 강제**: 하스켈은 **함수의 순수성**을 엄격하게 강제합니다. 즉, 모든 함수는 동일한 입력에 대해 항상 동일한 출력을 반환해야 하며, 외부 상태를 변경하거나 외부로부터 영향을 받아서는 안 됩니다.
    - **부수 효과 관리의 필수 도구**: 하지만 실제 프로그램은 파일 I/O, 사용자 입력, 네트워크 통신 등 **부수 효과가 불가피**합니다. 하스켈은 이러한 부수 효과를 직접 허용하는 대신, **Monad(특히 `IO`Monad)**를 사용하여 부수 효과를 "격리"하고 순수한 함수형 방식으로 처리할 수 있게 합니다. 예를 들어, `print()` 함수 호출은 하스켈에서 `IO` Monad 내부에서 일어나는 일입니다.
    - **강력한 타입 시스템과의 시너지**: 하스켈의 강력한 정적 타입 시스템은 Monad의 사용을 강제하고, 개발자가 모든 잠재적 "컨텍스트(예: 실패 가능성, I/O)"를 명시적으로 다루도록 요구합니다. 이는 런타임 오류를 줄이고 코드의 견고성을 높입니다.
- **파이썬에서의 역할**:
    
    - **다중 패러다임 언어의 유연성**: 파이썬은 기본적으로 절차적(procedural), 객체 지향(object-oriented), 그리고 함수형(functional) 프로그래밍 스타일을 모두 지원하는 **다중 패러다임 언어**입니다. 파이썬은 부수 효과를 허용하며, 변수 할당과 루프(loops)를 통해 상태 변경이 자유롭습니다.
    - **필수 아닌 선택적 패턴**: 따라서 파이썬에서는 Functor, Applicative, Monad가 하스켈처럼 **필수적인 개념은 아닙니다**. 대부분의 경우, 개발자는 직관적인 절차적 코드나 객체 지향 코드를 사용하여 동일한 결과를 얻을 수 있습니다. 예를 들어, 하스켈에서 Monad를 사용하는 복잡한 오류 전파 로직은 파이썬에서는 간단한 `if/else` 구문이나 예외 처리(`try/except`)로 구현될 수 있습니다.
    - **특정 시나리오에서의 이점**: 그럼에도 불구하고, 파이썬에서 이러한 개념을 적용하는 것은 특정 상황에서 **코드의 가독성, 유지보수성, 테스트 용이성**을 높일 수 있습니다. 특히 복잡한 데이터 변환 파이프라인, 오류 처리 로직을 추상화할 때, 또는 하스켈과 같은 순수 함수형 언어의 패턴을 파이썬에 적용하고 싶을 때 유용하게 사용될 수 있습니다. `oslash`와 같은 라이브러리는 이러한 패턴을 파이썬에서 편리하게 사용할 수 있도록 돕습니다. 하지만 **성능 오버헤드**가 있을 수 있으므로, 상황에 맞는 적절한 디자인 선택이 중요합니다.

요약하자면, 하스켈에서는 Functor, Applicative, Monad가 언어의 순수성 모델을 유지하기 위한 **근본적인 구성 요소**인 반면, 파이썬에서는 특정 디자인 패턴을 구현하고 코드의 함수형 특성을 강화하기 위한 **선택적인 도구**로 사용됩니다.

---

#### **값으로서의 오류 처리(Error Handling as Values)와 Combinator 패턴**

함수형 프로그래밍에서는 **오류를 부수 효과로 간주**하고, 예외를 발생시키는 대신 **오류를 일반적인 값으로 처리(Error Handling as Values)**하는 것을 선호합니다. 이는 예외 발생이 함수의 예측 불가능성을 높이고, 호출자가 예외 발생 여부를 알 수 없어 `try/catch` 블록을 불필요하게 많이 사용하게 만드는 문제를 해결합니다. 오류를 값으로 반환하면, 함수 시그니처만으로도 함수가 실패할 수 있음을 명확히 알 수 있으며, 호출자는 반환된 오류 값을 명시적으로 처리하도록 강제됩니다.

하스켈에서는 `Maybe` (값이 있거나 없음) 또는 `Either` (성공 값 또는 오류 값 중 하나)와 같은 **합 타입(Sum Type)**을 사용하여 이러한 "값으로서의 오류 처리"를 자연스럽게 구현합니다. 파이썬은 합 타입을 직접적으로 지원하지 않지만, 커스텀 클래스나 `Enum`을 사용하여 유사한 패턴을 만들 수 있습니다.

**Combinator 패턴**: **Combinator 패턴**은 함수형 프로그래밍에서 여러 함수를 조합하여 새로운 함수를 만드는 강력한 디자인 패턴입니다. 이 패턴은 특히 유효성 검사(Validation)와 같은 시나리오에서 "값으로서의 오류 처리"와 결합될 때 그 진가를 발휘합니다. Combinator 함수는 하나 이상의 함수를 인자로 받아 새로운 함수를 반환합니다.

**Combinator 패턴을 통한 유효성 검사 적용**: 고객 등록 시스템의 유효성 검사 시나리오를 예로 들어보겠습니다. 이메일, 전화번호, 연령 등 여러 가지 유효성 검사 규칙이 필요하다고 가정합니다. 절차적 방식으로는 일련의 `if/else` 문이나 불리언 값을 반환하는 개별 함수들을 조합할 수 있습니다. 그러나 이는 어떤 규칙이 실패했는지에 대한 상세 정보를 얻기 어렵고, 새로운 규칙이 추가될 때마다 기존 로직을 수정해야 하는 단점이 있습니다.

Combinator 패턴은 각 유효성 검사 규칙을 독립적인 함수로 정의하고, 이 함수들을 조합하여 복잡한 유효성 검사 파이프라인을 동적으로 구축할 수 있게 합니다. 이때, 각 유효성 검사 함수는 성공 또는 특정 오류를 나타내는 값을 반환하도록 설계하여 "값으로서의 오류 처리" 원칙을 따릅니다.

**파이썬 예시:** 아래 파이썬 코드는 `Enum`으로 유효성 검사 결과를 정의하고, 각 검사 규칙을 함수로 만든 후, Combinator 함수를 사용하여 이 규칙들을 조합하는 방법을 보여줍니다.

```
from enum import Enum
from datetime import date

# 1. 유효성 검사 결과를 나타내는 Enum 정의 (값으로서의 오류 처리)
class ValidationResult(Enum):
    SUCCESS = "Success"
    EMAIL_NOT_VALID = "Email format is invalid"
    PHONE_NUMBER_NOT_VALID = "Phone number must start with +0"
    NOT_AN_ADULT = "Customer must be at least 16 years old"

# 고객 정보 클래스
class Customer:
    def __init__(self, name: str, email: str, phone_number: str, dob: date):
        self.name = name
        self.email = email
        self.phone_number = phone_number
        self.dob = dob

    def __repr__(self):
        return f"Customer(name='{self.name}', email='{self.email}')"

# 2. 개별 유효성 검사 함수 정의
def validate_email(customer: Customer) -> ValidationResult:
    """이메일 형식 유효성 검사"""
    if "@" in customer.email and "." in customer.email: # 간단한 형식 검사
        return ValidationResult.SUCCESS
    return ValidationResult.EMAIL_NOT_VALID

def validate_phone_number(customer: Customer) -> ValidationResult:
    """전화번호 형식 유효성 검사"""
    if customer.phone_number.startswith("+0") and len(customer.phone_number) > 5: # 간단한 형식 검사
        return ValidationResult.SUCCESS
    return ValidationResult.PHONE_NUMBER_NOT_VALID

def validate_age(customer: Customer) -> ValidationResult:
    """연령 유효성 검사 (16세 이상)"""
    today = date.today()
    age = today.year - customer.dob.year - ((today.month, today.day) < (customer.dob.month, customer.dob.day))
    if age >= 16:
        return ValidationResult.SUCCESS
    return ValidationResult.NOT_AN_ADULT

# 3. Combinator 함수 정의
def combine_validators(*validators):
    """
    여러 유효성 검사 함수를 조합하여 새로운 유효성 검사 함수를 반환합니다.
    검사 중 하나라도 실패하면 즉시 해당 오류를 반환합니다 (단락 평가).
    """
    def combined_validator(customer: Customer) -> ValidationResult:
        for validator in validators:
            result = validator(customer)
            if result != ValidationResult.SUCCESS:
                return result # 첫 번째 실패 시 즉시 반환
        return ValidationResult.SUCCESS # 모든 검사 통과 시
    return combined_validator

# --- 실제 시나리오 적용 ---
# 테스트용 고객 데이터 생성
customer1 = Customer("Alice", "alice@example.com", "+0123456789", date(2000, 1, 1)) # 모든 유효성 통과
customer2 = Customer("Bob", "bob_at_example", "+0987654321", date(1995, 5, 10)) # 이메일 실패
customer3 = Customer("Charlie", "charlie@example.com", "123456789", date(2005, 10, 20)) # 전화번호 실패
customer4 = Customer("David", "david@example.com", "+0112233445", date(2010, 3, 15)) # 연령 실패

print("\n--- 유효성 검사 결과 ---")

# 모든 유효성 검사 규칙을 조합
full_validation_chain = combine_validators(
    validate_email,
    validate_phone_number,
    validate_age
)

# 각 고객에 대해 조합된 유효성 검사 함수 적용
for customer in [customer1, customer2, customer3, customer4]:
    validation_result = full_validation_chain(customer)
    print(f"{customer.name}: {validation_result.value}")

print("\n--- 특정 유효성 검사만 조합 (재사용성) ---")
# 이메일과 전화번호 유효성 검사만 조합하는 새로운 검사기 생성
email_phone_validator = combine_validators(
    validate_email,
    validate_phone_number
)

print(f"{customer1.name} (이메일/전화): {email_phone_validator(customer1).value}")
print(f"{customer3.name} (이메일/전화): {email_phone_validator(customer3).value}")
```

**결과 분석**:

- **값으로서의 오류 처리**: 각 `validate_` 함수는 불리언 대신 `ValidationResult` `Enum` 값을 반환합니다. 이는 성공 여부뿐만 아니라 **어떤 유형의 오류**가 발생했는지 명확하게 알려줍니다.
- **Combinator의 유연성**: `combine_validators` 함수는 `validate_email`, `validate_phone_number`, `validate_age`와 같은 개별 유효성 검사 함수들을 인자로 받아, 이들을 순서대로 실행하는 **새로운 함수**를 반환합니다.
- **모듈성 및 재사용성**: 각 유효성 검사 규칙은 독립적이므로, 새로운 규칙을 추가하거나 기존 규칙을 수정해도 다른 부분에 영향을 미치지 않습니다. 또한, 필요에 따라 특정 규칙들만을 조합하여 다양한 유효성 검사 시나리오에 적용할 수 있습니다.
- **단락 평가(Short-circuiting)**: `combine_validators`는 첫 번째 실패 시 즉시 해당 오류를 반환하여 불필요한 추가 검사를 피합니다.

이러한 Combinator 패턴은 파이썬과 같은 다중 패러다임 언어에서도 함수형 프로그래밍의 원칙을 적용하여 **견고하고 유연하며 재사용 가능한 코드**를 작성하는 데 크게 기여할 수 있습니다. 특히 복잡한 비즈니스 로직이나 유효성 검사 규칙을 다룰 때, 코드의 가독성과 유지보수성을 극적으로 향상시킬 수 있습니다.
