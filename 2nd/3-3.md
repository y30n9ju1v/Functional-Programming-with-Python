## 파이썬으로 쉽게 풀어쓴 함수형 프로그래밍

### 3.3 `functools` 모듈: 함수 도구 상자

`functools` 모듈은 파이썬의 표준 라이브러리 중 하나로, **고차 함수(higher-order functions)**와 함께 사용될 때 특히 유용한 도구들을 제공합니다. 고차 함수란 하나 이상의 함수를 인자로 받거나 함수를 결과로 반환하는 함수를 말합니다. `functools`는 함수형 프로그래밍 스타일로 코드를 작성할 때 복잡한 로직을 간결하고 선언적으로 표현할 수 있도록 돕는 "함수 도구 상자"와 같습니다. 이 섹션에서는 `functools` 모듈의 핵심 기능 중 하나인 **부분 함수 적용(Partial Function Application)**과 **함수 합성(Function Composition)**에 대해 자세히 살펴보겠습니다.

#### 부분 함수 적용(Partial Function Application): `functools.partial`

**부분 함수 적용**은 기존 함수의 일부 인수를 미리 채워 넣어 새로운 함수를 만드는 기법입니다. 예를 들어, `f(a, b, c)`라는 함수가 있을 때, `f(1, b, c)`와 동일하게 작동하는 새로운 함수 `g(b, c)`를 만들 수 있습니다. 이렇게 하면 원래 함수가 너무 많은 인수를 가질 때 코드의 가독성을 높이고 특정 상황에 맞춰 함수를 유연하게 사용할 수 있습니다.

`functools.partial` 함수는 이러한 부분 함수 적용을 위해 사용됩니다. `partial()`의 생성자는 `(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)`와 같은 형태로 인자를 받습니다. 여기서 `function`은 원본 함수이고, `arg`나 `kwarg`는 미리 채울 인자들입니다. 결과로 반환되는 객체는 호출 가능한(callable) 상태가 되어, 마치 새로운 함수처럼 사용할 수 있습니다.

**부분 함수 적용의 이점**:

- **재사용성 증가**: 자주 사용되는 함수의 특정 매개변수를 고정하여 재사용 가능한 특수 함수를 쉽게 만들 수 있습니다.
- **코드 간결화**: 복잡한 함수 호출을 줄여 코드의 가독성을 높입니다.
- **인터페이스 맞춤**: 특정 인터페이스(예: 특정 수의 인자만 허용하는 콜백 함수)에 맞춰 기존 함수를 변환할 수 있습니다.

다음은 `functools.partial` 사용 예시입니다:

**예시 1: 기본적인 부분 함수 적용**

```
import functools

# 원본 함수: 네 개의 인자를 받는 이차 함수
def quad(a, b, c, x):
    """
    주어진 계수 a, b, c와 변수 x에 대해 ax^2 + bx + c를 계산합니다.

    """
    return a * x**2 + b * x + c

# a=1, b=2, c=3으로 고정된 새로운 함수 'f' 생성
# 'f'는 이제 'x' 인자만 받습니다.
f = functools.partial(quad, 1, 2, 3) #

# 'f' 함수를 사용하여 다양한 'x' 값에 대한 결과 계산
# 원본 함수를 매번 모든 인자와 함께 호출하는 것보다 간결합니다.
xs = range(5) # 0, 1, 2, 3, 4
results_f = list(map(f, xs))
print(f"f(x) (1x^2 + 2x + 3): {results_f}") #

# a=2, b=0, c=1으로 고정된 새로운 함수 'g' 생성
g = functools.partial(quad, 2, 0, 1) #
results_g = list(map(g, xs))
print(f"g(x) (2x^2 + 0x + 1): {results_g}") #
```

**예시 2: 로깅 시스템에서 부분 함수 적용 활용**

```
import functools

def log(message, subsystem):
    """
    'message' 내용을 지정된 'subsystem'에 기록합니다.

    """
    print(f"{subsystem}: {message}")

# 'subsystem' 인자가 'server'로 미리 채워진 새로운 로깅 함수 생성
server_log = functools.partial(log, subsystem='server') #

# 이제 'server_log' 함수는 'message' 인자만 받습니다.
server_log("소켓을 열 수 없습니다.") # 출력: server: 소켓을 열 수 없습니다.
server_log("데이터베이스 연결 실패") # 출력: server: 데이터베이스 연결 실패

# 'subsystem' 인자가 'client'로 미리 채워진 다른 로깅 함수 생성
client_log = functools.partial(log, subsystem='client')
client_log("사용자 인증 실패") # 출력: client: 사용자 인증 실패
```

**예시 3: 여러 번의 부분 적용 및 키워드 인자**

`partial` 함수는 여러 번 적용될 수도 있으며, 키워드 인자(keyword arguments)를 사용하여 특정 인자를 고정할 수도 있습니다.

```
import functools

def print_formatted(text, prefix="", suffix=""):
    return f"{prefix}{text}{suffix}"

# 1단계: prefix 고정
add_hello_prefix = functools.partial(print_formatted, prefix="Hello, ")

# 2단계: suffix 고정 (이전 함수에 추가 적용)
greet_message = functools.partial(add_hello_prefix, suffix="!")

print(greet_message("World")) # 출력: Hello, World!
```

`functools.partial`은 특정 인자를 순서대로 채워 넣어야 하는 제약을 넘어서 키워드 인자를 사용하여 유연하게 적용할 수 있게 합니다. 예를 들어, `print` 함수를 사용하여 CSV 형식이나 공백으로 구분된 출력을 위한 새로운 함수를 만들 수 있습니다.

```
import functools

names = ['Dilbert', 'Alice', 'Wally']

# sep=','로 고정된 print 함수
print_csv = functools.partial(print, sep=',') #
print_csv(*names) # 출력: Dilbert,Alice,Wally

# sep=' '로 고정된 print 함수
print_space = functools.partial(print, sep=' ') #
print_space(*names) # 출력: Dilbert Alice Wally
```

**부분 함수 적용과 커링(Currying)의 차이점**: 부분 함수 적용은 함수의 인자 중 **일부(subset)**를 채워 넣는 것을 의미합니다. 반면 **커링**은 여러 인수를 받는 단일 함수를, 각 인수를 하나씩 받는 일련의 함수들로 변환하는 특수한 형태의 함수 변환입니다. 파이썬의 `functools.partial`은 엄밀히 말해 부분 함수 적용을 위한 도구이며, 순수한 커링은 서드파티 라이브러리(예: `PyMonad`)를 사용하거나 직접 구현해야 할 수 있습니다.

#### 함수 합성(Function Composition)

**함수 합성**은 여러 함수를 연결하여 하나의 새로운 함수를 만드는 기법입니다. 이는 한 함수의 출력이 다음 함수의 입력이 되는 방식으로 작동합니다. 수학에서 `f(g(x))`와 같이 표현되는 것과 유사합니다. 함수형 프로그래밍에서 함수 합성은 매우 중요하며, 데이터를 일련의 변환을 통해 처리하는 방식, 즉 **파이프라인 처리**의 핵심입니다.

**함수 합성의 이점**:

- **모듈성 및 재사용성**: 문제를 작고 독립적인 함수로 분해한 다음, 이들을 조합하여 더 복잡한 기능을 만듭니다. 각 함수는 한 가지 일만 수행하므로 재사용성이 높아집니다.
- **가독성 및 명확성**: 중간 변수 없이 데이터 흐름을 명확하게 표현하여 코드의 의도를 쉽게 파악할 수 있습니다.
- **디버깅 및 테스트 용이성**: 각 함수가 독립적이고 부수 효과(side effect)가 없으므로 (순수 함수인 경우), 개별 함수를 단위 테스트하고 디버깅하기가 훨씬 쉽습니다. 문제가 발생했을 때 어떤 함수에서 오류가 발생했는지 빠르게 격리할 수 있습니다.
- **효율성 향상**: 특히 대량의 데이터를 처리할 때, 중간 데이터를 불필요하게 여러 번 순회하거나 저장하지 않고 한 번의 파이프라인으로 처리하여 효율성을 높일 수 있습니다.

파이썬에는 `compose`와 같은 내장 함수가 없으므로, 직접 정의하여 사용할 수 있습니다.

**예시 1: 간단한 함수 합성 구현 및 사용**

```
# 두 함수를 합성하는 compose 함수
def compose(f, g):
    """
    함수 g의 출력을 함수 f의 입력으로 연결하여 새로운 함수를 반환합니다.
    즉, f(g(x))를 계산하는 함수를 만듭니다.

    """
    def func(x):
        return f(g(x))
    return func

# 두 개의 간단한 함수 정의
def increment(x):
    """x에 1을 더합니다."""
    return x + 1

def twice(x):
    """x에 2를 곱합니다."""
    return x * 2

# increment와 twice 함수를 합성
# 결과 함수는 먼저 x에 1을 더하고(increment), 그 결과에 2를 곱합니다(twice).
f = compose(twice, increment) #

print(f"f(1): {f(1)}") # (1 + 1) * 2 = 4
print(f"f(2): {f(2)}") # (2 + 1) * 2 = 6
print(f"f(3): {f(3)}") # (3 + 1) * 2 = 8
```

**예시 2: 학점 계산 파이프라인에서 함수 합성 활용**

실제 시나리오에서 함수 합성이 어떻게 강력하게 활용될 수 있는지 보여주는 예시입니다. 여기서는 점수를 학점으로 변환하고, 반올림하며, 최대 학점을 제한하는 일련의 변환을 하나의 파이프라인으로 구성합니다.

```
# 보너스 점수를 추가하는 클로저 함수
def get_bonus_of_func(bonus):
    def add(score):
        return score + bonus
    return add

# 점수를 학점으로 변환하는 클로저 함수 (스위스 학점 시스템: 1~6점)
def get_grade_for_func(max_score):
    def grade(score):
        return score / max_score * 5 + 1
    return grade

# 학점을 특정 정밀도로 반올림하는 클로저 함수
def get_round_to_func(granularity):
    def round_to(value):
        scaled_up = value * (1 / granularity)
        rounded = round(scaled_up)
        scaled_down = rounded * granularity
        return scaled_down
    return round_to

# 최대 학점을 제한하는 클로저 함수 (예: 6.0점 초과 불가)
def get_limit_of_func(max_grade):
    def limit(grade):
        return min(grade, max_grade)
    return limit

# 두 함수를 합성하는 compose 함수 (이전 예시와 동일)
def compose(f, g):
    def func(x):
        return f(g(x))
    return func

# 데이터 및 설정
max_score = 100
scores = # 110점은 최대 학점을 초과하는 경우 테스트
bonus_value = max_score / 10 # 10점 보너스
max_allowed_grade = 6.0
round_granularity = 0.1 # 소수점 첫째 자리까지 반올림

# 각 변환 함수 인스턴스 생성 (클로저)
bonus_of = get_bonus_of_func(bonus_value)
grade_for = get_grade_for_func(max_score)
limit_of = get_limit_of_func(max_allowed_grade)
round_to = get_round_to_func(round_granularity)

# 함수들을 순서대로 합성하여 하나의 파이프라인 함수 생성
# score_to_exact_grade: 점수 -> 보너스 적용 -> 학점 변환
score_to_exact_grade = compose(grade_for, bonus_of) #

# score_to_bounded_grade: 정확한 학점 -> 최대 학점 제한
score_to_bounded_grade = compose(limit_of, score_to_exact_grade) #

# score_to_rounded_grade: 제한된 학점 -> 반올림
score_to_rounded_grade = compose(round_to, score_to_bounded_grade) #

# 합성된 함수를 사용하여 점수 목록에 일괄 적용
rounded_grades = list(map(score_to_rounded_grade, scores))
print(f"최종 학점 (합성 함수 사용): {rounded_grades}")
# 출력: 최종 학점 (합성 함수 사용): [5.0, 5.5, 6.0, 3.5, 6.0, 6.0]
# 110점은 6.0으로 제대로 제한됨
```

이 함수형 접근 방식은 **절차형(procedural)** 코드와 비교할 때 분명한 장점을 가집니다. 절차형 코드는 일반적으로 더 짧을 수 있지만, 각 단계가 어떻게 작동하는지 파악하고 오류를 추적하기가 더 어려울 수 있습니다. 반면 함수형 접근 방식은 각 함수를 독립적으로 추론하고 테스트할 수 있게 합니다. 개별 함수가 올바르게 작동하고, 적절하게 합성되며, `map`과 같이 잘 테스트된 고차 함수와 함께 사용된다면, 전체 결과 또한 정확할 것임을 확신할 수 있습니다.

**여러 함수 합성하기**: 두 함수를 합성하는 `compose` 함수를 여러 함수를 한 번에 합성할 수 있도록 확장할 수 있습니다. 이를 위해 `functools.reduce` 함수를 활용할 수 있습니다. `reduce`는 iterable의 모든 값을 결합하여 단일 값을 생성하는 축소 함수입니다.

```
import functools

# 여러 함수를 합성하는 compose 함수
def compose(*fns):
    """
    여러 함수를 순서대로 합성합니다.
    함수 목록이 주어지면, fns(fns(...fns[n](x)...)) 와 같이 실행됩니다.
    빈 함수 목록이 주어질 경우, 항등 함수(identity function)를 반환합니다.

    """
    def compose_pair(f, g):
        def fn(x):
            return f(g(x))
        return fn
    # functools.reduce를 사용하여 함수 목록을 쌍별로 합성합니다.
    # lambda x: x는 빈 함수 목록에 대한 항등 함수로, 기본값 역할을 합니다.
    return functools.reduce(compose_pair, fns, lambda x: x)

# 예시 함수들
def add_one(x):
    return x + 1

def multiply_by_two(x):
    return x * 2

def power_of_three(x):
    return x ** 3

def subtract_one(x):
    return x - 1

# 여러 함수를 한 번에 합성
# 실행 순서: add_one -> multiply_by_two -> power_of_three -> subtract_one
# 즉, subtract_one(power_of_three(multiply_by_two(add_one(x))))
fn = compose(subtract_one, power_of_three, multiply_by_two, add_one)

print(f"fn(1): {fn(1)}") # (((1 + 1) * 2) ^ 3) - 1 = 63

# 빈 함수 목록을 전달했을 때 (항등 함수 반환)
identity_fn = compose()
print(f"identity_fn(37): {identity_fn(37)}") # 37
```

#### 파이프라인 처리 (Pipelines)

함수 합성은 데이터를 일련의 변환을 통해 처리하는 **파이프라인(pipeline)** 개념으로 이어집니다. 함수형 프로그래밍에서는 데이터를 변경하지 않고(불변성), 각 함수가 입력을 받아 출력을 생성함으로써 데이터가 함수 체인을 통해 흐르도록 장려합니다.

**이터레이터와 지연 평가(Lazy Evaluation)**: 파이썬의 `filter()`, `map()`, 그리고 `itertools` 모듈의 여러 함수들은 **지연 평가(lazy evaluation)**를 사용합니다. 이는 모든 요소를 한 번에 계산하거나 메모리에 로드하는 대신, 값이 요청될 때(예: `next()` 함수 호출 또는 `for` 루프)만 값을 생성한다는 의미입니다. 이러한 지연 평가는 특히 대규모 데이터 세트나 무한 스트림을 다룰 때 매우 중요합니다. 불필요한 계산을 피하고 메모리 사용량을 절약할 수 있기 때문입니다.

`map()`과 `filter()` 같은 함수는 직접적으로 반복되는 요소를 처리하는 대신 **이터레이터(iterator)**를 반환합니다. 이 이터레이터는 실제로 값이 필요할 때까지 계산을 지연시킵니다. 예를 들어, `for` 루프가 마지막까지 실행되지 않거나, `list()`나 `tuple()`과 같은 생성자를 통해 이터레이터가 '실현'되지 않으면 아무런 연산도 수행되지 않을 수 있습니다.

**`filter()`, `map()`, `reduce()` 패턴**: 이 세 가지 함수는 함께 사용하여 데이터 파이프라인을 구축하는 데 자주 활용됩니다.

1. **`filter(predicate, iterable)`**: `predicate` 함수(참/거짓을 반환하는 함수)를 만족하는 `iterable`의 요소들만 선택합니다.
2. **`map(function, iterable)`**: `iterable`의 각 요소에 `function`을 적용하여 새로운 `iterable`을 반환합니다.
3. **`reduce(function, iterable, [initial_value])`**: `iterable`의 모든 값을 `function`으로 결합하여 단일 값을 생성합니다.

다음은 파이프라인과 지연 평가의 동작 방식을 보여주는 예시입니다:

**예시 1: 파이프라인 실행 순서 및 지연 평가**

```
# 부수 효과를 확인하기 위해 print 문을 포함한 함수
def is_taxable(salary):
    """급여가 과세 대상인지 (100000 초과) 확인합니다."""
    print(f"is_taxable({salary}) 호출됨") #
    return salary > 100000

def calc_tax(salary):
    """급여에 대한 세금을 계산합니다 (5%)."""
    print(f"calc_tax({salary}) 호출됨") #
    return salary * 0.05

salaries =

# 파이프라인 구성: 과세 대상 급여 필터링 후 세금 계산
taxes = map(calc_tax, filter(is_taxable, salaries)) #

print("--- 파이프라인 생성 완료, 아직 연산 시작 안 함 ---")

# 'taxes' 이터레이터를 순회할 때 연산이 시작됩니다.
# (이터레이터가 실현될 때, 즉 값이 필요할 때마다)
for tax in taxes: #
    print(f"계산된 세금: {tax}\n") #

print("--- 모든 연산 완료 ---")
```

이 코드를 실행하면, `map`과 `filter` 호출 직후에는 `is_taxable`이나 `calc_tax` 함수가 즉시 실행되지 않고, `for` 루프가 `taxes` 이터레이터의 각 값을 요청할 때마다 `is_taxable`과 `calc_tax`가 순차적으로 호출되는 것을 볼 수 있습니다. 이는 파이썬의 `filter()`, `map()` 등의 함수가 지연 평가를 사용한다는 것을 명확히 보여줍니다. 만약 `for`루프가 없다면, 파이프라인은 생성되지만 실제 연산은 전혀 일어나지 않습니다.

**예시 2: `filter()`, `map()`, `sum()`을 이용한 총 인건비 계산**

이 예시는 직원별 인건비를 계산하고, 그 중 실제 작업 시간이 있는 직원들만을 대상으로 총 인건비를 합산하는 시나리오를 보여줍니다.

```
import functools
import operator

# (이름, 시급, 작업 시간) 튜플 목록
efforts = [ #
    ('Dilbert', 220, 13.5),
    ('Alice', 180, 16.0),
    ('Wally', 150, 0.0), # 작업 시간 없음
    ('Ashok', 80, 42.5),
    ('Dogbert', 250, 3.5),
    ('Pointy Haired Boss', 500, 0.0), # 작업 시간 없음
]

# 1단계: 실제 작업 시간이 있는 직원들만 필터링 (filter)
# lambda e: e > 0.0은 작업 시간이 0보다 큰지 확인합니다.
involved_employees = filter(lambda e: e > 0.0, efforts) #

# 2단계: 각 직원의 인건비 계산 (map)
# lambda e: e * e는 시급 * 작업 시간을 계산합니다.
cost_per_employee = map(lambda e: e * e, involved_employees) #

# 3단계: 모든 개별 인건비 합산 (sum)
# functools.reduce(operator.add, cost_per_employee) 대신 sum() 사용
total_costs = sum(cost_per_employee) #

print(f"총 프로젝트 인건비: {total_costs}") # 출력: 10125.0

# 참고: 작업 시간이 0인 직원은 총 합계에 영향을 주지 않으므로,
# filter 단계 없이 바로 map과 sum을 적용할 수도 있습니다.
cost_per_employee_no_filter = map(lambda e: e * e, efforts)
total_costs_no_filter = sum(cost_per_employee_no_filter)
print(f"필터링 없는 총 프로젝트 인건비: {total_costs_no_filter}") # 출력: 10125.0
```

**예시 3: `filter()`, `map()`, `sum()`, `len()`을 이용한 평균 학점 계산**

이 예시는 제출 목록에서 마감 기한 내에 제출된 시험의 평균 학점을 계산하는 시나리오를 보여줍니다.

```
from datetime import datetime

# (이름, 제출 날짜, 점수) 튜플 목록
submissions = [ #
    ('Alice', '2021-07-03', 73),
    ('Bob', '2021-07-18', 81), # 마감 기한 초과
    ('Charles', '2021-07-12', 57), # 마감 기한 초과
    ('Deborah', '2021-07-10', 96), # 마감 기한 내
    ('Ernest', '2021-07-19', 89), # 마감 기한 초과
    ('Fanny', '2021-07-06', 61),
]

max_score = 100
deadline_date = datetime.fromisoformat('2021-07-10') # 마감 기한

# 1단계: 마감 기한 내 제출만 필터링 (filter)
def is_within_deadline(submission): #
    submitted = datetime.fromisoformat(submission)
    return submitted <= deadline_date # 마감 기한 포함

within_deadline_submissions = filter(is_within_deadline, submissions) #

# 2단계: 점수를 스위스 학점 (1-6)으로 변환 (map)
def swiss_grade(score, max_score): #
    return score / max_score * 5 + 1

grades = map(lambda s: swiss_grade(s, max_score), within_deadline_submissions) #

# map 결과는 이터레이터이므로 list()로 실현해야 len()과 sum()을 사용할 수 있습니다.
grades_list = list(grades) #

# 3단계: 학점의 합계 및 개수를 이용한 평균 계산 (sum, len)
if grades_list:
    average_grade = sum(grades_list) / len(grades_list) #
    print(f"마감 기한 내 제출된 시험의 평균 학점: {average_grade:.2f}") # 출력: 4.35
else:
    print("마감 기한 내 제출된 시험이 없습니다.")
```

이와 같이 `functools` 모듈이 제공하는 `partial`과 함수 합성 기법은 파이썬에서 함수형 프로그래밍 스타일을 적용하여 코드를 **더욱 간결하고, 모듈화하며, 테스트하기 쉽게** 만들 수 있도록 돕습니다. 특히 파이프라인 처리는 데이터를 변경하지 않고도 복잡한 변환을 명확하게 표현할 수 있게 하여, 대규모 시스템에서도 안정적이고 유지보수하기 쉬운 코드를 작성하는 데 기여합니다.