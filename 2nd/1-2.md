## 1.2 함수형 프로그래밍의 핵심 원칙

**함수형 프로그래밍(Functional Programming, FP)**은 컴퓨터 과학에서 문제를 해결하고 프로그램을 구조화하는 강력한 패러다임 중 하나입니다. 대부분의 프로그래밍 언어는 **절차형(procedural)**, **객체 지향형(object-oriented)**, 또는 **선언형(declarative)**과 같은 다양한 방식으로 문제를 분해하는 것을 지원하며, 파이썬은 여러 패러다임을 지원하는 **멀티 패러다임 언어**에 속합니다. 즉, 파이썬에서는 절차형, 객체 지향형, 또는 함수형 스타일로 프로그램을 작성할 수 있습니다.

함수형 프로그래밍은 문제를 **함수의 집합**으로 분해하는 방식입니다. 이상적으로, 함수는 오직 입력을 받고 출력을 생성하며, 주어진 입력에 대한 출력을 결정하는 데 영향을 미치는 **내부 상태를 가지지 않습니다**. 이는 프로그램의 각 부분이 명확하고 예측 가능하도록 만드는 데 중점을 둡니다. 이 장에서는 파이썬에서 함수형 스타일로 코드를 작성할 때 이해하고 적용해야 할 몇 가지 핵심 원칙들을 깊이 있게 탐구합니다.

### 1.2.1 순수 함수(Pure Functions)와 부수 효과(Side Effects) 제거

함수형 프로그래밍의 가장 기본적이고 중요한 개념 중 하나는 **순수 함수(Pure Functions)**입니다. 순수 함수는 수학적 함수의 개념과 유사하게 동작합니다.

**순수 함수의 정의와 특징:** 순수 함수는 다음 두 가지 엄격한 조건을 만족해야 합니다:

- **동일한 입력에 대해 항상 동일한 출력 반환**: 어떤 주어진 입력에 대해서도 항상 똑같은 결과만을 생산합니다. 이는 함수가 외부 상태에 의존하지 않고 오직 전달된 인자만을 기반으로 계산을 수행한다는 의미입니다.
- **부수 효과(Side Effects) 없음**: 함수 실행 중에 함수 외부의 어떤 상태도 변경하지 않습니다. 이는 함수가 반환하는 값 외에 다른 모든 변경 사항을 피한다는 뜻입니다.

**부수 효과의 의미:** **부수 효과**란 함수가 자신의 입력과 출력 외에, 프로그램의 다른 부분이나 외부 세계에 가하는 모든 변경을 의미합니다. 이는 함수형 프로그래밍에서 피해야 할 주요 대상입니다. 일반적인 부수 효과의 예시는 다음과 같습니다:

- **전역 변수 또는 다른 외부 상태의 변경**: 함수 외부의 변수 값을 수정하는 것.
- **I/O(Input/Output) 작업**: 화면에 텍스트를 출력하거나(`print()`), 파일에 데이터를 쓰거나 읽는 것.
- **네트워크 요청**: 외부 서버와 통신하는 것.
- **데이터베이스 조작**: 데이터베이스에 데이터를 저장, 업데이트, 삭제하는 것.
- **시간 지연(delay) 함수 호출**: `time.sleep()`과 같이 프로그램의 실행 흐름에 영향을 주는 것.
- **예외 발생**: 함수가 예외를 `raise`하는 것 (함수형에서는 오류를 값으로 다루는 경향이 있음).

**예측 가능성 및 테스트 용이성:** 순수 함수를 사용하는 것은 많은 이점을 가져옵니다:

- **예측 가능성**: 순수 함수는 주어진 입력에 대해 항상 동일한 출력을 반환하므로, 그 동작을 **예측하기 매우 쉽습니다**. 이는 "내 컴퓨터에서는 되는데..."와 같은 일반적인 소프트웨어 개발 문제와 버그를 피하는 데 도움이 됩니다.
- **테스트 용이성**: 순수 함수는 외부 상태에 의존하지 않기 때문에 **단위 테스트(unit test)를 작성하기가 훨씬 쉽습니다**. 함수를 테스트하기 위해 복잡한 시스템 상태를 설정하거나 모의(mock) 객체를 만들 필요 없이, 단순히 올바른 입력을 제공하고 출력이 예상과 일치하는지 확인하기만 하면 됩니다.
- **디버깅 용이성**: 함수가 작고 명확하게 정의되어 있기 때문에, 프로그램에 문제가 발생했을 때 버그가 발생한 함수를 빠르게 격리하고 해당 함수의 중간 입력과 출력을 검사하여 문제를 진단할 수 있습니다.
- **모듈성 및 재사용성**: 문제를 작고 독립적인 순수 함수들로 분해하도록 강제하므로, 프로그램이 더욱 모듈화됩니다. 이러한 작은 함수들은 읽기 쉽고 오류를 확인하기 용이하며, 다른 프로그램이나 코드의 다른 부분에서도 쉽게 재사용될 수 있습니다.
- **병렬 처리 용이성**: 부수 효과가 없기 때문에, 여러 순수 함수를 독립적으로, 그리고 병렬로 안전하게 실행할 수 있습니다. 이는 멀티코어 환경에서 성능 향상을 가져올 수 있습니다.

**I/O와 같은 '더러운' 부수 효과 관리 전략:** 순수 함수는 이상적이지만, 실제 프로그램은 외부 세계와 상호작용해야 유용합니다. 파일을 읽고 쓰고, 사용자 입력을 받고, 결과를 화면에 표시하는 등의 **I/O 작업은 본질적으로 부수 효과를 가집니다**. 함수형 프로그래밍에서는 이러한 I/O를 "더러운(dirty)" 또는 "불순한(impure)" 것으로 간주하지만, **"더럽지만 필요한(dirty but necessary)"** 것으로 인정합니다.

파이썬과 같은 다중 패러다임 언어에서는 순수성을 강제하지 않습니다. 따라서 파이썬의 함수형 스타일 프로그램은 모든 I/O나 할당을 극단적으로 피하지 않습니다. 대신, 함수형처럼 보이는 인터페이스를 제공하되, 내부적으로는 비순수 기능을 사용할 수 있습니다. 예를 들어, 함수의 구현은 지역 변수에 할당을 사용할 수 있지만, 전역 변수를 수정하거나 다른 부수 효과를 일으키지는 않아야 합니다.

부수 효과를 완전히 없앨 수는 없으므로, 중요한 전략은 **부수 효과가 있는 코드를 코드베이스의 특정 부분으로 제한하고 격리하는 것**입니다. 예를 들어, I/O 작업은 프로그램의 시작이나 끝 부분, 또는 특정 모듈에 집중시킴으로써, 코드의 대부분은 순수 함수로 유지될 수 있습니다. 이렇게 하면 부수 효과가 어디서 발생하는지 명확해지고, 나머지 순수 코드는 여전히 쉽게 테스트하고 디버깅할 수 있습니다.

**코드 예시: 순수 함수와 불순 함수**

```
# 순수 함수 (Pure Function) 예시
def add(a, b):
    """
    두 숫자를 더하는 순수 함수.
    오직 입력에만 의존하며, 외부 상태를 변경하지 않습니다.
    """
    return a + b

# 동일한 입력에 대해 항상 동일한 출력 보장
result1 = add(2, 3)
result2 = add(2, 3)
print(f"add(2, 3)의 결과 (1회): {result1}")
print(f"add(2, 3)의 결과 (2회): {result2}")
# 출력 결과는 항상 5로 동일합니다.

# 불순 함수 (Impure Function) 예시: 전역 변수 변경
global_counter = 0

def increment_impure():
    """
    전역 변수를 변경하는 불순 함수.
    함수 외부의 상태(global_counter)에 의존하고 이를 변경합니다.
    """
    global global_counter # 전역 변수를 수정하기 위해 global 키워드 사용
    global_counter += 1
    return global_counter

print(f"\n불순 함수 호출 1: {increment_impure()}") # 전역 변수 변경: global_counter는 1이 됩니다.
print(f"불순 함수 호출 2: {increment_impure()}") # 전역 변수 변경: global_counter는 2가 됩니다.
print(f"최종 전역 카운터 값: {global_counter}")
# 함수 호출 시마다 결과가 달라지고 외부 상태가 변경됩니다.

# 불순 함수 (Impure Function) 예시: I/O 작업
def log_message(message):
    """
    콘솔에 메시지를 출력하는 불순 함수.
    반환 값 외에 콘솔 출력이라는 부수 효과를 가집니다.
    """
    print(f"[로그] {message}")

log_message("데이터 처리 시작") # 콘솔에 메시지를 출력합니다.
# 이 함수는 유용하지만, 순수 함수의 정의에는 부합하지 않습니다.
```

### 1.2.2 데이터 불변성(Immutability)

함수형 프로그래밍의 또 다른 핵심 원칙은 **데이터 불변성(Immutability)**입니다. 이는 프로그램 내의 모든 데이터가 한 번 생성되면 그 값을 변경할 수 없다는 개념입니다.

**데이터 불변성의 정의와 가변 데이터의 문제점:**

- **정의**: **불변(Immutable)** 데이터는 한 번 생성된 후에는 그 상태나 값을 바꿀 수 없습니다. 변경이 필요할 경우, 원본 데이터를 수정하는 대신, 변경된 내용을 반영하는 **새로운 데이터의 복사본**을 생성하여 반환해야 합니다. 반대로 **가변(Mutable)** 데이터는 생성된 후에 그 값을 변경할 수 있습니다.
- **가변 데이터의 문제점**: 가변 데이터를 사용하는 것은 다음과 같은 문제를 야기할 수 있습니다:
    - **예측 불가능성 및 디버깅의 어려움**: 변수의 값이 프로그램의 여러 지점에서 예상치 못하게 변경될 수 있어, 버그를 추적하고 수정하는 것이 매우 어려워집니다. "무슨 일이 일어난 거지?"라는 혼란을 유발하며, 개발자가 울부짖게 만들 수도 있습니다.
    - **동시성 문제**: 여러 스레드나 프로세스가 동일한 가변 데이터에 동시에 접근하여 수정하려고 할 때, **경쟁 조건(race condition)**이 발생하여 데이터 손상이나 비정상적인 동작을 초래할 수 있습니다. 불변 데이터는 이러한 문제를 피할 수 있습니다.
    - **함수 순수성 저해**: 함수가 인자로 전달받은 가변 객체를 내부에서 변경한다면, 해당 함수는 부수 효과를 가지게 되어 순수 함수가 아니게 됩니다. 이는 함수의 예측 가능성과 테스트 용이성을 떨어뜨립니다.

**Python에서의 가변/불변 타입:** 파이썬은 모든 것을 객체로 다루며, 각 객체는 가변적이거나 불변적입니다.

- **불변(Immutable) 타입**:
    - **숫자**: `int`, `float`, `complex` 등.
    - **문자열**: `str`. 문자열 메서드는 새 문자열을 반환하지, 원본을 변경하지 않습니다.
    - **튜플**: `tuple`. 튜플은 한 번 생성되면 요소를 추가, 삭제, 변경할 수 없습니다.
    - **고정 집합**: `frozenset`은 불변적인 집합 버전입니다.
- **가변(Mutable) 타입**:
    - **리스트**: `list`. 요소를 추가, 삭제, 변경할 수 있습니다.
    - **딕셔너리**: `dict`. 키-값 쌍을 추가, 삭제, 변경할 수 있습니다.
    - **집합**: `set`. 요소를 추가, 삭제할 수 있습니다.

**참조의 가변성**: 파이썬에서 변수에 객체를 할당하는 것은 객체 자체를 복사하는 것이 아니라, 해당 객체를 **참조(reference)**하는 것입니다. 변수를 재할당하는 것은 변수가 다른 객체를 가리키도록 하는 것이며, 이 과정에서 **참조는 항상 가변적**입니다.

**얕은 가변성(Shallow Mutability)**: 튜플과 같은 불변 컨테이너도 얕은 가변성을 가질 수 있습니다. 예를 들어, 불변 튜플이 가변 리스트를 포함하고 있다면, 튜플 자체는 변경할 수 없지만, 그 안에 있는 리스트의 내용은 변경될 수 있습니다.

**변수 업데이트 대신 새로운 복사본 생성:** 불변성을 지향하는 핵심은 데이터를 변경해야 할 때마다 **새로운 복사본을 만들어 반환하는 것**입니다.

- 예시: 파이썬의 `list`에는 `sort()` 메서드가 있어 리스트를 제자리에서(in-place) 정렬하지만, 내장 함수 **`sorted()`는 정렬된 새로운 리스트를 반환합니다**. 함수형 프로그래밍에서는 원본을 수정하지 않는 `sorted()`를 선호합니다.
- 리스트를 복사하는 가장 간단한 방법은 `list()` 함수를 사용하거나 슬라이싱(`[:]`)을 활용하는 것입니다.
- 파이썬의 **리스트 컴프리헨션(list comprehensions)**은 기존 리스트의 각 항목에 변환을 적용하여 **새로운 리스트를 생성하는 매우 효과적인 방법**입니다. 이는 가변 상태 변경 없이 데이터를 변환하는 데 널리 사용됩니다.

**효율성 고려: 영속적 데이터 구조:** 모든 데이터 변경 시 새로운 복사본을 생성하는 것은 특히 대규모 데이터 구조를 다룰 때 **비효율적일 수 있습니다**. 이는 많은 메모리를 소비하고 처리 시간을 증가시킬 수 있습니다.

이러한 문제를 해결하기 위해 함수형 프로그래밍에서는 **영속적 데이터 구조(Persistent Data Structures)**라는 개념을 활용합니다. 영속적 데이터 구조는 변경이 발생할 때마다 데이터 구조의 변경되지 않은 부분을 **구조 공유(Structural Sharing)**라는 방식으로 재사용하여 새로운 복사본 생성 비용을 줄입니다. 예를 들어, 리스트의 한 요소만 변경되면, 새로운 리스트를 완전히 복사하는 대신 변경되지 않은 부분에 대한 참조를 공유하고 변경된 요소만 새로운 노드로 생성하는 식입니다.

파이썬 자체는 영속적 데이터 구조를 기본적으로 지원하지 않지만, `Mori`나 `Immutable.js`와 같은 서드파티 라이브러리를 통해 이러한 개념을 사용할 수 있습니다. 이들 라이브러리는 클로저(Clojure)와 같은 언어에서 영속적 데이터 구조를 구현한 아이디어를 파이썬(또는 자바스크립트)으로 포팅한 것입니다.

**코드 예시: 데이터 불변성**

```
# 데이터 불변성 (Immutability) 예시

# 1. 가변 데이터 (Mutable Data)와 문제점
mutable_list =
print(f"초기 리스트 (가변): {mutable_list}") #

def add_element_impure(data_list, element):
    """
    원본 리스트를 직접 수정하는 불순한 함수.
    """
    data_list.append(element)
    return data_list

returned_list = add_element_impure(mutable_list, 4)
print(f"함수 호출 후 원본 리스트: {mutable_list}") # - 원본이 변경됨!
print(f"반환된 리스트: {returned_list}")     #
print(f"두 변수가 같은 객체인가? {id(mutable_list) == id(returned_list)}") # True

# 2. 불변성 지향 (Immutable Approach): 새로운 복사본 생성
original_tuple = (1, 2, 3) # 튜플은 불변 타입
print(f"\n초기 튜플 (불변): {original_tuple}") # (1, 2, 3)

def add_element_pure(data_tuple, element):
    """
    원본 튜플을 변경하지 않고 새 튜플을 반환하는 순수 함수.
    """
    new_tuple = data_tuple + (element,) # 새 튜플 생성
    return new_tuple

new_tuple = add_element_pure(original_tuple, 4)
print(f"함수 호출 후 원본 튜플: {original_tuple}") # (1, 2, 3) - 원본 불변!
print(f"새로 생성된 튜플: {new_tuple}")       # (1, 2, 3, 4)
print(f"두 변수가 같은 객체인가? {id(original_tuple) == id(new_tuple)}") # False

# 3. 리스트 컴프리헨션을 활용한 불변성 지향 (리스트의 경우)
numbers =
print(f"\n원본 숫자 리스트: {numbers}") #

# 각 숫자를 제곱하여 새로운 리스트 생성 (원본 변경 없음)
squared_numbers = [x * x for x in numbers]
print(f"제곱된 숫자 리스트 (새로운 객체): {squared_numbers}") #
print(f"원본 숫자 리스트 (변경 없음): {numbers}") #
```

### 1.2.3 일급 함수(First-Class Functions)와 고차 함수(Higher-Order Functions)

함수형 프로그래밍의 또 다른 핵심 기둥은 **일급 함수(First-Class Functions)**의 개념과 이를 활용하는 **고차 함수(Higher-Order Functions)**입니다. 이 두 가지 원칙은 함수형 스타일에서 코드를 조직하고 재사용하는 방식을 근본적으로 바꿉니다.

**일급 함수(First-Class Functions): 함수를 값처럼 다루는 능력**

- **정의**: 프로그래밍 언어가 함수를 다른 일반적인 값(예: 숫자, 문자열, 객체, 배열 등)처럼 다룰 수 있도록 지원할 때, 해당 언어는 **일급 함수**를 지원한다고 말합니다. 이는 함수가 다음과 같은 특징을 가짐을 의미합니다:
    - **변수나 데이터 구조에 할당될 수 있습니다**: 함수 객체를 변수에 저장하거나, 리스트, 딕셔너리 등의 데이터 구조에 담을 수 있습니다.
    - **다른 함수의 인자로 전달될 수 있습니다**: 함수를 다른 함수의 입력 값으로 넘겨줄 수 있습니다. 이는 콜백(callback) 함수나 커스텀 정렬 기준을 정의할 때 특히 유용합니다.
    - **다른 함수의 반환 값으로 사용될 수 있습니다**: 함수가 다른 함수를 생성하거나 구성하여 반환할 수 있습니다.
- **파이썬의 지원**: 파이썬은 함수를 완벽하게 일급 객체로 취급합니다. 이는 파이썬이 함수형 프로그래밍을 효과적으로 지원하는 핵심적인 이유 중 하나입니다. 개발자는 함수를 마치 데이터처럼 자유롭게 전달하고 조작하여 동적이고 유연한 코드를 작성할 수 있습니다.

**고차 함수(Higher-Order Functions - HOFs): 함수를 인자로 받거나 함수를 반환하는 함수**

- **정의**: 일급 함수라는 개념을 바탕으로, **고차 함수**는 하나 이상의 함수를 인자(매개변수)로 받거나, 함수를 반환 값으로 사용하는 함수를 의미합니다. 이러한 함수들은 추상화와 코드 재사용성을 크게 향상시킵니다.
- **목적 및 활용**:
    - **추상화된 연산**: `for` 루프와 같은 명령형(imperative) 프로그래밍에서 흔히 사용되는 상태 변경 방식 대신, 데이터에 대한 추상적인 연산을 정의하고 이를 고차 함수를 통해 적용합니다. 이는 코드의 **명확성(Clarity)**을 높이고, 프로그래머의 의도를 더 잘 전달합니다.
    - **코드 재사용**: 반복적으로 나타나는 패턴을 고차 함수로 캡슐화하여, 동일한 로직을 여러 곳에서 재사용할 수 있게 합니다.

**주요 내장 고차 함수:** 파이썬은 함수형 프로그래밍에 유용한 여러 내장 고차 함수를 제공합니다:

- **`map(function, iterable)`**: 이 함수는 `iterable`의 각 요소에 `function`을 적용하고, 그 결과를 담은 **새로운 이터레이터**를 반환합니다. 원본 데이터를 변경하지 않고 데이터를 변환할 때 사용됩니다.
    
    ```
    # map 함수 예시
    numbers =
    def square(x):
        return x * x
    squared_numbers = map(square, numbers)
    print(f"map으로 제곱: {list(squared_numbers)}") #
    ```
    
- **`filter(predicate, iterable)`**: 이 함수는 `iterable`의 각 요소에 대해 `predicate` 함수(참/거짓을 반환하는 함수, 즉 술어)를 적용하고, 조건이 참(True)인 요소들만 필터링하여 **새로운 이터레이터**를 반환합니다.
    
    ```
    # filter 함수 예시
    numbers =
    def is_even(x):
        return x % 2 == 0
    even_numbers = filter(is_even, numbers)
    print(f"filter로 짝수 추출: {list(even_numbers)}") #
    ```
    
- **`functools.reduce(function, iterable, [initializer])`**: `functools` 모듈에 있는 `reduce` 함수는 `iterable`의 모든 요소에 대해 누적 연산을 수행하여 **단일 값**을 산출합니다. `function`은 두 인자를 받아 하나의 값을 반환해야 합니다. 초기값(`initializer`)을 제공할 수 있습니다.
    
    ```
    import functools
    import operator # operator 모듈은 파이썬 연산자에 해당하는 함수를 제공
    
    # reduce 함수 예시
    numbers =
    total_sum = functools.reduce(operator.add, numbers)
    print(f"reduce로 합계 계산: {total_sum}") # 15
    ```
    

**함수 변환(Function Transformations) 및 조합(Composition):** 고차 함수는 함수를 동적으로 변환하거나 여러 함수를 조합하여 새로운 함수를 만드는 데 사용됩니다.

- **함수 변환**: 함수를 입력으로 받아 새로운 함수를 반환하는 고차 함수의 특정 유형입니다. 이는 특정 로직을 재사용하거나, 기존 함수의 동작을 변경할 때 유용합니다. 파이썬의 **데코레이터(Decorators)**는 이러한 함수 변환을 위한 **문법적 설탕(syntactic sugar)**으로, 함수를 선언할 때 `@` 기호를 사용하여 함수 변환을 적용할 수 있게 합니다.
    
    ```
    # 데코레이터 (함수 변환) 예시
    def debug_decorator(func):
        def wrapper(*args, **kwargs):
            print(f"DEBUG: '{func.__name__}' 함수 호출됨 (인자: {args}, {kwargs})")
            result = func(*args, **kwargs)
            print(f"DEBUG: '{func.__name__}' 함수 종료됨 (결과: {result})")
            return result
        return wrapper
    
    @debug_decorator # debug_decorator를 greet_user 함수에 적용
    def greet_user(name, greeting="Hello"):
        return f"{greeting}, {name}!"
    
    greet_user("Alice")
    # 출력:
    # DEBUG: 'greet_user' 함수 호출됨 (인자: ('Alice',), {})
    # DEBUG: 'greet_user' 함수 종료됨 (결과: Hello, Alice!)
    ```
    
- **함수 조합(Function Composition)**: 여러 함수를 연결하여 하나의 새로운 함수를 만드는 것을 의미합니다. 예를 들어, `f(g(x))`는 `x`에 먼저 `g` 함수를 적용한 다음, 그 결과를 `f` 함수에 적용하는 형태입니다. 이러한 조합은 복잡한 데이터 처리 파이프라인을 구축할 때 코드의 가독성과 유지보수성을 크게 향상시킵니다.
    
    ```
    # 함수 조합 예시
    def compose(f, g):
        """두 함수 f와 g를 f(g(x)) 형태로 조합하는 함수"""
        def func(x):
            return f(g(x))
        return func
    
    def add_one(x):
        return x + 1
    
    def multiply_by_two(x):
        return x * 2
    
    # (x + 1) * 2
    composed_function = compose(multiply_by_two, add_one)
    print(f"조합된 함수 결과 (5): {composed_function(5)}") # (5 + 1) * 2 = 12
    ```
    

**부분 적용(Partial Application)과 커링(Currying):** 이 두 개념은 여러 인자를 받는 함수를 더 유연하게 활용하기 위한 고급 기술입니다.

- **부분 적용(Partial Application)**: 함수가 예상하는 인자보다 적은 수의 인자로 호출될 때, 나머지 인자를 기다리는 새로운 함수를 반환하는 기법입니다. 파이썬의 `functools` 모듈에 있는 `partial()` 함수를 사용하여 쉽게 구현할 수 있습니다. 이는 특히 인자가 많은 함수 중 일부를 미리 고정하여 특정 컨텍스트에서 재사용할 때 유용합니다.
    
    ```
    import functools
    
    # 부분 적용 예시
    def greet_template(greeting, name, punctuation="!"):
        return f"{greeting}, {name}{punctuation}"
    
    # 첫 번째 인자 `greeting`을 "Hello"로 고정
    hello_greeter = functools.partial(greet_template, "Hello")
    print(f"부분 적용 함수 호출: {hello_greeter('Alice')}") # Hello, Alice!
    
    # 첫 번째, 세 번째 인자를 고정
    friendly_hello_greeter = functools.partial(greet_template, "Hi", punctuation="~")
    print(f"부분 적용 함수 호출 2: {friendly_hello_greeter('Bob')}") # Hi, Bob~
    ```
    
- **커링(Currying)**: 커링은 함수 변환의 특별한 형태로, 여러 인자를 받는 하나의 함수를 각 인자를 하나씩 받는 일련의 함수들로 변환하는 기법입니다. 즉, `f(a, b, c)`를 `f(a)(b)(c)`와 같이 호출할 수 있도록 만듭니다. 모든 인자가 채워질 때까지 각 호출은 새로운 함수를 반환합니다. 파이썬은 기본적으로 커링을 지원하지 않지만, `PyMonad`와 같은 서드파티 라이브러리를 통해 사용할 수 있습니다. 커링은 함수 시그니처를 특정 형태에 맞출 필요가 있을 때 유용하게 사용될 수 있습니다.
    

일급 함수와 고차 함수는 파이썬에서 유연하고 모듈화된 함수형 코드를 작성하는 데 필수적인 도구입니다. 이를 통해 개발자는 데이터 흐름에 집중하고, 재사용 가능한 빌딩 블록을 통해 복잡한 문제를 해결할 수 있습니다.

### 1.2.4 지연 평가(Lazy Evaluation)

**지연 평가(Lazy Evaluation)**는 함수형 프로그래밍의 중요한 특성 중 하나로, 필요할 때까지 계산을 미루는 평가 전략을 의미합니다. 즉, 어떤 표현식의 값이 실제로 사용되기 전까지는 해당 표현식을 계산하지 않습니다. **게으른 평가**라고도 불립니다.

**정의 및 작동 방식:** 일반적인 **즉시 평가(Eager Evaluation)** 방식에서는 함수가 호출되면 모든 인자를 즉시 계산하고 값을 전달합니다. 반면, 지연 평가 방식에서는 함수가 호출되어도 인자나 표현식의 계산을 미루고, 그 값이 실제로 필요해지는 시점(예: 해당 값이 출력되거나 다른 계산에 사용될 때)에 비로소 계산을 수행합니다.

함수형 언어 중에는 Haskell처럼 언어 자체가 기본적으로 지연 평가를 채택하는 경우가 많습니다. 이러한 언어에서는 개발자가 특별히 지시하지 않아도 모든 계산이 지연 평가됩니다. Haskell의 경우, 평가 엔진은 표현식을 평가해야 할 필요가 있을 때만 "thunk"라는 데이터 구조를 생성하여 필요한 모든 정보를 수집하고, 실제 값이 요청될 때 이 "thunk"를 평가합니다.

**지연 평가의 장점:** 지연 평가는 다음과 같은 중요한 이점을 제공합니다:

- **성능 최적화 및 자원 절약**: 모든 데이터를 미리 계산하여 메모리에 로드하는 대신, 실제로 필요한 부분만 계산하므로 **컴퓨팅 자원(CPU, 메모리)을 효율적으로 절약**할 수 있습니다. 특히 대규모 데이터셋을 처리하거나, 결과의 일부만 필요한 경우에 큰 이점을 가집니다.
- **무한 데이터 스트림 처리**: 무한한 길이의 데이터 시퀀스를 생성하고 처리하는 것이 가능해집니다. 예를 들어, 무한한 자연수 스트림을 생성하는 함수를 만들고, 필요에 따라 그 스트림의 처음 N개 요소만 가져다 쓸 수 있습니다. 즉시 평가 방식에서는 무한 시퀀스를 생성하려 하면 프로그램이 무한 루프에 빠지거나 메모리 부족으로 인해 종료될 것입니다.
- **모듈성 향상**: 데이터를 생산하는 부분과 소비하는 부분을 분리하여, 각 부분이 더욱 독립적으로 설계될 수 있습니다.

**Python에서의 지연 평가:** 파이썬은 Haskell처럼 완전한 지연 평가 언어는 아니지만, **이터레이터(Iterators)**와 **제너레이터(Generators)**를 통해 지연 평가를 강력하게 지원합니다.

- **이터레이터**: 파이썬의 이터레이터는 데이터 스트림을 나타내는 객체입니다. 이 객체는 `__next__()` 메서드를 통해 한 번에 하나의 요소를 반환하며, 더 이상 요소가 없으면 `StopIteration` 예외를 발생시킵니다. 이터레이터는 값이 요청될 때만 값을 생산하므로 **지연 평가 방식으로 동작합니다**.
    - **`map()`, `filter()` 등**: 파이썬의 내장 고차 함수인 `map()`, `filter()` 등은 리스트와 같은 콜렉션을 직접 반환하는 것이 아니라, **이터레이터 객체를 반환합니다**. 따라서 이들 함수는 즉시 모든 결과를 계산하지 않고, 필요한 시점에 요소들을 하나씩 생성하여 제공합니다.
- **제너레이터**: 제너레이터는 이터레이터를 쉽게 작성할 수 있도록 돕는 특별한 종류의 함수입니다. 함수 내부에 `yield` 키워드가 포함되면 해당 함수는 제너레이터 함수가 됩니다. 제너레이터 함수를 호출하면 즉시 값을 반환하는 것이 아니라 **제너레이터 객체(이터레이터)**를 반환합니다. `yield` 표현식에서 제너레이터의 실행이 일시 중단되고 지역 변수 상태가 보존되며, 다음에 `__next__()` 메서드가 호출될 때 실행을 다시 시작합니다. 이 때문에 제너레이터는 상태를 유지하면서 지연 평가를 수행할 수 있습니다.
    - **제너레이터 표현식(Generator Expressions)**: 리스트 컴프리헨션과 문법이 유사하지만, 대괄호 `[]`대신 괄호 `()`로 감싸져 있습니다. 리스트를 즉시 생성하여 메모리에 로드하는 리스트 컴프리헨션과 달리, 제너레이터 표현식은 **이터레이터를 반환하여 지연 평가를 적용합니다**. 이는 무한 스트림이나 매우 큰 데이터를 다룰 때 특히 유용합니다.
- **`range()` 함수**: 파이썬의 내장 `range()` 함수 또한 지연 평가의 좋은 예시입니다. `range(1000000)`과 같이 큰 숫자를 인자로 주어도 즉시 100만 개의 숫자를 생성하여 메모리에 저장하지 않고, 숫자가 필요할 때만 하나씩 생성하여 제공하는 지연 시퀀스를 반환합니다.

**코드 예시: 지연 평가**

```
# 1.2.4 지연 평가 (Lazy Evaluation) 예시

# 1. 제너레이터 함수 (Generator Function)
def count_up_to(max_num):
    print("--- 카운트 제너레이터 시작 ---")
    i = 0
    while i <= max_num:
        yield i # 값을 'yield'하고 실행을 일시 중단합니다.
        print(f"--- {i}를 생성했습니다 ---")
        i += 1

# 제너레이터 객체 생성 (아직 아무 계산도 수행되지 않음)
my_counter = count_up_to(5)
print(f"생성된 객체: {my_counter}") # <generator object count_up_to at ...>

# next() 호출 시에만 값이 생성됩니다.
print(f"첫 번째 값: {next(my_counter)}")
# 출력:
# --- 카운트 제너레이터 시작 ---
# --- 0를 생성했습니다 ---
# 첫 번째 값: 0

print(f"두 번째 값: {next(my_counter)}")
# 출력:
# --- 1를 생성했습니다 ---
# 두 번째 값: 1

# 나머지 값을 모두 소비 (for 루프 또는 list() 사용)
print(f"\n나머지 값 모두 소비: {list(my_counter)}")
# 출력:
# --- 2를 생성했습니다 ---
# --- 3를 생성했습니다 ---
# --- 4를 생성했습니다 ---
# --- 5를 생성했습니다 ---
# 나머지 값 모두 소비:
# 제너레이터는 한 번 소비되면 재사용할 수 없습니다.

# 2. 제너레이터 표현식 (Generator Expression)
# 리스트 컴프리헨션과 달리 괄호 ()를 사용
gen_exp_example = (x * 10 for x in range(3))
print(f"\n제너레이터 표현식 객체: {gen_exp_example}") # <generator object <genexpr> at ...>

# 필요할 때만 값이 생성됩니다.
for val in gen_exp_example:
    print(f"제너레이터 표현식에서 생성된 값: {val}")
# 출력:
# 제너레이터 표현식에서 생성된 값: 0
# 제너레이터 표현식에서 생성된 값: 10
# 제너레이터 표현식에서 생성된 값: 20

# 3. map() 함수의 지연 평가 특성
def expensive_operation(data):
    print(f"고비용 연산: 데이터 {data} 처리 중...")
    return data ** 2

large_data_set = range(1, 6) # range()도 지연 평가
# map()은 이터레이터 객체를 반환하며, 실제 연산은 값을 소비할 때 일어납니다.
mapped_results = map(expensive_operation, large_data_set)
print(f"\nmap() 호출 후: {mapped_results}") # <map object at ...>
# 이 시점에는 '고비용 연산' 메시지가 출력되지 않습니다.

# 값을 소비하는 시점에 연산이 수행됩니다.
for res in mapped_results:
    print(f"연산 결과: {res}")
# 출력:
# 고비용 연산: 데이터 1 처리 중...
# 연산 결과: 1
# 고비용 연산: 데이터 2 처리 중...
# 연산 결과: 4
# ... (마지막 데이터까지)
```

지연 평가는 함수형 프로그래밍에서 효율성, 유연성, 그리고 무한 데이터 구조를 다루는 능력을 제공하는 강력한 도구입니다. 파이썬은 이터레이터와 제너레이터를 통해 이러한 이점을 효과적으로 활용할 수 있게 해줍니다.