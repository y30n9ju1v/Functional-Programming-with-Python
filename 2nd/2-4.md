## 2.4 재귀(Recursion): 반복적인 문제 해결

함수형 프로그래밍에서 **재귀(Recursion)**는 반복적인 문제를 해결하는 핵심 기법 중 하나입니다. 대부분의 프로그래밍 언어에서 반복적인 작업은 `for`나 `while`과 같은 반복문(loops)을 사용하여 처리하지만, 함수형 패러다임에서는 **함수가 자기 자신을 호출하는 방식**을 선호합니다. 재귀는 문제 해결 방식을 그 문제 자체의 더 작은 형태로 정의함으로써, 코드를 더욱 간결하고 우아하게 만들 수 있습니다.

재귀 함수는 크게 두 가지 핵심 부분으로 구성됩니다: **기본 사례(Base Case)**와 **재귀 사례(Recursive Case)**.

- **기본 사례(Base Case)**: 재귀 호출의 **종료 조건**을 정의하는 부분입니다. 이 조건이 충족되면 함수는 더 이상 자신을 호출하지 않고, 미리 정의된 값을 반환함으로써 재귀의 무한 반복을 방지합니다. 기본 사례가 없으면 함수는 계속해서 자신을 호출하며 결국 스택 오버플로우(Stack Overflow) 오류를 일으킬 것입니다.
    
- **재귀 사례(Recursive Case)**: 함수가 **자기 자신을 호출하는 부분**입니다. 이때, 함수는 원래의 문제를 해결하기 위해 더 작거나 단순화된 형태로 문제를 재정의하여 자신을 호출합니다. 각 재귀 호출은 결국 기본 사례에 도달할 수 있도록 문제의 크기를 점진적으로 줄여나가야 합니다.
    

팩토리얼(factorial) 계산은 재귀의 기본 개념을 이해하기 좋은 예시입니다. $N!$ (N 팩토리얼)은 $N \times (N-1) \times \dots \times 1$로 정의됩니다. 이를 재귀적으로 표현하면 $N! = N \times (N-1)!$이 됩니다.

```
# 팩토리얼 함수 (재귀 예시)
def factorial(n):
    # 기본 사례(Base Case): n이 0일 때 1을 반환합니다.
    if n == 0:
        return 1
    # 재귀 사례(Recursive Case): n * (n-1) 팩토리얼을 계산합니다.
    elif n > 0:
        return n * factorial(n - 1)
    else:
        raise ValueError("팩토리얼은 0 이상의 정수에 대해서만 정의됩니다.")

print(f"factorial(4): {factorial(4)}")   # 출력: factorial(4): 24
print(f"factorial(5): {factorial(5)}")   # 출력: factorial(5): 120
```

위 코드에서 `n == 0`은 기본 사례이며, `n * factorial(n - 1)`은 `factorial` 함수가 자신을 호출하는 재귀 사례입니다. 각 호출에서 `n`의 값이 1씩 감소하여 결국 기본 사례인 `n == 0`에 도달하게 됩니다.

### 꼬리 호출 최적화(Tail Call Optimization) 부재와 파이썬의 성능 고려사항

**꼬리 호출 최적화(Tail Call Optimization, TCO)**는 일부 컴파일러가 재귀 함수의 성능을 향상시키기 위해 사용하는 고급 기술입니다. 특히, 함수가 마지막으로 수행하는 연산이 자신을 호출하는 것인 **꼬리 재귀(tail-recursive) 함수**의 경우, 컴파일러는 새로운 스택 프레임을 생성하는 대신 기존 스택 프레임을 재사용하여 메모리 사용량을 줄이고 스택 오버플로우를 방지할 수 있습니다.

하지만 **파이썬은 꼬리 호출 최적화를 지원하지 않습니다**. 이 점은 파이썬에서 재귀 함수를 사용할 때 중요한 성능 고려 사항으로 작용합니다. TCO가 없기 때문에, 파이썬에서 깊은 재귀 호출은 각 함수 호출마다 새로운 스택 프레임을 생성하게 되며, 이는 메모리 오버헤드를 증가시키고 결국 **스택 오버플로우(Stack Overflow)** 오류를 유발할 수 있습니다. 결과적으로, 파이썬에서 반복적인 작업을 수행할 때는 일반적으로 재귀보다 `for`나 `while` 같은 **반복문이 더 효율적입니다**.

예를 들어, 피보나치 수열을 재귀적으로 계산하는 함수를 살펴봅시다. 피보나치 수열은 $F(0)=0$, $F(1)=1$이고, $F(n)=F(n-1)+F(n-2)$로 정의됩니다. TCO가 없는 환경에서 이 함수를 그대로 사용하면 심각한 성능 저하와 중복 계산 문제가 발생합니다.

```
# 비효율적인 피보나치 함수 (TCO 부재의 문제점)
calls = 0 # 함수 호출 횟수 기록용

def fib(n):
    global calls
    calls += 1 # 함수 호출 시마다 카운트 증가

    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        # fib(n-2)와 fib(n-1)이 모두 새로운 호출 스택을 생성합니다.
        # 동일한 인수에 대한 중복 계산이 발생합니다.
        return fib(n - 2) + fib(n - 1)

# fib(6) 호출 시의 호출 과정을 보면 많은 중복 호출이 발생함을 알 수 있습니다.
# fib(6)은 다음과 같이 호출 스택을 생성합니다:
#   fib(4)
#     fib(2)
#       fib(0)
#       fib(1)
#     fib(3)
#       fib(1)
#       fib(2)
#         fib(0)
#         fib(1)
#   fib(5)
#     fib(3)
#       fib(1)
#       fib(2)
#         fib(0)
#         fib(1)
#     fib(4)
#       fib(2)
#         fib(0)
#         fib(1)
#       fib(3)
#         fib(1)
#         fib(2)
#           fib(0)
#           fib(1)

print(f"fib(35)={fib(35)} (호출 횟수: {calls}회)")
# fib(35)를 계산하기 위해 약 3천만 번 가까이 함수가 호출될 수 있습니다.
```

위 예시에서 `fib(35)`를 계산하는 데 약 3천만 번의 함수 호출이 발생하며, 이는 거의 5초에 가까운 실행 시간을 필요로 합니다. 이는 TCO 부재로 인한 중복 계산과 스택 프레임 생성 오버헤드 때문입니다.

### 메모이제이션(Memoization)을 통한 성능 개선: `functools.lru_cache`

앞서 살펴본 피보나치 함수처럼 동일한 인수에 대해 여러 번 같은 결과를 계산하는 경우, **메모이제이션(Memoization)** 기법을 사용하여 성능을 크게 개선할 수 있습니다. 메모이제이션은 **이미 계산한 함수의 결과를 저장(캐싱)**해두고, 동일한 입력이 들어오면 다시 계산하는 대신 저장된 결과를 즉시 반환하는 최적화 기법입니다. 이는 계산 비용이 높은 중간 결과가 여러 번 재사용될 때 특히 유용합니다.

메모이제이션은 일반적으로 함수 인수를 키(key)로, 계산된 결과를 값(value)으로 하는 딕셔너리(dictionary)에 저장하여 구현됩니다.

파이썬에서는 `functools` 모듈의 **`lru_cache` 데코레이터**를 사용하여 메모이제이션을 매우 간편하게 적용할 수 있습니다. `lru_cache`는 "Least Recently Used (가장 최근에 사용되지 않은)" 캐시 정책을 따르며, 지정된 캐시 크기를 초과할 경우 가장 오랫동안 사용되지 않은 항목부터 제거합니다.

`lru_cache`를 피보나치 함수에 적용하여 성능을 개선하는 예시를 살펴봅시다.

```
import functools # functools 모듈 임포트

# lru_cache 데코레이터를 사용하여 fib_memoized 함수에 메모이제이션을 적용합니다.
# 기본적으로 최대 128개의 최근 결과를 캐싱합니다.
@functools.lru_cache()
def fib_memoized(n):
    # 이 부분의 로직은 이전과 동일하지만,
    # lru_cache 덕분에 이미 계산된 결과는 재계산되지 않습니다.
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib_memoized(n - 2) + fib_memoized(n - 1)

print(f"fib_memoized(35)={fib_memoized(35)}")
print(f"lru_cache 정보: {fib_memoized.cache_info()}") # 캐시 히트/미스 정보 확인

# fib_memoized.cache_info()는 캐시 사용 통계를 보여줍니다.
# hits: 캐시에서 결과를 찾은 횟수 (캐시된 결과를 사용한 횟수)
# misses: 캐시에서 결과를 찾지 못해 함수가 실제로 실행된 횟수 (캐시되지 않은 호출 횟수)
# maxsize: 캐시의 최대 크기
# currsize: 현재 캐시에 저장된 항목 수

# 순수 함수 (pure function)는 동일한 인수에 대해 항상 동일한 결과를 반환하고 외부 상태를 변경하지 않는 함수를 의미합니다.
# 재귀 함수 자체는 순수 함수의 조건을 완벽히 만족하지 않을 수 있지만,
# 메모이제이션은 함수의 출력이 입력에만 의존하게 만들어 순수 함수의 장점을 살리는 데 도움을 줍니다.
# lru_cache와 같은 데코레이터를 통해 메모이제이션은 함수의 본질적인 로직과 분리되어 적용될 수 있는 **횡단 관심사(cross-cutting concern)**입니다.
```

`lru_cache`를 사용한 `fib_memoized(35)`는 캐시 미스 수(`misses`)만큼만 함수가 실제로 실행됩니다. 이는 약 3천만 번의 호출이 필요했던 이전 함수에 비해 **약 40만 배 이상의 호출 횟수 감소**를 가져옵니다. 실행 시간 또한 크게 단축되어 거의 즉시 결과를 얻을 수 있습니다.

이처럼 메모이제이션은 특히 재귀 함수에서 발생할 수 있는 중복 계산 문제를 해결하고, 파이썬의 TCO 부재로 인한 성능 저하를 상쇄하는 강력한 도구로 활용될 수 있습니다. 이를 통해 함수형 프로그래밍 스타일을 유지하면서도 효율적인 코드 작성이 가능해집니다.