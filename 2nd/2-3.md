## 2.3 이터레이터와 제너레이터: 데이터 스트림 처리

함수형 프로그래밍은 데이터를 함수의 흐름을 통해 처리하는 방식에 중점을 둡니다. 이 과정에서 **이터레이터(Iterator)**와 **제너레이터(Generator)**는 파이썬에서 데이터 스트림을 효율적으로 다루는 핵심 도구로 활용됩니다. 이들은 필요한 시점에 데이터를 생성함으로써 메모리 사용량을 최적화하고 무한한 데이터 스트림을 처리할 수 있게 합니다.

### 이터레이터 개념과 프로토콜 (`__next__`, `StopIteration`)

**이터레이터**는 데이터 스트림을 나타내는 객체로, 한 번에 하나의 요소를 반환합니다. 이는 데이터 컬렉션의 모든 요소를 메모리에 한꺼번에 로드하지 않고도 순회할 수 있게 해주는 강력한 개념입니다.

파이썬에서 이터레이터가 되기 위해서는 특정 프로토콜을 준수해야 합니다. 이 프로토콜의 핵심은 다음과 같은 두 가지 메서드입니다:

- **`__next__()` 메서드**: 인수를 받지 않으며, 스트림의 다음 요소를 반환합니다. 스트림에 더 이상 요소가 없을 경우, `StopIteration` 예외를 발생시켜 순회의 끝을 알립니다.
- **`StopIteration` 예외**: 이터레이터가 더 이상 반환할 요소가 없을 때 `__next__()` 메서드에 의해 발생합니다.

어떤 객체가 이터레이터를 생성할 수 있다면, 그 객체를 **이터러블(Iterable)**하다고 합니다. `iter()` 내장 함수는 임의의 객체를 받아 해당 객체의 내용을 순회하는 이터레이터를 반환하려고 시도합니다. 만약 객체가 순회를 지원하지 않으면 `TypeError`를 발생시킵니다.

**파이썬의 다양한 내장 데이터 타입들이 이터레이터를 지원합니다**:

- **리스트(Lists)**와 **튜플(Tuples)**: 가장 일반적인 이터러블 객체입니다.
- **문자열(Strings)**: 모든 파이썬 시퀀스 타입과 마찬가지로 이터레이터를 생성할 수 있습니다.
- **딕셔너리(Dictionaries)**: `iter()`를 딕셔너리에 호출하면 딕셔너리의 **키(keys)**를 순회하는 이터레이터를 반환합니다. Python 3.7부터는 딕셔너리 순회 순서가 삽입 순서와 동일하게 보장됩니다. `values()`나 `items()` 메서드를 명시적으로 호출하여 값이나 키/값 쌍을 순회할 수도 있습니다. `dict()` 생성자는 `(key, value)` 튜플의 유한 스트림을 반환하는 이터레이터를 받을 수 있습니다.
- **파일(Files)**: `readline()` 메서드를 호출하여 파일의 각 줄을 순회할 수 있습니다.
- **셋(Sets)**: 이터러블에서 내용을 가져와 셋의 요소를 순회할 수 있습니다.

**코드 예시: 이터레이터 프로토콜 수동 사용**

```
# 리스트는 이터러블 객체입니다.
L = #

# iter() 함수를 사용하여 이터레이터를 얻습니다.
it = iter(L) #
print(it)
# 출력: <list_iterator object at ...>

# __next__() 메서드를 사용하여 다음 요소를 가져옵니다.
print(it.__next__()) # # 1
print(next(it))      # # 2 (next() 내장 함수는 __next__()를 호출합니다)
print(next(it))      # # 3

# 더 이상 요소가 없으므로 StopIteration 예외가 발생합니다.
try:
    next(it)
except StopIteration as e:
    print(f"순회 종료: {e}") #
# 출력: 순회 종료:
```

**`for` 문과 이터레이터**: `for` 문은 파이썬에서 이터레이터를 사용하는 가장 중요한 컨텍스트 중 하나입니다. `for X in Y` 문에서 `Y`는 이터레이터이거나 `iter()`가 이터레이터를 생성할 수 있는 객체여야 합니다. 파이썬은 내부적으로 `iter()`와 `next()` 호출을 사용하여 순회를 처리합니다.

**이터레이터의 특징**:

- **단방향 순회**: 이터레이터는 오직 앞으로만 이동할 수 있습니다. 이전 요소를 가져오거나, 이터레이터를 초기화하거나, 복사하는 방법은 표준 프로토콜에 정의되어 있지 않습니다. 따라서 이터레이터의 출력을 모두 소비하면, 같은 스트림으로 다른 작업을 수행하려면 새 이터레이터를 생성해야 합니다.
- **느린(Lazy) 평가**: 이터레이터는 `next()` 함수를 통해 요청될 때만 값을 생성합니다. 이는 불필요한 계산이나 메모리 할당을 줄여 컴퓨팅 파워와 메모리를 절약할 수 있게 합니다. 이터레이터가 무한한 길이를 가질 수 있는 것도 이 느린 평가 덕분입니다.

`max()`, `min()`과 같은 내장 함수는 단일 이터레이터 인수를 받아 최대 또는 최소 요소를 반환할 수 있습니다. `in`및 `not in` 연산자도 이터레이터를 지원하지만, 무한 이터레이터의 경우 문제가 발생할 수 있습니다.

### 제너레이터 함수와 `yield` 키워드

**제너레이터(Generator)**는 이터레이터를 작성하는 작업을 간소화하는 특별한 종류의 함수입니다. 일반 함수는 값을 계산하고 반환하지만, 제너레이터는 값의 스트림을 반환하는 이터레이터를 반환합니다.

제너레이터의 핵심은 **`yield` 키워드**입니다. `yield` 키워드를 포함하는 함수는 자동으로 제너레이터 함수가 됩니다.

- 일반 함수가 `return` 문에 도달하면 지역 변수가 소멸되고 값이 호출자에게 반환됩니다. 함수를 다시 호출하면 새로운 독립적인 지역 변수 세트가 생성됩니다.
- 그러나 제너레이터 함수는 `yield` 표현식을 실행할 때 값을 출력하고, **실행 상태와 지역 변수를 보존한 채 일시 중지됩니다**.
- 제너레이터의 `__next__()` 메서드가 다음에 호출될 때, 함수는 중단되었던 지점부터 실행을 재개합니다. 이 때문에 제너레이터를 **"다시 시작 가능한 함수(resumable functions)"**로 생각할 수 있습니다.

**코드 예시: 간단한 제너레이터 함수**

```
#
def generate_ints(N):
    for i in range(N):
        yield i

# 제너레이터 함수를 호출하면 제너레이터 객체를 반환합니다.
gen = generate_ints(3) #
print(gen)
# 출력: <generator object generate_ints at ...>

# next()를 호출할 때마다 값이 생성되고 함수가 재개됩니다.
print(next(gen)) # # 0
print(next(gen)) # # 1
print(next(gen)) # # 2

# 더 이상 yield할 값이 없으면 StopIteration이 발생합니다.
try:
    next(gen)
except StopIteration as e:
    print(f"제너레이터 종료: {e}") #
# 출력: 제너레이터 종료:
```

제너레이터는 상태를 유지하므로, `for` 루프와 함께 사용하거나 시퀀스 언패킹(sequence unpacking)에 사용할 수 있습니다. 예를 들어, `for i in generate_ints(5)` 또는 `a, b, c = generate_ints(3)`와 같이 사용할 수 있습니다.

**제너레이터로 값 전달하기**: Python 2.5부터 `yield`는 값을 반환하는 표현식이 되어, 제너레이터 내부로 값을 전달할 수 있게 되었습니다. `send(value)` 메서드를 호출하여 제너레이터의 코드를 재개하고, `yield` 표현식은 지정된 값을 반환합니다. 일반적인 `__next__()` 메서드를 호출하면 `yield`는 `None`을 반환합니다.

**코드 예시: 제너레이터로 값 전달**

```
#
def counter(maximum):
    i = 0
    while i < maximum:
        val = (yield i) # yield는 이제 값을 반환하는 표현식입니다.
        # 값이 제공되면 카운터를 변경합니다.
        if val is not None:
            i = val
        else:
            i += 1

it = counter(10) #
print(next(it)) # 0 (일반적인 next() 호출은 yield에 None을 반환)
print(next(it)) # 1
print(it.send(8)) # 8 (send()는 yield에 8을 반환하고, i가 8로 변경)
print(next(it)) # 9
try:
    next(it)
except StopIteration:
    print("카운터 종료")
# 출력:
# 0
# 1
# 8
# 9
# 카운터 종료
```

`send()` 외에도 `throw(value)` (제너레이터 내부에 예외 발생)와 `close()` (`GeneratorExit` 예외를 보내 순회 종료) 메서드가 있습니다. 이러한 변화들은 제너레이터를 단방향 생산자에서 **생산자이자 소비자**로 전환시켜, **코루틴(coroutines)**이라는 서브루틴의 더 일반화된 형태로 만들었습니다. 서브루틴은 한 지점에서 시작하고 한 지점에서 종료되지만, 코루틴은 여러 `yield` 문에서 시작, 종료 및 재개될 수 있습니다.

### 제너레이터 표현식(Generator Expressions)과 리스트/딕셔너리/셋 컴프리헨션(List/Dict/Set Comprehensions)

이터레이터의 출력에 대한 두 가지 일반적인 연산은 1) 모든 요소에 대해 어떤 작업을 수행하는 것과 2) 특정 조건을 충족하는 요소의 하위 집합을 선택하는 것입니다. **리스트 컴프리헨션(List Comprehensions)**과 **제너레이터 표현식(Generator Expressions)**은 이러한 작업을 위한 간결한 표기법으로, 함수형 프로그래밍 언어인 Haskell에서 차용되었습니다. 또한 파이썬은 딕셔너리와 셋을 위한 컴프리헨션도 제공합니다.

**1. 리스트 컴프리헨션(List Comprehensions)**

- **문법**: 대괄호(`[]`)로 묶여 있습니다.
- **반환 값**: Python 리스트를 반환합니다.
- **평가 방식**: **즉시(eagerly)** 모든 값을 한 번에 생성하고 메모리에 저장합니다.

**코드 예시: 리스트 컴프리헨션**

```
line_list = [' line 1 \n ', 'line 2  \n ', '  \n ', ''] #

# 모든 공백을 제거한 새 리스트를 생성합니다.
stripped_list = [line.strip() for line in line_list] #
print(stripped_list)
# 출력: ['line 1', 'line 2', '', '']

# if 조건을 추가하여 특정 요소만 선택할 수 있습니다.
non_empty_stripped_list = [line.strip() for line in line_list if line != ""] #
print(non_empty_stripped_list)
# 출력: ['line 1', 'line 2']
```

**2. 제너레이터 표현식(Generator Expressions)**

- **문법**: 괄호(`()`)로 묶여 있습니다. 함수 호출을 나타내는 괄호 안에 직접 작성될 때는 추가 괄호가 필요 없을 수도 있습니다.
- **반환 값**: **이터레이터(Iterator)**를 반환합니다.
- **평가 방식**: **느리게(lazily)** 필요할 때만 값을 계산합니다. 이는 무한한 스트림이나 매우 많은 양의 데이터를 다룰 때 리스트 컴프리헨션보다 선호됩니다. 제너레이터는 클래스를 구현할 필요 없이 `yield` 키워드만으로 이터레이터의 장점을 활용할 수 있게 합니다.

**코드 예시: 제너레이터 표현식**

```
line_list = [' line 1 \n ', 'line 2  \n ', '  \n ', ''] #

# 제너레이터 표현식은 이터레이터를 반환합니다.
stripped_iter = (line.strip() for line in line_list) #
print(stripped_iter)
# 출력: <generator object <genexpr> at ...>

# 이터레이터는 필요할 때 값을 생성합니다.
print(next(stripped_iter)) # 'line 1'
print(next(stripped_iter)) # 'line 2'

# 함수에 즉시 전달되는 이터레이터를 생성할 때 유용합니다.
obj_total = sum(obj.count for obj in [{'count':1}, {'count':2}]) #
print(obj_total)
# 출력: 3
```

**다중 `for...in` 절**: 컴프리헨션과 제너레이터 표현식은 여러 `for...in` 절을 포함할 수 있습니다. 이 절들은 왼쪽에서 오른쪽으로 순회하며, 병렬로 순회하지 않습니다. 결과 출력의 길이는 모든 시퀀스 길이의 곱과 같습니다.

**코드 예시: 다중 `for...in` 절**

```
seq1 = 'abc' # 길이 3
seq2 = (1, 2, 3) # 길이 3

#
# 리스트 컴프리헨션으로 가능한 모든 (x, y) 쌍을 생성합니다.
# 결과 길이는 3 * 3 = 9 입니다.
pairs = [(x, y) for x in seq1 for y in seq2]
print(pairs)
# 출력: [('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('c', 3)]

# 표현식이 튜플을 생성하는 경우, 모호성을 피하기 위해 괄호로 묶어야 합니다.
# [x, y for x in seq1 for y in seq2] # Syntax Error
# [(x, y) for x in seq1 for y in seq2] # Correct
```

**3. 딕셔너리 컴프리헨션(Dictionary Comprehensions)**

- **문법**: 중괄호(`{}`)를 사용하며, 각 요소가 `key: value` 쌍으로 구성됩니다.

**코드 예시: 딕셔너리 컴프리헨션**

```
numbers = range(1, 6)

#
# 숫자를 키로, 제곱을 값으로 하는 딕셔너리 생성
squares_dict = {x: x ** 2 for x in numbers}
print(squares_dict)
# 출력: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

**4. 셋 컴프리헨션(Set Comprehensions)**

- **문법**: 중괄호(`{}`)를 사용하며, 중복이 없는 요소들로 구성됩니다.

**코드 예시: 셋 컴프리헨션**

```
additions = [(3, 4), (4, 3), (5, 2), (3, 1), (4, 2)]

#
# 튜플의 합을 요소로 하는 셋 생성 (중복 제거)
sums_set = {x + y for (x, y) in additions}
print(sums_set)
# 출력: {4, 6, 7} (7, 4+3, 5+2, 3+4에서 중복된 7과 6이 제거됨)
```

**컴프리헨션의 장점**: 컴프리헨션은 `filter()`나 `map()`과 같은 고차 함수(higher-order function)를 사용하는 것과 유사하지만, 종종 더 읽기 쉽고 간결합니다. 특히 간단한 변환이나 필터링에는 `lambda` 표현식을 정의할 필요 없이 직접 표현식을 작성할 수 있어 코드를 짧고 명확하게 만듭니다. 이는 **명령형(imperative)** 사고방식(어떻게 할 것인가)에서 벗어나 **선언형(declarative)** 사고방식(무엇을 원하는가)으로 프로그래밍하는 데 기여합니다.

**내부적인 작동 방식**: 컴프리헨션이나 제너레이터 표현식은 다음과 같은 파이썬 코드와 동일하게 해석될 수 있습니다:

```
#
# for expr1 in sequence1:
#    if not (condition1):
#        continue # 이 요소 건너뛰기
#    for expr2 in sequence2:
#        if not (condition2):
#            continue # 이 요소 건너뛰기
#        ...
#        for exprN in sequenceN:
#            if not (conditionN):
#                continue # 이 요소 건너뛰기
#            # expression 값을 출력합니다.
```

결론적으로, 이터레이터와 제너레이터는 파이썬에서 함수형 프로그래밍 스타일을 구현하는 데 있어 중요한 기반입니다. 이들은 데이터 스트림을 효율적으로 처리하고, 느린 평가를 통해 메모리를 절약하며, 간결한 컴프리헨션 문법으로 코드의 가독성을 높이는 데 기여합니다.