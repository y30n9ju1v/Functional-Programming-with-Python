## 제7장: 재귀(Recursion)

함수형 프로그래밍의 핵심 개념 중 하나인 재귀(Recursion)는 함수가 **자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법**입니다. 이는 일반적으로 명령형 프로그래밍에서 사용되는 반복문(loops)의 강력한 대안으로 제시되며, 특히 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 분할하는 데 탁월한 방식을 제공합니다.

함수형 프로그래밍은 개발자가 "무엇을 원하는지"를 명시하는 **선언적(Declarative) 프로그래밍** 스타일을 지향합니다. 이는 코드의 모든 구현 세부 사항을 정의하는 **명령형(Imperative) 프로그래밍**과는 대조됩니다. 재귀는 문제 해결의 '방법(how)'보다는 '무엇(what)'을 달성하고자 하는지에 초점을 맞춘다는 점에서 이러한 선언적 패러다임과 잘 부합합니다. 재귀 함수는 자기 자신을 통해 문제를 정의함으로써, 코드를 더 간결하고, 디버깅하기 쉽고, 추론하기 쉽게 만들어줍니다.

### 재귀의 필수 요소

모든 재귀 함수는 두 가지 필수 요소를 포함해야 합니다. 이 두 가지 요소는 함수가 올바르게 작동하고 무한 루프에 빠지는 것을 방지하는 데 결정적인 역할을 합니다.

- **기저 사례(Base Case)**: **기저 사례는 재귀 호출을 중단하는 조건입니다**. 이 조건이 충족되면 함수는 더 이상 자신을 호출하지 않고, 미리 정의된 값을 반환하거나 특정 작업을 수행하고 종료됩니다. 기저 사례가 없다면, 함수는 무한히 자기 자신을 호출하게 되어 프로그램이 멈추거나 시스템 리소스가 고갈될 수 있습니다 (스택 오버플로우). 따라서 기저 사례는 재귀 함수의 **무한 루프를 방지하는 핵심 안전 장치**입니다. 마치 계단을 내려갈 때 '바닥에 도착하면 멈춘다'는 규칙과 같아요.
    
- **재귀 호출(Recursive Step)**: **재귀 호출은 함수가 문제를 더 작은 하위 문제로 분할하여 자기 자신을 호출하는 부분입니다**. 이때, 다음 호출로 전달되는 입력은 원래 문제보다 더 작거나 단순화되어야 합니다. 또한, 이 하위 문제의 해결은 궁극적으로 기저 사례에 도달하도록 보장해야 합니다. 입력이 변경되지 않으면 "무한 재귀 루프"가 발생할 수 있습니다. 예를 들어, 10층에서 1층까지 내려가는 문제를 풀 때, '현재 층에서 한 층 내려가서 다시 내려가는 문제'로 바꾸는 것과 같습니다.
    

다음 `countdown` 함수는 기저 사례와 재귀 호출의 작동 방식을 명확하게 보여주는 간단한 예시입니다.

```python
# countdown 함수: 재귀의 기본 개념
def countdown(n):
    # 기저 사례(Base Case): n이 0보다 작거나 같으면 재귀를 중단합니다.
    if n <= 0:
        print("발사!") # "Blast Off!"
        return

    # 재귀 호출(Recursive Step): 현재 숫자를 출력하고 n-1로 자기 자신을 호출하여 문제를 축소합니다.
    print(n)
    countdown(n - 1) # n의 값을 1씩 줄여가며 함수를 다시 호출

# 함수 호출 예시
print("카운트다운 시작:")
countdown(5)
# 예상 출력:
# 카운트다운 시작:
# 5
# 4
# 3
# 2
# 1
# 발사!
```

위 예시에서 `n <= 0`은 기저 사례이며, `countdown(n - 1)`은 재귀 호출입니다. 매 호출마다 `n`의 값이 1씩 감소하여 결국 기저 사례에 도달하도록 합니다.

### 파이썬에서 재귀 사용 시 고려사항

파이썬은 재귀를 지원하지만, 다른 순수 함수형 언어와는 다른 몇 가지 중요한 특성 때문에 주의 깊게 사용해야 합니다.

- **꼬리 재귀 최적화(Tail Call Optimization, TCO)의 부재**: 일부 컴파일러와 런타임 환경(예: Elixir 또는 Haskell)은 **꼬리 재귀 최적화(TCO)**를 통해 특정 형태의 재귀 함수(꼬리 재귀 함수)를 효율적으로 처리합니다. TCO는 함수가 마지막에 자신을 호출할 때 이전 스택 프레임을 재사용함으로써 메모리 사용량을 줄이고 스택 오버플로우를 방지하는 최적화 기법입니다. 그러나 **파이썬은 TCO를 지원하지 않습니다**. 이는 파이썬의 디자인 철학에 따른 것으로, 파이썬 인터프리터는 각 함수 호출마다 새로운 스택 프레임을 생성합니다. 파이썬 개발자들은 명시적인 스택 트레이스(stack trace)를 통해 디버깅을 쉽게 할 수 있도록 TCO를 의도적으로 구현하지 않았습니다.
    
    다음은 팩토리얼 계산을 위한 일반 재귀 함수와 꼬리 재귀 "형태"의 함수 예시입니다. 파이썬에서는 두 함수 모두 스택 사용량 측면에서 최적화되지 않습니다.
    
```python
# 팩토리얼 함수의 일반 재귀 구현
def factorial_recursive(n):
	if n == 0:
		return 1
	elif n > 0:
		# 다음 계산을 위해 현재 n 값을 기다려야 합니다.
		# 이 호출이 끝나야 n * ... 계산이 완료됩니다.
		return n * factorial_recursive(n - 1)

# 팩토리얼 함수의 꼬리 재귀 "형태" 구현 (Python은 최적화하지 않음)
# acc (accumulator) 변수에 중간 결과를 누적하여 전달합니다.
def factorial_tail_recursive(n, acc=1):
	if n == 0:
		return acc
	elif n > 0:
		# 함수 호출이 마지막 연산입니다.
		# Python이 TCO를 지원했다면 여기서 이전 스택 프레임을 재사용했을 것입니다.
		return factorial_tail_recursive(n - 1, n * acc)

print(f"일반 재귀 팩토리얼(5): {factorial_recursive(5)}")
print(f"꼬리 재귀 팩토리얼(5): {factorial_tail_recursive(5)}")
# 예상 출력:
# 일반 재귀 팩토리얼(5): 120
# 꼬리 재귀 팩토리얼(5): 120
```
    
factorial_tail_recursive` 함수는 꼬리 재귀 형태를 띠지만, 파이썬에서는 여전히 깊은 재귀 시 스택 메모리 문제를 겪을 수 있습니다.
    
    
- **스택 깊이 제한(Stack Depth Limit)**: TCO가 없기 때문에, 파이썬에서 **매 재귀 호출은 콜 스택(call stack)에 새로운 프레임을 추가합니다**. 재귀가 너무 깊어지면 (기본적으로 약 1000회), 파이썬은 **`RecursionError`를 발생시켜 프로그램이 충돌하는 것을 방지합니다** (일명 "스택 오버플로우"). 이는 파이썬이 "재귀를 너무 깊게" 할 경우 메모리 부족으로 인해 프로그램이 중단될 수 있음을 의미합니다.
    
    이 스택 깊이 제한은 `sys.setrecursionlimit()` 함수를 사용하여 일시적으로 늘릴 수 있지만, 이는 근본적인 해결책이 아니며 메모리 부족 문제를 유발할 수 있으므로 신중하게 사용해야 합니다.
    
- **성능 고려사항**: 파이썬에서 재귀 함수는 일반적으로 반복문(for/while loop)에 비해 **성능이 떨어질 수 있습니다**. 이는 각 함수 호출마다 발생하는 오버헤드(새로운 스택 프레임 생성, 매개변수 전달 등)와 TCO 부재 때문입니다. 특히, 피보나치 수열과 같이 중복 계산이 많은 재귀 함수는 비효율적일 수 있습니다. 다음 예시는 최적화되지 않은 피보나치 함수가 얼마나 많은 호출을 하는지 보여줍니다.
    
```python
# 피보나치 수열 계산 (비효율적인 재귀 예시)
calls = 0 # 전역 변수를 사용한 호출 횟수 기록 (순수 함수형 아님, 데모 목적)
def fib(n):
	global calls
	calls += 1
	if n == 0:
		return 0
	elif n == 1:
		return 1
	else:
		# fib(n-2)와 fib(n-1)이 각각 다시 호출되면서 중복 계산이 발생합니다.
		# 예를 들어, fib(5)는 fib(4)와 fib(3)을 호출하고,
		# fib(4)는 fib(3)과 fib(2)를 호출하므로 fib(3)이 두 번 계산됩니다.
		return fib(n - 2) + fib(n - 1)

# print(f"fib(35)={fib(35)} after {calls} calls")
# 실제 실행 시, fib(35)는 약 3천만 번의 함수 호출과 약 5초 이상의 시간이 소요될 수 있습니다.
# n이 조금만 커져도 호출 횟수가 기하급수적으로 늘어납니다.
```
    
- **성능 향상을 위한 메모이제이션(Memoization)**: 위와 같은 비효율성을 완화하기 위해 **메모이제이션(Memoization)** 기법을 사용할 수 있습니다. 메모이제이션은 함수의 결과를 캐시(저장)하여 동일한 입력에 대해 함수가 다시 호출될 때 계산을 다시 수행하는 대신 저장된 결과를 반환하는 방식입니다. 이는 특히 중복 계산이 많은 재귀 함수에서 **함수 호출 횟수를 크게 줄여 성능을 향상시킬 수 있습니다**.
    
    파이썬의 `functools` 모듈은 `lru_cache` 데코레이터를 통해 메모이제이션 기능을 손쉽게 제공합니다. `lru_cache`는 "Least Recently Used"의 약자로, 가장 최근에 사용되지 않은 항목부터 캐시에서 제거하는 전략을 사용합니다.
    
```python
# functools.lru_cache를 사용한 메모이제이션
from functools import lru_cache

@lru_cache(maxsize=None) # maxsize=None은 캐시 크기 제한 없음 (메모리 허용 범위 내)
def fib_lru_cache(n):
	if n == 0:
		return 0
	elif n == 1:
		return 1
	else:
		return fib_lru_cache(n - 2) + fib_lru_cache(n - 1)

# print(f"fib_lru_cache(35)={fib_lru_cache(35)}")
# print(f"호출 횟수 (캐시 사용): {fib_lru_cache.cache_info().hits + fib_lru_cache.cache_info().misses}")
# fib(35)가 36번의 호출만으로 계산되는 것을 볼 수 있습니다. (원래 3천만 번 대비)
# 캐시 덕분에 각 fib(n)은 한 번만 계산됩니다.
```
    
lru_cache`는 "함수 자체와는 거의 관련이 없는 횡단 관심사(cross cutting concern)"이며, 함수 외부에서 함수 동작을 개선하는 강력한 방법입니다.
    

### 재귀의 실용적 활용

파이썬의 재귀에는 성능 및 스택 깊이 제한과 같은 고려사항이 있지만, 특정 문제 유형, 특히 데이터 구조의 **깊이를 미리 알 수 없는 경우**에 매우 유용하고 우아한 해결책을 제공합니다. 재귀는 **트리(tree) 또는 중첩된(nested) 데이터 구조를 순회하거나 조작하는 데 특히 유용합니다**.

- **중첩된 리스트(Nested Lists) 평탄화**: 재귀의 고전적인 예시 중 하나는 여러 겹으로 중첩된 리스트를 단일한 "평탄한(flattened)" 리스트로 변환하는 것입니다. 재귀는 각 요소를 검사하고, 만약 그 요소가 다시 리스트라면 재귀적으로 평탄화 함수를 호출하여 하위 리스트를 처리합니다.
    
```python
# 중첩된 리스트 평탄화 함수
def flatten_list_recursive(nested_list):
	flattened = [] # 평탄화된 결과를 저장할 리스트
	for element in nested_list:
		if isinstance(element, list):
			# 요소가 리스트이면, 재귀적으로 flatten_list_recursive를 호출하여
			# 하위 리스트를 평탄화하고 그 결과를 현재 리스트에 추가합니다.
			flattened.extend(flatten_list_recursive(element))
		else:
			# 요소가 리스트가 아니면 (단일 요소), 그대로 추가합니다.
			flattened.append(element)
	return flattened

# 함수 호출 예시
nested_list_example = [1, [2, [3, 4]], 5, [6, [7, 8, [9, 10]]]]
print(f"원본 중첩 리스트: {nested_list_example}")
print(f"평탄화된 리스트: {flatten_list_recursive(nested_list_example)}")
# 예상 출력: 평탄화된 리스트: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
    
이 함수는 리스트의 중첩 깊이를 미리 알 필요 없이 모든 중첩된 요소를 처리할 수 있도록 해줍니다.
    
- **트리 또는 중첩된 디렉토리/파일 시스템 순회**: 재귀는 파일 시스템과 같이 **트리 구조를 가지는 데이터 구조를 처리하는 데 매우 효과적**입니다. 각 디렉토리는 중첩된 다른 디렉토리나 파일을 포함할 수 있으므로, 재귀 함수는 각 수준에서 자신을 호출하여 하위 항목을 탐색할 수 있습니다. 이러한 구조는 "얼마나 깊게 중첩될지 알 수 없기 때문에" 일반적인 반복문으로는 구현하기 어렵습니다.
    
```python
# 중첩된 디렉토리(딕셔너리)를 순회하여 파일 경로 목록 생성
def list_files_recursive(current_file_tree, current_path=""):
	file_paths = [] # 찾은 파일 경로들을 저장할 리스트

	# 현재 파일 트리의 각 항목(노드)을 순회
	for node_name, node_content in current_file_tree.items():
		# 현재 노드의 전체 경로를 생성합니다.
		# current_path가 비어있으면 node_name만, 아니면 current_path/node_name 형식으로 만듭니다.
		new_path = f"{current_path}/{node_name}" if current_path else node_name

		# 노드 내용이 None이면 파일 (더 이상 중첩 없음)
		if node_content is None:
			file_paths.append(new_path)
		# 노드 내용이 딕셔너리이면 디렉토리 (중첩된 구조)
		elif isinstance(node_content, dict):
			# 재귀적으로 하위 디렉토리를 탐색하고, 그 결과를 현재 목록에 추가합니다.
			file_paths.extend(list_files_recursive(node_content, new_path))

	return file_paths

# 예시 파일 트리 (딕셔너리 형태)
file_tree_example = {
	"documents": {
		"proposal.docx": None,
		"receipts": {
			"january": {
				"grocery.pdf": None,
				"electric.pdf": None
			},
			"february": {
				"rent.pdf": None
			}
		}
	},
	"photos": {
		"vacation": {
			"beach.jpg": None,
			"mountain.jpg": None
		},
		"profile.png": None
	}
}

print("파일 시스템 경로 목록:")
for path in list_files_recursive(file_tree_example):
	print(path)
# 예상 출력:
# 파일 시스템 경로 목록:
# documents/proposal.docx
# documents/receipts/january/grocery.pdf
# documents/receipts/january/electric.pdf
# documents/receipts/february/rent.pdf
# photos/vacation/beach.jpg
# photos/vacation/mountain.jpg
# photos/profile.png
```
    
이 함수는 파일 시스템의 임의의 깊이를 처리할 수 있으며, 각 디렉토리 수준에서 재귀적으로 호출되어 모든 파일을 찾아냅니다.
    

이처럼 재귀는 파이썬에서 몇 가지 특이점을 가지지만, **복잡하거나 중첩된 데이터 구조를 다루는 문제에 대해 매우 우아하고 직관적인 해결책을 제공하는 강력한 도구**입니다. 성능 저하를 고려해야 하지만, `lru_cache`와 같은 내장 도구를 사용하여 효율성을 개선할 수 있습니다.