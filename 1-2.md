## 제2장: 불변성(Immutability)

여러분, 안녕하세요! "파이썬으로 쉽게 풀어 쓴 함수형 프로그래밍"의 두 번째 장에 오신 것을 환영합니다. 지난 장에서는 명령형 프로그래밍과 선언형 프로그래밍의 큰 그림을 그렸죠? 이번 장에서는 선언형 프로그래밍, 특히 함수형 프로그래밍의 핵심 기둥 중 하나인 **불변성(Immutability)**에 대해 깊이 파고들어 볼 거예요.

프로그래밍에서 데이터는 마치 살아있는 생명체처럼 계속 변한다고 생각하기 쉽습니다. 하지만 이 데이터를 다루는 방식, 즉 **가변성(Mutability)**과 **불변성(Immutability)**은 우리가 만드는 코드의 품질과 동작 방식에 어마어마한 영향을 미칩니다. 함수형 프로그래밍은 특히 **불변성**을 가장 중요한 원칙으로 강조해요. 불변성은 한 번 만들어진 데이터는 절대로 그 값을 바꿀 수 없다는 뜻인데, 이게 왜 그렇게 중요할까요? 바로 코드의 예측 가능성을 높이고, 우리가 예상치 못한 문제(부수 효과, side effects)를 줄이며, 궁극적으로는 더 튼튼하고 이해하기 쉬운 코드를 만드는 데 결정적인 역할을 하기 때문입니다.

### 불변 데이터: 한 번 생성되면 변경할 수 없는 값입니다.

불변 데이터는 말 그대로 **한 번 만들어지면 그 값을 변경할 수 없는 값**을 의미합니다. 마치 여러분이 책에 연필로 글씨를 썼다가 지우개로 지우는 대신, 새로운 종이에 다시 쓰는 것과 비슷하다고 생각하면 돼요. 일단 설정된 값은 영원히 그대로 유지되며, 변경될 염려가 없습니다. 이는 데이터의 상태가 예측 가능하게 유지되어, 시간이 지남에 따라 변수의 상태가 어떻게 변경되었는지 추적하기 어려워지는 명령형 코드의 단점을 해소합니다.

파이썬은 객체 지향 및 명령형 패러다임과 함께 함수형 프로그래밍 개념을 부분적으로 지원하는 **다중 패러다임 언어**입니다. 그래서 파이썬에는 본질적으로 불변인 데이터 타입과 가변인 데이터 타입이 공존해요. 먼저 불변 타입부터 살펴볼까요?

- **파이썬의 불변(Immutable) 타입**:
    
    - **숫자 (Integers, Floats 등)**: 숫자 값은 한 번 할당되면 변경할 수 없습니다. 예를 들어 `x = 5`라고 했을 때 `x = x + 1`은 `x`의 값을 변경하는 것이 아니라, `x`가 새로운 숫자 객체 `6`을 참조하도록 재할당하는 것입니다. 기존의 `5`는 그대로 메모리에 남아있고, `x`라는 이름표만 `6`이 있는 곳으로 옮겨가는 거죠.
        
    - **문자열 (Strings)**: 파이썬의 문자열은 불변 객체입니다. 문자열에 대한 어떤 조작(예: 대문자 변환, 일부 교체)을 수행하더라도, **원본 문자열이 변경되는 것이 아니라 새로운 문자열 객체가 반환**됩니다. 예를 들어, `my_string = "hello"`일 때 `my_string.upper()`를 호출하면 `"HELLO"`라는 새로운 문자열이 생성되고 반환되지만, `my_string` 자체는 여전히 `"hello"`입니다.
        
    - **튜플 (Tuples)**: 튜플은 변경할 수 없는 순서 있는 컬렉션입니다. 한 번 생성된 튜플에 요소를 추가하거나 제거하거나 변경할 수 없습니다. 튜플의 값을 변경해야 한다면, 기존 튜플의 값을 사용하여 **새로운 튜플의 복사본을 생성**해야 합니다.
        

```
# 파이썬의 불변 타입 예시
# ID는 파이썬 객체의 메모리 주소를 나타냅니다. ID가 다르면 다른 객체라는 뜻이에요.

# 1. 숫자 (int)
num = 10
print(f"초기 숫자: {num}, ID: {id(num)}") # ID는 메모리 주소
num = num + 5 # num에 새로운 값 15를 할당합니다.
print(f"변경 후 숫자: {num}, ID: {id(num)}")
# 초기 ID와 변경 후 ID가 다름을 확인할 수 있습니다.
# 이는 num이라는 변수가 원래 10을 가리키다가, 15라는 새로운 객체를 가리키게 되었다는 뜻입니다.

# 2. 문자열 (str)
s = "Python"
print(f"초기 문자열: {s}, ID: {id(s)}")
s_upper = s.upper() # s.upper()는 "PYTHON"이라는 새로운 문자열 객체를 생성합니다.
print(f"대문자 변환 후: {s_upper}, ID: {id(s_upper)}")
print(f"원본 문자열: {s}, ID: {id(s)}")
# s_upper는 새로운 ID를 가집니다. 원본 문자열 s는 변경되지 않고 그대로 "Python"입니다.

# 3. 튜플 (tuple)
t = (1, 2, 3)
print(f"초기 튜플: {t}, ID: {id(t)}")
# t[0] = 100 # TypeError: 'tuple' object does not support item assignment (튜플은 개별 요소 변경 불가)

# 새 튜플 생성 (기존 튜플은 변경되지 않음)
new_t = t + (4,) # 기존 튜플 t에 (4,) 튜플을 더해 새로운 튜플 (1, 2, 3, 4)를 만듭니다.
print(f"새 튜플: {new_t}, ID: {id(new_t)}")
print(f"원본 튜플: {t}, ID: {id(t)}")
# new_t는 새로운 ID를 가집니다. 원본 튜플 t는 변경되지 않고 그대로 (1, 2, 3)입니다.
```

이러한 불변 타입들은 함수형 프로그래밍의 불변성 원칙과 아주 잘 맞아떨어집니다.

- **파이썬의 가변(Mutable) 타입**:
    
    - **리스트 (Lists)**: 리스트는 요소를 추가, 제거, 변경할 수 있는 순서 있는 컬렉션입니다. 이러한 **"제자리 변경(in-place modification)"**은 함수형 프로그래밍에서 피하고자 하는 동작입니다. 예를 들어, `my_list[0] = "H4"`와 같이 리스트의 특정 인덱스 값을 직접 변경하는 것은 명령형 방식의 변이(mutation)에 해당하며, 이는 예기치 않은 문제를 야기할 수 있습니다.
        
    - **딕셔너리 (Dictionaries)**: 딕셔너리는 키-값 쌍을 저장하며, 키와 값을 추가, 제거, 변경할 수 있는 가변 타입입니다.
        
    - **세트 (Sets)**: 세트는 중복을 허용하지 않는 가변 컬렉션이며, 요소를 추가하거나 제거할 수 있습니다.
        

```
# 파이썬의 가변 타입 예시
# ID가 동일하다는 것은 같은 메모리 공간의 객체가 변경되었다는 뜻입니다.

# 1. 리스트 (list)
my_list = [1, 2, 3]
print(f"초기 리스트: {my_list}, ID: {id(my_list)}")
my_list[0] = 100 # 원본 리스트의 첫 번째 값 변경
my_list.append(4) # 원본 리스트에 요소 추가
print(f"변경 후 리스트: {my_list}, ID: {id(my_list)}")
# ID가 동일함을 확인할 수 있습니다. (제자리 변경)
# 즉, my_list라는 변수가 가리키는 리스트 객체 자체가 변경된 것입니다.

# 2. 딕셔너리 (dict)
my_dict = {"name": "Alice", "age": 30}
print(f"초기 딕셔너리: {my_dict}, ID: {id(my_dict)}")
my_dict["age"] = 31 # 'age' 키의 값 변경
my_dict["city"] = "Seoul" # 'city'라는 새 키-값 추가
print(f"변경 후 딕셔너리: {my_dict}, ID: {id(my_dict)}")
# ID가 동일함을 확인할 수 있습니다.
# my_dict라는 변수가 가리키는 딕셔너리 객체 자체가 변경되었습니다.

# 3. 세트 (set)
my_set = {1, 2, 3}
print(f"초기 세트: {my_set}, ID: {id(my_set)}")
my_set.add(4) # 요소 추가
my_set.remove(1) # 요소 제거
print(f"변경 후 세트: {my_set}, ID: {id(my_set)}")
# ID가 동일함을 확인할 수 있습니다.
# my_set이라는 변수가 가리키는 세트 객체 자체가 변경되었습니다.
```

파이썬에서 함수형 프로그래밍을 할 때는 이러한 가변 타입들을 불변처럼 다루기 위한 전략이 필요합니다.

### 불변성의 중요성: 코드의 예측 가능성을 향상시키고, 의도치 않은 상태 변경으로 인한 버그를 줄이며, 코드 이해 및 디버깅을 용이하게 합니다.

불변성이 왜 그렇게 중요할까요? 바로 함수형 프로그래밍의 핵심 목표인 **예측 가능성, 유지보수성, 디버깅 용이성**과 직접적으로 연결되기 때문입니다.

1. **코드의 예측 가능성 향상**:
    
    - 변수가 불변이라는 것은 **한 번 생성된 이후에는 변경되지 않았음을 확신할 수 있다**는 의미입니다. 이는 가변 변수로 인해 발생하는 수많은 버그의 원인을 제거합니다.
        
    - 예를 들어, 함수가 인수로 받은 객체를 내부에서 변경한다면, 이 함수를 호출하는 다른 부분의 코드는 변경된 객체에 의존하게 되고, 이는 예상치 못한 동작을 유발할 수 있습니다. 불변성을 지키면 이런 "숨겨진" 상태 변경에 대해 걱정할 필요가 없습니다. 데이터베이스 상태, 인터넷 연결 여부 등 외부 요인에 의해 함수 동작이 예측 불가능해지는 문제(‘내 컴퓨터에서는 잘 되는데?’ 밈을 유발하는 문제)가 줄어듭니다.
        
2. **의도치 않은 상태 변경으로 인한 버그 감소**:
    
    - 함수형 프로그래밍은 **객체를 제자리에서 변경하는 것(mutation)을 피합니다**. 이는 이러한 변경이 많은 문제와 의도치 않은 결과를 초래할 수 있기 때문입니다.
        
    - 지난 장에서 잠깐 언급했던 **순수 함수(Pure Functions)**는 두 가지 중요한 특성을 가집니다: **동일한 인수가 주어지면 항상 동일한 값을 반환**하고, **부수 효과(side effects)를 일으키지 않습니다**. 불변성은 이러한 부수 효과를 제거하는 데 필수적입니다. 함수가 자신의 범위 밖의 상태를 변경하는 '부수 효과'를 일으킬 가능성이 높아지는 명령형 코드의 단점을 해소합니다.
        

```
# 부수 효과가 있는 함수 (명령형 스타일)
# 이 함수는 외부 변수 `total`의 값을 직접 변경합니다.
total = 0
def add_to_total(num):
    global total # 외부 상태인 'total'을 직접 변경하겠다고 선언
    total += num

add_to_total(5)
print(f'부수 효과 예시: {total}') # total이 5로 변경됨

add_to_total(10)
print(f'부수 효과 예시 (다시 호출 후): {total}') # total이 15로 또 변경됨. 함수의 결과가 외부 상태에 따라 달라짐.

# 순수 함수 (선언형/함수형 스타일)
# 이 함수는 외부 상태에 의존하지 않고, 입력값만을 가지고 결과를 반환합니다.
def pure_add(a, b):
    return a + b # 외부 상태를 변경하지 않고, 입력값에만 의존

result1 = pure_add(3, 7)
print(f'순수 함수 예시 1: {result1}') # 항상 10을 반환

result2 = pure_add(3, 7)
print(f'순수 함수 예시 2: {result2}') # 다시 호출해도 항상 10을 반환, 외부 영향 없음
```

이처럼 순수 함수는 예측 가능하고 테스트하기 쉽다는 큰 장점이 있습니다.

3. **코드 이해 및 디버깅 용이성**:
    
    - 변수의 상태를 계속해서 변경하지 않음으로써, 코드가 더 명확해지고 이해하기 쉬워집니다.
        
    - **"어떻게(how)" 작동하는지보다는 "무엇을(what)" 원하는지에 집중**하게 되어 코드의 전체적인 의도를 파악하기 쉬워집니다.
        
    - 변수 상태를 추적할 필요가 없기 때문에 **디버깅이 훨씬 쉬워집니다**. 특히 복잡한 코드나 여러 스레드가 동시에 실행되는 환경에서 가변 상태는 디버깅을 매우 어렵게 만듭니다. 순수 함수는 예측 가능하기 때문에 단위 테스트 작성도 매우 용이하며, 테스트가 통과하면 프로덕션에서도 동일하게 작동할 것이라고 기대할 수 있습니다.
        
4. **확장성(Scalability) 및 병렬 처리**:
    
    - 요즘 컴퓨터는 여러 작업을 동시에 처리하는 **병렬 처리(Parallel Processing)**가 중요해지고 있습니다. 명령형 코드에서는 여러 스레드나 프로세스가 같은 데이터를 동시에 변경하려 할 때 충돌이 발생할 수 있습니다. 이를 **경쟁 조건(Race Condition)**이라고 부르며, 해결하기 매우 까다롭습니다.
        
    - 하지만 선언형 코드, 특히 불변성을 사용하는 코드에서는 데이터가 변경되지 않으므로, 여러 스레드가 동시에 데이터를 읽어도 아무런 문제가 발생하지 않습니다. 마치 여러 사람이 동시에 같은 책을 읽어도 책 내용이 바뀌지 않는 것과 같아요. 이는 병렬 처리를 훨씬 쉽게 만들어 줍니다. 데이터가 불변하기 때문에 여러 프로세스에 걸쳐 쉽게 복사 및 분산될 수 있으며, 각 액터(actor)가 자신만의 데이터 복사본을 가지므로 다른 액터가 상태를 변경할 염려 없이 모든 것이 격리된 환경에서 실행됩니다. 이는 분산 시스템에서 부하를 수평적으로 분산하는 데 매우 강력한 이점을 제공합니다.
        

### 파이썬에서 불변성을 지향하는 방법: 기존 데이터를 변경하는 대신 새로운 복사본을 반환합니다.

파이썬은 완전한 함수형 언어는 아니므로, 불변성 원칙을 엄격하게 지키려면 개발자의 노력이 필요합니다. 하지만 걱정 마세요! 핵심적인 방법은 **기존 데이터를 변경하는 대신 항상 새로운 복사본을 반환**하는 것입니다. 마치 원본 사진을 그대로 두고 편집된 새로운 사진을 만드는 것과 비슷하죠.

- **데이터 변경 시 새 복사본 반환**:
    
    - 변수 값을 직접 변경하는 대신, 기존 값을 인수로 받아들이고 **업데이트된 새로운 값의 복사본을 반환하는 함수**를 작성합니다. 이는 함수의 입력값을 포함하여 함수의 범위 밖의 어떤 것도 변경해서는 안 된다는 순수 함수의 원칙을 따릅니다.
        
    - 예를 들어, 앞서 보았던 리스트의 특정 요소를 변경하는 시나리오에서, 명령형 방식은 `rooms[2] = "H4"`와 같이 원본 리스트를 직접 변경했지만, 불변형 방식은 `map` 함수나 리스트 컴프리헨션을 사용하여 `rooms` 리스트의 각 요소를 확인하고, `"H3"`일 경우 `"H4"`를 반환하고, 그 외에는 기존 요소를 그대로 반환하여 **새로운 `new_rooms` 리스트를 생성**합니다. 이때 원본 `rooms` 리스트는 변경되지 않습니다.
        

```
# 리스트 변경을 통한 불변성 지향 예시

# 명령형 (가변) 방식: 원본 리스트를 직접 변경
mutable_list = ["H1", "H2", "H3"]
print(f"가변 방식 초기 리스트: {mutable_list}")
mutable_list[2] = "H4" # 원본 리스트의 세 번째 요소 변경
print(f"가변 방식 변경 후 리스트: {mutable_list}") # ['H1', 'H2', 'H4']

# 함수형 (불변) 방식: 새로운 복사본 반환
original_rooms = ["H1", "H2", "H3"]
print(f"불변 방식 초기 리스트: {original_rooms}")

# 리스트 컴프리헨션을 사용하여 새로운 리스트 생성
# 각 room을 순회하며, 만약 room이 "H3"이면 "H4"로 바꾸고, 아니면 그대로 둡니다.
immutable_rooms = [
    "H4" if room == "H3" else room
    for room in original_rooms
]
print(f"불변 방식 새 리스트: {immutable_rooms}") # ['H1', 'H2', 'H4']
print(f"불변 방식 원본 리스트: {original_rooms}") # ['H1', 'H2', 'H3'] (변경 없음)
```

- **가변 타입을 불변처럼 다루기**:
    
    - **리스트**: 요소를 추가하거나 제거할 때 `append()`, `remove()` 같은 제자리 변경 메서드 대신, `+` 연산자나 리스트 컴프리헨션(list comprehension), `slice`를 사용하여 **새로운 리스트를 생성**합니다.
        
    
    ```
    # 리스트에 요소 추가 (불변성 유지)
    def add_element_immutable(lst, element):
        # 기존 리스트 lst와 추가할 요소 [element]를 더해 새로운 리스트를 반환합니다.
        return lst + [element] # 새 리스트 반환
    
    my_list = [1, 2, 3]
    updated_list = add_element_immutable(my_list, 4)
    print(f"원본 리스트: {my_list}") # [1, 2, 3]
    print(f"새 리스트: {updated_list}") # [1, 2, 3, 4]
    
    # 리스트에서 요소 제거 (불변성 유지)
    def remove_element_immutable(lst, element):
        # 리스트 컴프리헨션을 사용하여 element와 같지 않은 요소들로만 새 리스트를 만듭니다.
        return [x for x in lst if x != element] # 해당 요소 제외한 새 리스트 반환
    
    my_list = [1, 2, 3, 4, 5]
    filtered_list = remove_element_immutable(my_list, 3)
    print(f"원본 리스트: {my_list}") # [1, 2, 3, 4, 5]
    print(f"필터링된 리스트: {filtered_list}") # [1, 2, 4, 5]
    ```
    
    - **딕셔너리**: 딕셔너리를 업데이트할 때 `update()` 메서드나 직접 할당(`dict[key] = value`) 대신 `dict.copy()`를 사용하거나 새로운 딕셔너리를 병합하여 만듭니다. 파이썬 3.9+부터는 `|` 연산자로 딕셔너리 병합이 가능해 불변성 유지가 더 간결해졌습니다.
        
    
    ```
    # 딕셔너리 업데이트 (불변성 유지)
    def update_dict_immutable(original_dict, key, value):
        # original_dict의 모든 요소를 풀고, key: value 쌍을 덮어씌워 새 딕셔너리를 만듭니다.
        return {**original_dict, key: value} # 새 딕셔너리 반환 (Python 3.5+ 이상)
        # Python 3.9+ 에서는 더 간결하게: return original_dict | {key: value}
    
    my_dict = {"a": 1, "b": 2}
    updated_dict = update_dict_immutable(my_dict, "b", 20) # 'b'의 값을 20으로 변경
    updated_dict_new_key = update_dict_immutable(my_dict, "c", 30) # 'c'라는 새 키 추가
    print(f"원본 딕셔너리: {my_dict}") # {'a': 1, 'b': 2}
    print(f"업데이트된 딕셔너리: {updated_dict}") # {'a': 1, 'b': 20}
    print(f"새 키 추가된 딕셔너리: {updated_dict_new_key}") # {'a': 1, 'b': 2, 'c': 30}
    ```
    
    - **세트**: 요소를 추가하거나 제거할 때 `add()`, `remove()` 같은 제자리 변경 메서드 대신, `union()` 또는 세트 컴프리헨션을 사용하여 **새로운 세트를 생성**합니다.
        
    
    ```
    # 세트에 요소 추가 (불변성 유지)
    def add_to_set_immutable(original_set, element):
        # original_set과 {element}를 합쳐 새로운 세트를 반환합니다.
        return original_set.union({element}) # 새 세트 반환
    
    my_set = {1, 2, 3}
    updated_set = add_to_set_immutable(my_set, 4)
    print(f"원본 세트: {my_set}") # {1, 2, 3}
    print(f"새 세트: {updated_set}") # {1, 2, 3, 4}
    ```
    
- **성능과 메모리 효율성 고려**:
    
    - 불변성을 지키기 위해 모든 데이터 변경 시 새로운 복사본을 생성하는 것은 **성능 및 메모리 효율성 측면에서 단점**이 될 수 있습니다. 특히 대규모 객체를 다룰 때, 변경되지 않은 부분까지 매번 복사해야 한다면 상당한 오버헤드가 발생할 수 있습니다. 이는 트레이드오프 관계이며, 상황에 따라 신중하게 결정해야 합니다.
        
    - 일부 순수 함수형 언어(예: Clojure)는 이러한 성능 문제를 해결하기 위해 **영구 데이터 구조(Persistent Data Structures)**와 **구조적 공유(Structural Sharing)** 개념을 도입했습니다. 영구 데이터 구조는 데이터를 변경할 때 변경된 부분만 새로 만들고, 변경되지 않은 부분은 기존 구조와 공유하는 방식이에요. 마치 책의 한 페이지만 수정하고, 나머지 페이지는 그대로 두는 것과 같죠. 이는 메모리 사용을 최적화하는 기술입니다. 파이썬의 내장 타입은 이러한 구조적 공유를 자동으로 제공하지 않지만, 개념을 이해하는 것은 함수형 사고방식에 중요합니다. 경우에 따라 `frozenset`과 같이 불변성을 명시적으로 제공하는 라이브러리나 내장 타입을 활용할 수 있습니다.
        

불변성을 지향하는 것은 파이썬에서 함수형 프로그래밍을 효과적으로 적용하기 위한 핵심적인 단계입니다. 비록 파이썬이 모든 측면에서 순수 함수형 언어의 장점을 제공하지는 않지만, 불변성 원칙을 따르는 것만으로도 코드의 품질과 안정성을 크게 향상시킬 수 있습니다.

**결론**: 제2장에서는 **불변성(Immutability)**의 개념과 파이썬의 불변/가변 데이터 타입을 살펴보았습니다. 우리는 **불변 데이터가 코드의 예측 가능성을 높이고, 버그를 줄이며, 디버깅을 용이하게 하는 근본적인 이점**을 제공함을 이해했습니다. 또한, 파이썬과 같이 가변 타입이 존재하는 언어에서 **기존 데이터를 변경하는 대신 새로운 복사본을 반환하는 방식**으로 불변성 원칙을 지키는 구체적인 방법들을 배웠습니다. 이러한 불변성 지향은 궁극적으로 코드의 **확장성과 병렬 처리 능력**을 향상시키는 데 기여합니다. 다음 장에서는 함수형 프로그래밍의 또 다른 핵심 개념인 **순수 함수(Pure Functions)**에 대해 더 깊이 다룰 것입니다. 순수 함수는 오늘 배운 불변성 개념과 밀접하게 연결되어 있으며, 코드의 신뢰성을 극대화하는 데 중요한 역할을 합니다.