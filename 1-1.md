### 제1장: 명령형(Imperative) vs. 선언형(Declarative) 프로그래밍

안녕하세요! "파이썬으로 쉽게 풀어 쓴 함수형 프로그래밍"의 첫 장을 시작하게 된 것을 환영합니다. 프로그래밍을 처음 배우기 시작했을 때, 우리는 컴퓨터에게 "어떻게" 해야 할지 하나하나 세세하게 가르치는 방식을 주로 사용했어요. 그런데 사실 프로그래밍에는 다양한 스타일, 즉 **패러다임**이 존재합니다. 이 책에서는 그중에서도 가장 기본이 되는 두 가지 스타일, 바로 **명령형(Imperative) 프로그래밍**과 **선언형(Declarative) 프로그래밍**에 대해 깊이 있게 이야기해 보려고 합니다.

여러분은 혹시 '어떻게'와 '무엇을'이라는 두 가지 질문이 프로그래밍 방식에 어떤 큰 차이를 가져올지 상상해 본 적 있으신가요? 이 두 방식은 어느 하나가 무조건 좋다고 할 수 있는 관계는 아니에요. 마치 망치와 드라이버처럼, 어떤 문제를 해결하느냐에 따라 더 적합한 도구가 달라질 수 있습니다. 하지만 최근에는 특히 코드의 가독성, 유지보수성, 그리고 예측 가능성을 높여주는 **선언형 프로그래밍**, 그중에서도 **함수형 프로그래밍**이 많은 주목을 받고 있습니다.

자, 그럼 먼저 우리가 익숙한 **명령형 프로그래밍**부터 자세히 알아볼까요?

### 명령형 프로그래밍: "어떻게"(How) 코드를 실행할지 모든 구현 세부 사항을 정의하는 방식입니다.

명령형 프로그래밍은 컴퓨터에게 단순히 "무엇을 해줘"라고 말하는 것이 아니라, "어떻게" 그 일을 해야 하는지 모든 과정을 빠짐없이 지시하는 방식입니다. 요리 레시피에 비유하면, 재료를 썰고, 양념을 넣고, 몇 분 동안 끓이는지 같은 모든 단계를 상세하게 적는 것과 같아요. 이 방식은 **코드의 실행 순서**와 **변수의 상태 변화**에 초점을 맞춥니다.

**특징을 좀 더 쉽게 풀어보면 이렇습니다.**

- **단계별 지시**: 코드는 한 줄씩 위에서 아래로 순서대로 실행돼요. 우리는 각 단계에서 어떤 일이 벌어질지 직접 정의해야 합니다.
    
- **상태 직접 조작**: 변수나 객체의 값을 직접 변경해요. 예를 들어, `x = x + 1`처럼 변수의 값을 할당하거나 업데이트하는 식이죠.
    
- **명시적인 흐름 제어**: `for` 루프, `while` 루프, `if/else` 조건문 등을 사용해서 코드가 어떤 순서로 실행될지 명확하게 우리가 제어합니다.
    

**예시 1: 목록에서 특정 조건에 맞는 요소 찾기**

대학생들의 목록에서 여성 학생들만 골라내는 시나리오를 생각해 봅시다.

```
from enum import Enum

class Gender(Enum):
    MALE = "MALE"
    FEMALE = "FEMALE"
    PREFER_NOT_TO_SAY = "PREFER_NOT_TO_SAY"

class Person:
    def __init__(self, name, gender):
        self.name = name
        self.gender = gender

    def __repr__(self):
        return f"Person(name='{self.name}', gender={self.gender.name})"

people = [
    Person("John", Gender.MALE),
    Person("Maria", Gender.FEMALE),
    Person("Aisha", Gender.FEMALE),
    Person("Alex", Gender.MALE),
    Person("Alice", Gender.FEMALE),
    Person("Bob", Gender.PREFER_NOT_TO_SAY)
]

# 명령형 방식: 여성만 필터링
females_imperative = [] # 1. 결과를 담을 빈 리스트를 만듭니다.
for person in people: # 2. 'people' 리스트의 모든 사람을 '어떻게' 순회할지 'for' 루프를 직접 만듭니다.
    if person.gender == Gender.FEMALE: # 3. 각 사람이 여성인지 'if' 조건문으로 직접 확인합니다.
        females_imperative.append(person) # 4. 조건에 맞으면 빈 리스트에 '추가'하라고 직접 지시합니다.

print(f"명령형 결과: {females_imperative}")
```

이 코드를 보면, 우리는 "여성"을 찾아달라는 최종 목표 외에, 빈 리스트를 만들고, `for` 반복문을 돌고, `if` 조건문을 사용하는 등 **"어떻게"** 그 목표를 달성할지 모든 세부적인 절차를 직접 지시하고 있어요.

**예시 2: 자동차의 상태 변경**

자동차의 연료를 추가하거나 창문을 닦는 과정을 통해서도 명령형 프로그래밍의 특징을 볼 수 있습니다.

```
class Car:
    def __init__(self):
        self.gas = 0
        self.windows_clean = False
        self.four_wheel_drive = False

    def add_gas(self, gallons):
        self.gas += gallons # 'gas' 변수의 상태를 직접 변경합니다.

    def clean_windows(self):
        self.windows_clean = True # 'windows_clean' 변수의 상태를 직접 변경합니다.

    def set_four_wheel_drive(self, status):
        self.four_wheel_drive = status # 'four_wheel_drive' 변수의 상태를 직접 변경합니다.

# 명령형 방식: 자동차 객체의 상태를 직접 변경
my_car = Car() # 1. 'my_car'라는 자동차 객체를 하나 만듭니다.
my_car.add_gas(10) # 2. 'my_car'의 'gas' 상태를 10으로 업데이트하라고 지시합니다.
my_car.clean_windows() # 3. 'my_car'의 'windows_clean' 상태를 True로 업데이트하라고 지시합니다.
my_car.set_four_wheel_drive(True) # 4. 'my_car'의 'four_wheel_drive' 상태를 True로 업데이트하라고 지시합니다.

print(f"자동차 가스: {my_car.gas}, 창문 깨끗함: {my_car.windows_clean}, 4륜 구동: {my_car.four_wheel_drive}")
```

이 예시에서는 `my_car`라는 **하나의 변수**가 `add_gas()`, `clean_windows()`, `set_four_wheel_drive()` 같은 메서드가 실행될 때마다 내부 상태가 계속해서 변하는 것을 볼 수 있습니다.

**예시 3: 리스트의 합계 계산**

이번에는 숫자로 이루어진 리스트의 모든 요소를 더하는 과정을 명령형 방식으로 살펴봅시다.

```
# 명령형 방식: 리스트의 합계 계산
numbers = [1, 2, 3, 4, 5]
total = 0 # 1. 합계를 저장할 변수를 초기화합니다.
for num in numbers: # 2. 리스트를 순회하며 각 요소를 '어떻게' 더할지 지시합니다.
    total += num # 3. 'total' 변수의 상태를 직접 변경합니다.
print(f"명령형 합계: {total}")
```

물론 명령형 프로그래밍은 컴퓨터의 동작 방식과 매우 유사해서 직관적인 면도 있습니다. 하지만 코드가 복잡해질수록 몇 가지 아쉬운 점들이 드러나기 시작합니다. 어떤 점들이 있을까요?

- **변수 상태 추적의 어려움**: 코드가 복잡해질수록, `my_car`처럼 변수의 상태가 언제, 어디서, 어떻게 바뀌었는지 파악하기가 어려워져요. 이것 때문에 디버깅(버그를 잡는 과정)이 매우 복잡해지곤 합니다.
    
- **가독성 저하**: "무엇을" 원하는지보다는 "어떻게" 작동하는지에 집중하다 보니, 코드 전체의 의도를 한눈에 파악하기가 어려울 수 있어요.
    
- **부수 효과(Side Effects)**: 함수가 외부 상태를 변경하는 것을 '부수 효과'라고 부르는데, 명령형에서는 흔히 발생합니다. 예를 들어, 전역 변수의 값을 바꾸거나, 데이터베이스에 기록하거나, 화면에 무엇인가를 출력하는 것들이 모두 부수 효과입니다. 이런 부수 효과가 많아지면 코드를 예측하기 어려워지고 버그가 발생할 확률이 높아져요. 반면, 함수형 프로그래밍에서는 함수가 오직 입력값에만 의존해서 결과값을 반환하고, 외부 상태를 전혀 변경하지 않는 '순수 함수(Pure Function)'를 지향합니다. 순수 함수는 마치 수학 함수처럼, 같은 입력에는 항상 같은 출력을 보장하고 외부 환경에 영향을 주지 않아요.
    

```
# 부수 효과가 있는 함수 (명령형 스타일)
total = 0
def add_to_total(num):
    global total # 외부 상태인 'total'을 직접 변경
    total += num
add_to_total(5)
print(f'부수 효과 예시: {total}') # total이 5로 변경됨

# 순수 함수 (선언형/함수형 스타일)
def pure_add(a, b):
    return a + b # 외부 상태를 변경하지 않고, 입력값에만 의존
result = pure_add(3, 7)
print(f'순수 함수 예시: {result}') # 항상 10을 반환, 외부 영향 없음
```

이처럼 순수 함수는 예측 가능하고 테스트하기 쉽다는 큰 장점이 있습니다.

### 선언형 프로그래밍: "무엇을"(What) 원하는지 명시하고, "어떻게"(How) 달성할지는 언어/프레임워크에 맡기는 방식입니다.

이제 명령형과는 정반대인 **선언형 프로그래밍**에 대해 알아볼까요? 선언형 프로그래밍은 우리가 **"무엇을"** 원하는지 말하고, **"어떻게"** 그 목표를 달성할지는 파이썬 같은 프로그래밍 언어나 사용하는 프레임워크에게 맡기는 방식입니다. 마치 레스토랑에서 "스테이크 주세요"라고 주문하면, 주방장이 어떻게 스테이크를 요리할지는 신경 쓰지 않는 것과 같아요. 혹은 목적지까지 가기 위해 직접 운전하는 것(명령형)이 아니라, 택시를 불러서 '어디로 가주세요'라고 말하는 것(선언형)과 비슷하죠. 우리는 최종 목표만 말하면 됩니다. 이 방식은 **데이터의 변환**에 더 중점을 둡니다.

**특징을 좀 더 쉽게 풀어보면 이렇습니다.**

- **결과 중심**: 우리는 최종적으로 얻고 싶은 결과가 무엇인지 명시적으로 선언합니다.
    
- **추상화**: 구현에 필요한 세부적인 절차는 언어나 프레임워크가 알아서 처리해주기 때문에, 우리는 더 중요한 비즈니스 로직에 집중할 수 있어요.
    
- **불변성 강조**: 대부분의 경우, 한 번 만들어진 데이터는 변경하지 않고, 변경이 필요할 때는 항상 **새로운 데이터를 만들어서 반환**하는 방식을 사용합니다. 이를 **불변성(Immutability)**이라고 해요.
    

**예시 1: 목록에서 특정 조건에 맞는 요소 찾기 (선언형)**

앞서 봤던 "여성 학생만 골라내기" 시나리오를 선언형 방식으로 다시 풀어볼게요.

```
from enum import Enum

class Gender(Enum):
    MALE = "MALE"
    FEMALE = "FEMALE"
    PREFER_NOT_TO_SAY = "PREFER_NOT_TO_SAY"

class Person:
    def __init__(self, name, gender):
        self.name = name
        self.gender = gender

    def __repr__(self):
        return f"Person(name='{self.name}', gender={self.gender.name})"

people = [
    Person("John", Gender.MALE),
    Person("Maria", Gender.FEMALE),
    Person("Aisha", Gender.FEMALE),
    Person("Alex", Gender.MALE),
    Person("Alice", Gender.FEMALE),
    Person("Bob", Gender.PREFER_NOT_TO_SAY)
]

# 선언형 방식: 여성만 필터링
# filter 함수와 람다(익명 함수)를 사용하여 '무엇을' 필터링할지 선언합니다.
females_declarative = list(filter(lambda person: person.gender == Gender.FEMALE, people))
print(f"선언형 결과: {females_declarative}")
```

이 코드를 보면, 우리는 `filter()` 함수에게 `people` 리스트에서 "성별이 여성인 사람들을 **필터링해줘**"라고 **무엇을** 원하는지 선언만 했습니다. `filter()` 함수가 내부적으로 `for` 루프를 돌며 어떻게 조건을 검사하는지는 우리가 직접 작성하지 않았습니다. 이처럼 선언형 방식은 훨씬 **간결하고 표현력이 풍부한 코드**를 만들 수 있습니다.

**예시 2: 자동차의 상태 변경 (선언형, 불변성)**

이제 두 번째 예시였던 자동차의 상태 변경을 선언형 방식으로, 특히 **불변성** 개념을 활용해서 구현해 볼까요? 불변성이란 한 번 생성된 데이터는 절대 변경할 수 없다는 원칙입니다. 만약 어떤 값을 바꾸고 싶다면, 기존 데이터를 변경하는 대신 변경된 값이 담긴 **새로운 데이터를 만들어내는** 방식이죠.

파이썬에서는 `tuple`이 대표적인 불변 객체입니다. 리스트(list)와 달리 `tuple`은 요소를 추가하거나 변경할 수 없어요. 여기서는 `namedtuple`을 사용해서 자동차의 상태를 불변 객체로 표현해 보겠습니다.

```
from collections import namedtuple

# 'CarState'를 불변 객체로 표현합니다. namedtuple은 튜플처럼 한 번 만들어지면 값을 변경할 수 없습니다.
CarState = namedtuple('CarState', ['gas', 'windows_clean', 'four_wheel_drive'])

# 초기 자동차 상태를 정의합니다.
initial_car = CarState(gas=0, windows_clean=False, four_wheel_drive=False)

# 함수형(선언형) 방식: 원본 객체를 변경하지 않고 새로운 상태를 반환하는 함수들을 만듭니다.
# 여기서 중요한 것은 'car' 객체를 직접 수정하지 않고, 새로운 'CarState' 객체를 반환한다는 점입니다.
def add_gas_func(car, gallons):
    # car._replace()는 기존 'CarState' 객체를 변경하지 않고, 'gas'만 업데이트된 새로운 객체를 반환합니다.
    # 마치 기존 자동차 상태를 기반으로 '가스'만 채운 '새로운 자동차'를 만드는 것과 같아요.
    return car._replace(gas=car.gas + gallons)

def clean_windows_func(car):
    # 마찬가지로, 기존 'car'의 'windows_clean' 상태만 True로 바뀐 새로운 'CarState' 객체를 반환합니다.
    return car._replace(windows_clean=True)

def set_four_wheel_drive_func(car, status):
    # 4륜 구동 상태만 변경된 새로운 'CarState' 객체를 반환합니다.
    return car._replace(four_wheel_drive=status)

# 함수들을 연결해서 사용합니다. 마치 파이프라인처럼!
# 각 함수는 이전 함수의 결과를 받아서 새로운 결과를 만들어냅니다.
car_after_gas = add_gas_func(initial_car, 10) # initial_car는 그대로, 새로운 car_after_gas 생성
car_after_cleaning = clean_windows_func(car_after_gas) # car_after_gas는 그대로, 새로운 car_after_cleaning 생성
final_car_state = set_four_wheel_drive_func(car_after_cleaning, True) # car_after_cleaning은 그대로, 최종 final_car_state 생성

print(f"최종 자동차 상태: {final_car_state}")
print(f"초기 자동차 상태는 여전히 그대로: {initial_car}")
```

이 코드의 핵심은 `initial_car` 객체가 변경되지 않고 그대로 남아있다는 점입니다. `add_gas_func` 같은 함수들은 기존 상태를 받아서 **새로운 상태 객체를 만들어 반환**합니다. 이렇게 되면 `my_car`라는 하나의 변수가 계속 바뀌는 명령형 방식과 달리, 각 단계의 상태(예: `initial_car`, `car_after_gas`, `car_after_cleaning`, `final_car_state`)를 명확하게 추적할 수 있습니다. 덕분에 코드를 읽고 추론하기가 훨씬 쉬워지고, 예측 불가능한 버그를 줄일 수 있어요.

여기서 잠깐, `namedtuple`과 `_replace()`에 대해 좀 더 자세히 알아볼까요?

**개념 설명: `namedtuple`과 불변성**

파이썬의 `tuple`은 대표적인 **불변(Immutable) 객체**입니다. 한 번 생성되면 그 내용을 변경할 수 없죠. 반면에 `list`는 **가변(Mutable) 객체**로, 생성된 후에도 요소를 추가하거나 변경할 수 있습니다.

`namedtuple`은 `tuple`의 한 종류인데, 각 요소에 이름을 붙여서 마치 객체의 속성처럼 접근할 수 있게 해줍니다. 일반 튜플보다 훨씬 가독성이 좋죠. 예를 들어, `(0, False, False)` 대신 `CarState(gas=0, windows_clean=False, four_wheel_drive=False)`라고 표현할 수 있어서 코드를 읽는 사람이 훨씬 쉽게 이해할 수 있습니다.

그리고 `_replace()` 메서드는 `namedtuple`이 제공하는 아주 유용한 기능입니다. `namedtuple`은 불변이기 때문에 직접 속성 값을 변경할 수 없어요. 예를 들어, `initial_car.gas = 10`처럼 쓸 수 없다는 거죠. 이럴 때 `_replace()`를 사용하면, 기존 `namedtuple` 객체의 특정 속성만 변경된 **새로운 `namedtuple` 객체**를 반환해 줍니다. 원본은 그대로 유지하면서 변경된 버전만 새로 만드는 거죠. 이것이 바로 선언형 프로그래밍에서 강조하는 **불변성**을 구현하는 핵심적인 방법 중 하나입니다.

**예시 3: 리스트의 합계 계산 (선언형)**

이번에는 숫자로 이루어진 리스트의 모든 요소를 더하는 과정을 선언형 방식으로 살펴봅시다.

```
# 선언형 방식: 리스트의 합계 계산
numbers = [1, 2, 3, 4, 5]
# sum 함수를 사용하여 '무엇을' 할지 선언합니다.
total_declarative = sum(numbers)
print(f"선언형 합계: {total_declarative}")
```

이 코드를 보면, 우리는 `sum()` 함수에게 `numbers` 리스트의 "합계를 구해줘"라고 **무엇을** 원하는지 선언만 했습니다. `sum()` 함수가 내부적으로 어떻게 각 숫자를 더하는지는 우리가 직접 작성하지 않았습니다. 이처럼 선언형 방식은 훨씬 **간결하고 표현력이 풍부한 코드**를 만들 수 있습니다.

### 선언형 코드의 장점: 왜 주목해야 할까요?

이제 선언형 프로그래밍이 어떤 특징을 가지고 있는지 알았으니, 왜 많은 개발자들이 이 패러다임에 주목하고 있는지 그 장점들을 살펴봅시다.

1. **가독성 및 간결성**:
    
    - 선언형 코드는 "무엇을" 할지에 집중하기 때문에, 불필요한 "어떻게"에 대한 세부 구현이 줄어듭니다. 이는 코드를 더 짧고, 더 읽기 쉽게 만듭니다. 마치 잘 정리된 보고서처럼, 핵심 내용이 명확하게 드러나는 거죠.
        
    - 예를 들어, 리스트에서 특정 조건을 만족하는 요소를 찾는 경우, 명령형에서는 `for` 루프와 `if` 조건을 직접 명시해야 하지만, 선언형에서는 `filter()` 함수 하나로 의도를 명확하게 표현할 수 있습니다.
        
2. **예측 가능성 및 디버깅 용이성**:
    
    - **불변성**은 선언형 프로그래밍의 큰 장점 중 하나입니다. 데이터가 한 번 생성되면 변경되지 않기 때문에, 코드를 실행하는 동안 어떤 변수의 값이 예상치 못하게 바뀌는 일이 없습니다.
        
    - 변수의 상태 변화를 추적할 필요가 없으므로, 코드가 복잡해져도 버그를 찾고 수정하기가 훨씬 쉬워집니다. 각 함수가 독립적으로 작동하며 예측 가능한 결과를 내기 때문이죠.
        
3. **부수 효과(Side Effects) 최소화**:
    
    - 선언형 프로그래밍, 특히 함수형 프로그래밍에서는 함수가 자신의 입력값 외에 다른 외부 상태를 변경하지 않는 **순수 함수(Pure Function)**를 지향합니다.
        
    - 부수 효과가 없으면 코드의 예측 가능성이 높아지고, 여러 함수가 복잡하게 얽혀 있을 때 발생하는 예상치 못한 문제를 줄일 수 있습니다.
        
4. **병렬 처리 용이성**:
    
    - 요즘 컴퓨터는 여러 작업을 동시에 처리하는 **병렬 처리(Parallel Processing)**가 중요해지고 있습니다. 명령형 코드에서는 여러 스레드나 프로세스가 같은 데이터를 동시에 변경하려 할 때 충돌이 발생할 수 있습니다. 이를 **경쟁 조건(Race Condition)**이라고 부르며, 해결하기 매우 까다롭습니다.
        
    - 하지만 선언형 코드, 특히 불변성을 사용하는 코드에서는 데이터가 변경되지 않으므로, 여러 스레드가 동시에 데이터를 읽어도 아무런 문제가 발생하지 않습니다. 이는 병렬 처리를 훨씬 쉽게 만들어 줍니다.
        
5. **테스트 용이성**:
    
    - 순수 함수를 사용하면, 특정 입력에 대해 항상 동일한 출력을 보장하기 때문에 테스트 코드를 작성하기가 매우 쉽습니다. 외부 상태에 의존하지 않으므로, 테스트 환경을 복잡하게 설정할 필요 없이 함수 자체만 테스트하면 됩니다.
        

### 제1장 마무리: 명령형과 선언형, 그리고 앞으로의 여정

자, 이제 명령형 프로그래밍과 선언형 프로그래밍의 기본적인 차이점을 이해하셨을 거예요.

- **명령형 프로그래밍**은 "어떻게" 컴퓨터가 작업을 수행할지 모든 세부 단계를 직접 지시하는 방식입니다. 마치 요리사가 모든 재료 손질부터 조리법까지 하나하나 직접 지시하는 것과 같죠. 변수의 상태를 직접 변경하며, 코드의 실행 순서에 집중합니다.
    
- **선언형 프로그래밍**은 "무엇을" 원하는지 최종 결과에 집중하고, "어떻게" 그 결과를 얻을지는 언어나 프레임워크에 맡기는 방식입니다. 마치 손님이 레스토랑에서 단순히 메뉴를 주문하는 것과 같아요. 데이터의 변환에 중점을 두며, 불변성을 강조합니다.
    

두 패러다임 모두 프로그래밍에서 중요한 역할을 합니다. 하지만 현대 소프트웨어 개발에서는 코드의 복잡성이 증가하고, 유지보수성과 확장성이 중요해지면서 선언형 프로그래밍, 특히 그 핵심에 있는 **함수형 프로그래밍**의 가치가 더욱 커지고 있습니다.

다음 장에서는 선언형 프로그래밍의 꽃이라고 할 수 있는 **함수형 프로그래밍**의 기본 개념과 파이썬에서 이를 어떻게 활용할 수 있는지 더 깊이 있게 탐구해 볼 거예요. 함수형 프로그래밍이 여러분의 코드를 얼마나 더 깔끔하고 강력하게 만들 수 있는지 기대하셔도 좋습니다!